
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model SalesData
 * 
 */
export type SalesData = $Result.DefaultSelection<Prisma.$SalesDataPayload>
/**
 * Model ProductData
 * 
 */
export type ProductData = $Result.DefaultSelection<Prisma.$ProductDataPayload>
/**
 * Model StockData
 * 
 */
export type StockData = $Result.DefaultSelection<Prisma.$StockDataPayload>
/**
 * Model ImportBatch
 * 
 */
export type ImportBatch = $Result.DefaultSelection<Prisma.$ImportBatchPayload>
/**
 * Model AdvertisingData
 * 
 */
export type AdvertisingData = $Result.DefaultSelection<Prisma.$AdvertisingDataPayload>
/**
 * Model AdvertisingSettlement
 * 
 */
export type AdvertisingSettlement = $Result.DefaultSelection<Prisma.$AdvertisingSettlementPayload>
/**
 * Model ReturnsAndCancellations
 * 
 */
export type ReturnsAndCancellations = $Result.DefaultSelection<Prisma.$ReturnsAndCancellationsPayload>
/**
 * Model MarketplaceReimbursement
 * 
 */
export type MarketplaceReimbursement = $Result.DefaultSelection<Prisma.$MarketplaceReimbursementPayload>
/**
 * Model CommissionAdjustments
 * 
 */
export type CommissionAdjustments = $Result.DefaultSelection<Prisma.$CommissionAdjustmentsPayload>
/**
 * Model AffiliateSamples
 * 
 */
export type AffiliateSamples = $Result.DefaultSelection<Prisma.$AffiliateSamplesPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Brand
 * 
 */
export type Brand = $Result.DefaultSelection<Prisma.$BrandPayload>
/**
 * Model Supplier
 * 
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model PurchaseOrder
 * 
 */
export type PurchaseOrder = $Result.DefaultSelection<Prisma.$PurchaseOrderPayload>
/**
 * Model PurchaseOrderItem
 * 
 */
export type PurchaseOrderItem = $Result.DefaultSelection<Prisma.$PurchaseOrderItemPayload>
/**
 * Model CashFlowEntry
 * 
 */
export type CashFlowEntry = $Result.DefaultSelection<Prisma.$CashFlowEntryPayload>
/**
 * Model DashboardMetrics
 * 
 */
export type DashboardMetrics = $Result.DefaultSelection<Prisma.$DashboardMetricsPayload>
/**
 * Model ImportHistory
 * 
 */
export type ImportHistory = $Result.DefaultSelection<Prisma.$ImportHistoryPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model InvoiceItem
 * 
 */
export type InvoiceItem = $Result.DefaultSelection<Prisma.$InvoiceItemPayload>
/**
 * Model AffiliateEndorsement
 * 
 */
export type AffiliateEndorsement = $Result.DefaultSelection<Prisma.$AffiliateEndorsementPayload>
/**
 * Model AffiliateProductSale
 * 
 */
export type AffiliateProductSale = $Result.DefaultSelection<Prisma.$AffiliateProductSalePayload>
/**
 * Model ActivityLogs
 * 
 */
export type ActivityLogs = $Result.DefaultSelection<Prisma.$ActivityLogsPayload>
/**
 * Model DuplicateCheckLogs
 * 
 */
export type DuplicateCheckLogs = $Result.DefaultSelection<Prisma.$DuplicateCheckLogsPayload>
/**
 * Model ImportMetadata
 * 
 */
export type ImportMetadata = $Result.DefaultSelection<Prisma.$ImportMetadataPayload>
/**
 * Model Tailor
 * 
 */
export type Tailor = $Result.DefaultSelection<Prisma.$TailorPayload>
/**
 * Model TailorProduction
 * 
 */
export type TailorProduction = $Result.DefaultSelection<Prisma.$TailorProductionPayload>
/**
 * Model ProductHPP
 * 
 */
export type ProductHPP = $Result.DefaultSelection<Prisma.$ProductHPPPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const StockMovementType: {
  in: 'in',
  out: 'out',
  adjustment: 'adjustment'
};

export type StockMovementType = (typeof StockMovementType)[keyof typeof StockMovementType]


export const ImportType: {
  sales: 'sales',
  products: 'products',
  stock: 'stock',
  advertising: 'advertising',
  advertising_settlement: 'advertising_settlement',
  ADVERTISING_SETTLEMENT: 'ADVERTISING_SETTLEMENT',
  returns_and_cancellations: 'returns_and_cancellations',
  marketplace_reimbursements: 'marketplace_reimbursements',
  commission_adjustments: 'commission_adjustments',
  affiliate_samples: 'affiliate_samples'
};

export type ImportType = (typeof ImportType)[keyof typeof ImportType]


export const ImportStatus: {
  pending: 'pending',
  processing: 'processing',
  completed: 'completed',
  failed: 'failed',
  partial: 'partial'
};

export type ImportStatus = (typeof ImportStatus)[keyof typeof ImportStatus]


export const SupplierStatus: {
  active: 'active',
  inactive: 'inactive',
  pending: 'pending'
};

export type SupplierStatus = (typeof SupplierStatus)[keyof typeof SupplierStatus]


export const POStatus: {
  draft: 'draft',
  sent: 'sent',
  confirmed: 'confirmed',
  partial: 'partial',
  delivered: 'delivered',
  cancelled: 'cancelled'
};

export type POStatus = (typeof POStatus)[keyof typeof POStatus]


export const CashFlowType: {
  income: 'income',
  expense: 'expense'
};

export type CashFlowType = (typeof CashFlowType)[keyof typeof CashFlowType]


export const ImportHistoryStatus: {
  pending: 'pending',
  processing: 'processing',
  completed: 'completed',
  failed: 'failed',
  partial: 'partial'
};

export type ImportHistoryStatus = (typeof ImportHistoryStatus)[keyof typeof ImportHistoryStatus]


export const InvoiceStatus: {
  draft: 'draft',
  sent: 'sent',
  paid: 'paid',
  overdue: 'overdue',
  cancelled: 'cancelled'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const InvoiceType: {
  invoice: 'invoice',
  receipt: 'receipt'
};

export type InvoiceType = (typeof InvoiceType)[keyof typeof InvoiceType]


export const TailorStatus: {
  active: 'active',
  inactive: 'inactive',
  pending: 'pending'
};

export type TailorStatus = (typeof TailorStatus)[keyof typeof TailorStatus]


export const TailorProductionStatus: {
  completed: 'completed',
  in_progress: 'in_progress',
  pending: 'pending'
};

export type TailorProductionStatus = (typeof TailorProductionStatus)[keyof typeof TailorProductionStatus]

}

export type StockMovementType = $Enums.StockMovementType

export const StockMovementType: typeof $Enums.StockMovementType

export type ImportType = $Enums.ImportType

export const ImportType: typeof $Enums.ImportType

export type ImportStatus = $Enums.ImportStatus

export const ImportStatus: typeof $Enums.ImportStatus

export type SupplierStatus = $Enums.SupplierStatus

export const SupplierStatus: typeof $Enums.SupplierStatus

export type POStatus = $Enums.POStatus

export const POStatus: typeof $Enums.POStatus

export type CashFlowType = $Enums.CashFlowType

export const CashFlowType: typeof $Enums.CashFlowType

export type ImportHistoryStatus = $Enums.ImportHistoryStatus

export const ImportHistoryStatus: typeof $Enums.ImportHistoryStatus

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type InvoiceType = $Enums.InvoiceType

export const InvoiceType: typeof $Enums.InvoiceType

export type TailorStatus = $Enums.TailorStatus

export const TailorStatus: typeof $Enums.TailorStatus

export type TailorProductionStatus = $Enums.TailorProductionStatus

export const TailorProductionStatus: typeof $Enums.TailorProductionStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more SalesData
 * const salesData = await prisma.salesData.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more SalesData
   * const salesData = await prisma.salesData.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.salesData`: Exposes CRUD operations for the **SalesData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesData
    * const salesData = await prisma.salesData.findMany()
    * ```
    */
  get salesData(): Prisma.SalesDataDelegate<ExtArgs>;

  /**
   * `prisma.productData`: Exposes CRUD operations for the **ProductData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductData
    * const productData = await prisma.productData.findMany()
    * ```
    */
  get productData(): Prisma.ProductDataDelegate<ExtArgs>;

  /**
   * `prisma.stockData`: Exposes CRUD operations for the **StockData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockData
    * const stockData = await prisma.stockData.findMany()
    * ```
    */
  get stockData(): Prisma.StockDataDelegate<ExtArgs>;

  /**
   * `prisma.importBatch`: Exposes CRUD operations for the **ImportBatch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImportBatches
    * const importBatches = await prisma.importBatch.findMany()
    * ```
    */
  get importBatch(): Prisma.ImportBatchDelegate<ExtArgs>;

  /**
   * `prisma.advertisingData`: Exposes CRUD operations for the **AdvertisingData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdvertisingData
    * const advertisingData = await prisma.advertisingData.findMany()
    * ```
    */
  get advertisingData(): Prisma.AdvertisingDataDelegate<ExtArgs>;

  /**
   * `prisma.advertisingSettlement`: Exposes CRUD operations for the **AdvertisingSettlement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdvertisingSettlements
    * const advertisingSettlements = await prisma.advertisingSettlement.findMany()
    * ```
    */
  get advertisingSettlement(): Prisma.AdvertisingSettlementDelegate<ExtArgs>;

  /**
   * `prisma.returnsAndCancellations`: Exposes CRUD operations for the **ReturnsAndCancellations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReturnsAndCancellations
    * const returnsAndCancellations = await prisma.returnsAndCancellations.findMany()
    * ```
    */
  get returnsAndCancellations(): Prisma.ReturnsAndCancellationsDelegate<ExtArgs>;

  /**
   * `prisma.marketplaceReimbursement`: Exposes CRUD operations for the **MarketplaceReimbursement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketplaceReimbursements
    * const marketplaceReimbursements = await prisma.marketplaceReimbursement.findMany()
    * ```
    */
  get marketplaceReimbursement(): Prisma.MarketplaceReimbursementDelegate<ExtArgs>;

  /**
   * `prisma.commissionAdjustments`: Exposes CRUD operations for the **CommissionAdjustments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommissionAdjustments
    * const commissionAdjustments = await prisma.commissionAdjustments.findMany()
    * ```
    */
  get commissionAdjustments(): Prisma.CommissionAdjustmentsDelegate<ExtArgs>;

  /**
   * `prisma.affiliateSamples`: Exposes CRUD operations for the **AffiliateSamples** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AffiliateSamples
    * const affiliateSamples = await prisma.affiliateSamples.findMany()
    * ```
    */
  get affiliateSamples(): Prisma.AffiliateSamplesDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs>;

  /**
   * `prisma.brand`: Exposes CRUD operations for the **Brand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Brands
    * const brands = await prisma.brand.findMany()
    * ```
    */
  get brand(): Prisma.BrandDelegate<ExtArgs>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs>;

  /**
   * `prisma.purchaseOrder`: Exposes CRUD operations for the **PurchaseOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrders
    * const purchaseOrders = await prisma.purchaseOrder.findMany()
    * ```
    */
  get purchaseOrder(): Prisma.PurchaseOrderDelegate<ExtArgs>;

  /**
   * `prisma.purchaseOrderItem`: Exposes CRUD operations for the **PurchaseOrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrderItems
    * const purchaseOrderItems = await prisma.purchaseOrderItem.findMany()
    * ```
    */
  get purchaseOrderItem(): Prisma.PurchaseOrderItemDelegate<ExtArgs>;

  /**
   * `prisma.cashFlowEntry`: Exposes CRUD operations for the **CashFlowEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashFlowEntries
    * const cashFlowEntries = await prisma.cashFlowEntry.findMany()
    * ```
    */
  get cashFlowEntry(): Prisma.CashFlowEntryDelegate<ExtArgs>;

  /**
   * `prisma.dashboardMetrics`: Exposes CRUD operations for the **DashboardMetrics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DashboardMetrics
    * const dashboardMetrics = await prisma.dashboardMetrics.findMany()
    * ```
    */
  get dashboardMetrics(): Prisma.DashboardMetricsDelegate<ExtArgs>;

  /**
   * `prisma.importHistory`: Exposes CRUD operations for the **ImportHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImportHistories
    * const importHistories = await prisma.importHistory.findMany()
    * ```
    */
  get importHistory(): Prisma.ImportHistoryDelegate<ExtArgs>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs>;

  /**
   * `prisma.invoiceItem`: Exposes CRUD operations for the **InvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceItems
    * const invoiceItems = await prisma.invoiceItem.findMany()
    * ```
    */
  get invoiceItem(): Prisma.InvoiceItemDelegate<ExtArgs>;

  /**
   * `prisma.affiliateEndorsement`: Exposes CRUD operations for the **AffiliateEndorsement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AffiliateEndorsements
    * const affiliateEndorsements = await prisma.affiliateEndorsement.findMany()
    * ```
    */
  get affiliateEndorsement(): Prisma.AffiliateEndorsementDelegate<ExtArgs>;

  /**
   * `prisma.affiliateProductSale`: Exposes CRUD operations for the **AffiliateProductSale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AffiliateProductSales
    * const affiliateProductSales = await prisma.affiliateProductSale.findMany()
    * ```
    */
  get affiliateProductSale(): Prisma.AffiliateProductSaleDelegate<ExtArgs>;

  /**
   * `prisma.activityLogs`: Exposes CRUD operations for the **ActivityLogs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLogs.findMany()
    * ```
    */
  get activityLogs(): Prisma.ActivityLogsDelegate<ExtArgs>;

  /**
   * `prisma.duplicateCheckLogs`: Exposes CRUD operations for the **DuplicateCheckLogs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DuplicateCheckLogs
    * const duplicateCheckLogs = await prisma.duplicateCheckLogs.findMany()
    * ```
    */
  get duplicateCheckLogs(): Prisma.DuplicateCheckLogsDelegate<ExtArgs>;

  /**
   * `prisma.importMetadata`: Exposes CRUD operations for the **ImportMetadata** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImportMetadata
    * const importMetadata = await prisma.importMetadata.findMany()
    * ```
    */
  get importMetadata(): Prisma.ImportMetadataDelegate<ExtArgs>;

  /**
   * `prisma.tailor`: Exposes CRUD operations for the **Tailor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tailors
    * const tailors = await prisma.tailor.findMany()
    * ```
    */
  get tailor(): Prisma.TailorDelegate<ExtArgs>;

  /**
   * `prisma.tailorProduction`: Exposes CRUD operations for the **TailorProduction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TailorProductions
    * const tailorProductions = await prisma.tailorProduction.findMany()
    * ```
    */
  get tailorProduction(): Prisma.TailorProductionDelegate<ExtArgs>;

  /**
   * `prisma.productHPP`: Exposes CRUD operations for the **ProductHPP** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductHPPS
    * const productHPPS = await prisma.productHPP.findMany()
    * ```
    */
  get productHPP(): Prisma.ProductHPPDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    SalesData: 'SalesData',
    ProductData: 'ProductData',
    StockData: 'StockData',
    ImportBatch: 'ImportBatch',
    AdvertisingData: 'AdvertisingData',
    AdvertisingSettlement: 'AdvertisingSettlement',
    ReturnsAndCancellations: 'ReturnsAndCancellations',
    MarketplaceReimbursement: 'MarketplaceReimbursement',
    CommissionAdjustments: 'CommissionAdjustments',
    AffiliateSamples: 'AffiliateSamples',
    Category: 'Category',
    Brand: 'Brand',
    Supplier: 'Supplier',
    PurchaseOrder: 'PurchaseOrder',
    PurchaseOrderItem: 'PurchaseOrderItem',
    CashFlowEntry: 'CashFlowEntry',
    DashboardMetrics: 'DashboardMetrics',
    ImportHistory: 'ImportHistory',
    Invoice: 'Invoice',
    InvoiceItem: 'InvoiceItem',
    AffiliateEndorsement: 'AffiliateEndorsement',
    AffiliateProductSale: 'AffiliateProductSale',
    ActivityLogs: 'ActivityLogs',
    DuplicateCheckLogs: 'DuplicateCheckLogs',
    ImportMetadata: 'ImportMetadata',
    Tailor: 'Tailor',
    TailorProduction: 'TailorProduction',
    ProductHPP: 'ProductHPP'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "salesData" | "productData" | "stockData" | "importBatch" | "advertisingData" | "advertisingSettlement" | "returnsAndCancellations" | "marketplaceReimbursement" | "commissionAdjustments" | "affiliateSamples" | "category" | "brand" | "supplier" | "purchaseOrder" | "purchaseOrderItem" | "cashFlowEntry" | "dashboardMetrics" | "importHistory" | "invoice" | "invoiceItem" | "affiliateEndorsement" | "affiliateProductSale" | "activityLogs" | "duplicateCheckLogs" | "importMetadata" | "tailor" | "tailorProduction" | "productHPP"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      SalesData: {
        payload: Prisma.$SalesDataPayload<ExtArgs>
        fields: Prisma.SalesDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesDataPayload>
          }
          findFirst: {
            args: Prisma.SalesDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesDataPayload>
          }
          findMany: {
            args: Prisma.SalesDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesDataPayload>[]
          }
          create: {
            args: Prisma.SalesDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesDataPayload>
          }
          createMany: {
            args: Prisma.SalesDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesDataPayload>[]
          }
          delete: {
            args: Prisma.SalesDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesDataPayload>
          }
          update: {
            args: Prisma.SalesDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesDataPayload>
          }
          deleteMany: {
            args: Prisma.SalesDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SalesDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesDataPayload>
          }
          aggregate: {
            args: Prisma.SalesDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesData>
          }
          groupBy: {
            args: Prisma.SalesDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesDataCountArgs<ExtArgs>
            result: $Utils.Optional<SalesDataCountAggregateOutputType> | number
          }
        }
      }
      ProductData: {
        payload: Prisma.$ProductDataPayload<ExtArgs>
        fields: Prisma.ProductDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDataPayload>
          }
          findFirst: {
            args: Prisma.ProductDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDataPayload>
          }
          findMany: {
            args: Prisma.ProductDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDataPayload>[]
          }
          create: {
            args: Prisma.ProductDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDataPayload>
          }
          createMany: {
            args: Prisma.ProductDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDataPayload>[]
          }
          delete: {
            args: Prisma.ProductDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDataPayload>
          }
          update: {
            args: Prisma.ProductDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDataPayload>
          }
          deleteMany: {
            args: Prisma.ProductDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductDataPayload>
          }
          aggregate: {
            args: Prisma.ProductDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductData>
          }
          groupBy: {
            args: Prisma.ProductDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductDataCountArgs<ExtArgs>
            result: $Utils.Optional<ProductDataCountAggregateOutputType> | number
          }
        }
      }
      StockData: {
        payload: Prisma.$StockDataPayload<ExtArgs>
        fields: Prisma.StockDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockDataPayload>
          }
          findFirst: {
            args: Prisma.StockDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockDataPayload>
          }
          findMany: {
            args: Prisma.StockDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockDataPayload>[]
          }
          create: {
            args: Prisma.StockDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockDataPayload>
          }
          createMany: {
            args: Prisma.StockDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockDataPayload>[]
          }
          delete: {
            args: Prisma.StockDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockDataPayload>
          }
          update: {
            args: Prisma.StockDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockDataPayload>
          }
          deleteMany: {
            args: Prisma.StockDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StockDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockDataPayload>
          }
          aggregate: {
            args: Prisma.StockDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockData>
          }
          groupBy: {
            args: Prisma.StockDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockDataCountArgs<ExtArgs>
            result: $Utils.Optional<StockDataCountAggregateOutputType> | number
          }
        }
      }
      ImportBatch: {
        payload: Prisma.$ImportBatchPayload<ExtArgs>
        fields: Prisma.ImportBatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImportBatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportBatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImportBatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportBatchPayload>
          }
          findFirst: {
            args: Prisma.ImportBatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportBatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImportBatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportBatchPayload>
          }
          findMany: {
            args: Prisma.ImportBatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportBatchPayload>[]
          }
          create: {
            args: Prisma.ImportBatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportBatchPayload>
          }
          createMany: {
            args: Prisma.ImportBatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImportBatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportBatchPayload>[]
          }
          delete: {
            args: Prisma.ImportBatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportBatchPayload>
          }
          update: {
            args: Prisma.ImportBatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportBatchPayload>
          }
          deleteMany: {
            args: Prisma.ImportBatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImportBatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ImportBatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportBatchPayload>
          }
          aggregate: {
            args: Prisma.ImportBatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImportBatch>
          }
          groupBy: {
            args: Prisma.ImportBatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImportBatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImportBatchCountArgs<ExtArgs>
            result: $Utils.Optional<ImportBatchCountAggregateOutputType> | number
          }
        }
      }
      AdvertisingData: {
        payload: Prisma.$AdvertisingDataPayload<ExtArgs>
        fields: Prisma.AdvertisingDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdvertisingDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisingDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdvertisingDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisingDataPayload>
          }
          findFirst: {
            args: Prisma.AdvertisingDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisingDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdvertisingDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisingDataPayload>
          }
          findMany: {
            args: Prisma.AdvertisingDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisingDataPayload>[]
          }
          create: {
            args: Prisma.AdvertisingDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisingDataPayload>
          }
          createMany: {
            args: Prisma.AdvertisingDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdvertisingDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisingDataPayload>[]
          }
          delete: {
            args: Prisma.AdvertisingDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisingDataPayload>
          }
          update: {
            args: Prisma.AdvertisingDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisingDataPayload>
          }
          deleteMany: {
            args: Prisma.AdvertisingDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdvertisingDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdvertisingDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisingDataPayload>
          }
          aggregate: {
            args: Prisma.AdvertisingDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdvertisingData>
          }
          groupBy: {
            args: Prisma.AdvertisingDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdvertisingDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdvertisingDataCountArgs<ExtArgs>
            result: $Utils.Optional<AdvertisingDataCountAggregateOutputType> | number
          }
        }
      }
      AdvertisingSettlement: {
        payload: Prisma.$AdvertisingSettlementPayload<ExtArgs>
        fields: Prisma.AdvertisingSettlementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdvertisingSettlementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisingSettlementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdvertisingSettlementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisingSettlementPayload>
          }
          findFirst: {
            args: Prisma.AdvertisingSettlementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisingSettlementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdvertisingSettlementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisingSettlementPayload>
          }
          findMany: {
            args: Prisma.AdvertisingSettlementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisingSettlementPayload>[]
          }
          create: {
            args: Prisma.AdvertisingSettlementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisingSettlementPayload>
          }
          createMany: {
            args: Prisma.AdvertisingSettlementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdvertisingSettlementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisingSettlementPayload>[]
          }
          delete: {
            args: Prisma.AdvertisingSettlementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisingSettlementPayload>
          }
          update: {
            args: Prisma.AdvertisingSettlementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisingSettlementPayload>
          }
          deleteMany: {
            args: Prisma.AdvertisingSettlementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdvertisingSettlementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdvertisingSettlementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdvertisingSettlementPayload>
          }
          aggregate: {
            args: Prisma.AdvertisingSettlementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdvertisingSettlement>
          }
          groupBy: {
            args: Prisma.AdvertisingSettlementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdvertisingSettlementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdvertisingSettlementCountArgs<ExtArgs>
            result: $Utils.Optional<AdvertisingSettlementCountAggregateOutputType> | number
          }
        }
      }
      ReturnsAndCancellations: {
        payload: Prisma.$ReturnsAndCancellationsPayload<ExtArgs>
        fields: Prisma.ReturnsAndCancellationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReturnsAndCancellationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnsAndCancellationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReturnsAndCancellationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnsAndCancellationsPayload>
          }
          findFirst: {
            args: Prisma.ReturnsAndCancellationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnsAndCancellationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReturnsAndCancellationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnsAndCancellationsPayload>
          }
          findMany: {
            args: Prisma.ReturnsAndCancellationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnsAndCancellationsPayload>[]
          }
          create: {
            args: Prisma.ReturnsAndCancellationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnsAndCancellationsPayload>
          }
          createMany: {
            args: Prisma.ReturnsAndCancellationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReturnsAndCancellationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnsAndCancellationsPayload>[]
          }
          delete: {
            args: Prisma.ReturnsAndCancellationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnsAndCancellationsPayload>
          }
          update: {
            args: Prisma.ReturnsAndCancellationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnsAndCancellationsPayload>
          }
          deleteMany: {
            args: Prisma.ReturnsAndCancellationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReturnsAndCancellationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReturnsAndCancellationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnsAndCancellationsPayload>
          }
          aggregate: {
            args: Prisma.ReturnsAndCancellationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReturnsAndCancellations>
          }
          groupBy: {
            args: Prisma.ReturnsAndCancellationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReturnsAndCancellationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReturnsAndCancellationsCountArgs<ExtArgs>
            result: $Utils.Optional<ReturnsAndCancellationsCountAggregateOutputType> | number
          }
        }
      }
      MarketplaceReimbursement: {
        payload: Prisma.$MarketplaceReimbursementPayload<ExtArgs>
        fields: Prisma.MarketplaceReimbursementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketplaceReimbursementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceReimbursementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketplaceReimbursementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceReimbursementPayload>
          }
          findFirst: {
            args: Prisma.MarketplaceReimbursementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceReimbursementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketplaceReimbursementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceReimbursementPayload>
          }
          findMany: {
            args: Prisma.MarketplaceReimbursementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceReimbursementPayload>[]
          }
          create: {
            args: Prisma.MarketplaceReimbursementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceReimbursementPayload>
          }
          createMany: {
            args: Prisma.MarketplaceReimbursementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketplaceReimbursementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceReimbursementPayload>[]
          }
          delete: {
            args: Prisma.MarketplaceReimbursementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceReimbursementPayload>
          }
          update: {
            args: Prisma.MarketplaceReimbursementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceReimbursementPayload>
          }
          deleteMany: {
            args: Prisma.MarketplaceReimbursementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketplaceReimbursementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MarketplaceReimbursementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketplaceReimbursementPayload>
          }
          aggregate: {
            args: Prisma.MarketplaceReimbursementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketplaceReimbursement>
          }
          groupBy: {
            args: Prisma.MarketplaceReimbursementGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketplaceReimbursementGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketplaceReimbursementCountArgs<ExtArgs>
            result: $Utils.Optional<MarketplaceReimbursementCountAggregateOutputType> | number
          }
        }
      }
      CommissionAdjustments: {
        payload: Prisma.$CommissionAdjustmentsPayload<ExtArgs>
        fields: Prisma.CommissionAdjustmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommissionAdjustmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionAdjustmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommissionAdjustmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionAdjustmentsPayload>
          }
          findFirst: {
            args: Prisma.CommissionAdjustmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionAdjustmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommissionAdjustmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionAdjustmentsPayload>
          }
          findMany: {
            args: Prisma.CommissionAdjustmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionAdjustmentsPayload>[]
          }
          create: {
            args: Prisma.CommissionAdjustmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionAdjustmentsPayload>
          }
          createMany: {
            args: Prisma.CommissionAdjustmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommissionAdjustmentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionAdjustmentsPayload>[]
          }
          delete: {
            args: Prisma.CommissionAdjustmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionAdjustmentsPayload>
          }
          update: {
            args: Prisma.CommissionAdjustmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionAdjustmentsPayload>
          }
          deleteMany: {
            args: Prisma.CommissionAdjustmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommissionAdjustmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommissionAdjustmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionAdjustmentsPayload>
          }
          aggregate: {
            args: Prisma.CommissionAdjustmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommissionAdjustments>
          }
          groupBy: {
            args: Prisma.CommissionAdjustmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommissionAdjustmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommissionAdjustmentsCountArgs<ExtArgs>
            result: $Utils.Optional<CommissionAdjustmentsCountAggregateOutputType> | number
          }
        }
      }
      AffiliateSamples: {
        payload: Prisma.$AffiliateSamplesPayload<ExtArgs>
        fields: Prisma.AffiliateSamplesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AffiliateSamplesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateSamplesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AffiliateSamplesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateSamplesPayload>
          }
          findFirst: {
            args: Prisma.AffiliateSamplesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateSamplesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AffiliateSamplesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateSamplesPayload>
          }
          findMany: {
            args: Prisma.AffiliateSamplesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateSamplesPayload>[]
          }
          create: {
            args: Prisma.AffiliateSamplesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateSamplesPayload>
          }
          createMany: {
            args: Prisma.AffiliateSamplesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AffiliateSamplesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateSamplesPayload>[]
          }
          delete: {
            args: Prisma.AffiliateSamplesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateSamplesPayload>
          }
          update: {
            args: Prisma.AffiliateSamplesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateSamplesPayload>
          }
          deleteMany: {
            args: Prisma.AffiliateSamplesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AffiliateSamplesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AffiliateSamplesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateSamplesPayload>
          }
          aggregate: {
            args: Prisma.AffiliateSamplesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAffiliateSamples>
          }
          groupBy: {
            args: Prisma.AffiliateSamplesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AffiliateSamplesGroupByOutputType>[]
          }
          count: {
            args: Prisma.AffiliateSamplesCountArgs<ExtArgs>
            result: $Utils.Optional<AffiliateSamplesCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Brand: {
        payload: Prisma.$BrandPayload<ExtArgs>
        fields: Prisma.BrandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BrandFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BrandFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          findFirst: {
            args: Prisma.BrandFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BrandFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          findMany: {
            args: Prisma.BrandFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          create: {
            args: Prisma.BrandCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          createMany: {
            args: Prisma.BrandCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BrandCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          delete: {
            args: Prisma.BrandDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          update: {
            args: Prisma.BrandUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          deleteMany: {
            args: Prisma.BrandDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BrandUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BrandUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          aggregate: {
            args: Prisma.BrandAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBrand>
          }
          groupBy: {
            args: Prisma.BrandGroupByArgs<ExtArgs>
            result: $Utils.Optional<BrandGroupByOutputType>[]
          }
          count: {
            args: Prisma.BrandCountArgs<ExtArgs>
            result: $Utils.Optional<BrandCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrder: {
        payload: Prisma.$PurchaseOrderPayload<ExtArgs>
        fields: Prisma.PurchaseOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          delete: {
            args: Prisma.PurchaseOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          update: {
            args: Prisma.PurchaseOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrder>
          }
          groupBy: {
            args: Prisma.PurchaseOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrderItem: {
        payload: Prisma.$PurchaseOrderItemPayload<ExtArgs>
        fields: Prisma.PurchaseOrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseOrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>[]
          }
          delete: {
            args: Prisma.PurchaseOrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          update: {
            args: Prisma.PurchaseOrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseOrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrderItem>
          }
          groupBy: {
            args: Prisma.PurchaseOrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderItemCountAggregateOutputType> | number
          }
        }
      }
      CashFlowEntry: {
        payload: Prisma.$CashFlowEntryPayload<ExtArgs>
        fields: Prisma.CashFlowEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashFlowEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFlowEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashFlowEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFlowEntryPayload>
          }
          findFirst: {
            args: Prisma.CashFlowEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFlowEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashFlowEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFlowEntryPayload>
          }
          findMany: {
            args: Prisma.CashFlowEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFlowEntryPayload>[]
          }
          create: {
            args: Prisma.CashFlowEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFlowEntryPayload>
          }
          createMany: {
            args: Prisma.CashFlowEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CashFlowEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFlowEntryPayload>[]
          }
          delete: {
            args: Prisma.CashFlowEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFlowEntryPayload>
          }
          update: {
            args: Prisma.CashFlowEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFlowEntryPayload>
          }
          deleteMany: {
            args: Prisma.CashFlowEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CashFlowEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CashFlowEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashFlowEntryPayload>
          }
          aggregate: {
            args: Prisma.CashFlowEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCashFlowEntry>
          }
          groupBy: {
            args: Prisma.CashFlowEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CashFlowEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CashFlowEntryCountArgs<ExtArgs>
            result: $Utils.Optional<CashFlowEntryCountAggregateOutputType> | number
          }
        }
      }
      DashboardMetrics: {
        payload: Prisma.$DashboardMetricsPayload<ExtArgs>
        fields: Prisma.DashboardMetricsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DashboardMetricsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardMetricsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DashboardMetricsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardMetricsPayload>
          }
          findFirst: {
            args: Prisma.DashboardMetricsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardMetricsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DashboardMetricsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardMetricsPayload>
          }
          findMany: {
            args: Prisma.DashboardMetricsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardMetricsPayload>[]
          }
          create: {
            args: Prisma.DashboardMetricsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardMetricsPayload>
          }
          createMany: {
            args: Prisma.DashboardMetricsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DashboardMetricsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardMetricsPayload>[]
          }
          delete: {
            args: Prisma.DashboardMetricsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardMetricsPayload>
          }
          update: {
            args: Prisma.DashboardMetricsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardMetricsPayload>
          }
          deleteMany: {
            args: Prisma.DashboardMetricsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DashboardMetricsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DashboardMetricsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DashboardMetricsPayload>
          }
          aggregate: {
            args: Prisma.DashboardMetricsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDashboardMetrics>
          }
          groupBy: {
            args: Prisma.DashboardMetricsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DashboardMetricsGroupByOutputType>[]
          }
          count: {
            args: Prisma.DashboardMetricsCountArgs<ExtArgs>
            result: $Utils.Optional<DashboardMetricsCountAggregateOutputType> | number
          }
        }
      }
      ImportHistory: {
        payload: Prisma.$ImportHistoryPayload<ExtArgs>
        fields: Prisma.ImportHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImportHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImportHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportHistoryPayload>
          }
          findFirst: {
            args: Prisma.ImportHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImportHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportHistoryPayload>
          }
          findMany: {
            args: Prisma.ImportHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportHistoryPayload>[]
          }
          create: {
            args: Prisma.ImportHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportHistoryPayload>
          }
          createMany: {
            args: Prisma.ImportHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImportHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportHistoryPayload>[]
          }
          delete: {
            args: Prisma.ImportHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportHistoryPayload>
          }
          update: {
            args: Prisma.ImportHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportHistoryPayload>
          }
          deleteMany: {
            args: Prisma.ImportHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImportHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ImportHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportHistoryPayload>
          }
          aggregate: {
            args: Prisma.ImportHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImportHistory>
          }
          groupBy: {
            args: Prisma.ImportHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImportHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImportHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<ImportHistoryCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InvoiceItem: {
        payload: Prisma.$InvoiceItemPayload<ExtArgs>
        fields: Prisma.InvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.InvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findMany: {
            args: Prisma.InvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          create: {
            args: Prisma.InvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          createMany: {
            args: Prisma.InvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.InvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          update: {
            args: Prisma.InvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.InvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceItem>
          }
          groupBy: {
            args: Prisma.InvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      AffiliateEndorsement: {
        payload: Prisma.$AffiliateEndorsementPayload<ExtArgs>
        fields: Prisma.AffiliateEndorsementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AffiliateEndorsementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateEndorsementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AffiliateEndorsementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateEndorsementPayload>
          }
          findFirst: {
            args: Prisma.AffiliateEndorsementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateEndorsementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AffiliateEndorsementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateEndorsementPayload>
          }
          findMany: {
            args: Prisma.AffiliateEndorsementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateEndorsementPayload>[]
          }
          create: {
            args: Prisma.AffiliateEndorsementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateEndorsementPayload>
          }
          createMany: {
            args: Prisma.AffiliateEndorsementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AffiliateEndorsementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateEndorsementPayload>[]
          }
          delete: {
            args: Prisma.AffiliateEndorsementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateEndorsementPayload>
          }
          update: {
            args: Prisma.AffiliateEndorsementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateEndorsementPayload>
          }
          deleteMany: {
            args: Prisma.AffiliateEndorsementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AffiliateEndorsementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AffiliateEndorsementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateEndorsementPayload>
          }
          aggregate: {
            args: Prisma.AffiliateEndorsementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAffiliateEndorsement>
          }
          groupBy: {
            args: Prisma.AffiliateEndorsementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AffiliateEndorsementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AffiliateEndorsementCountArgs<ExtArgs>
            result: $Utils.Optional<AffiliateEndorsementCountAggregateOutputType> | number
          }
        }
      }
      AffiliateProductSale: {
        payload: Prisma.$AffiliateProductSalePayload<ExtArgs>
        fields: Prisma.AffiliateProductSaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AffiliateProductSaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProductSalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AffiliateProductSaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProductSalePayload>
          }
          findFirst: {
            args: Prisma.AffiliateProductSaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProductSalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AffiliateProductSaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProductSalePayload>
          }
          findMany: {
            args: Prisma.AffiliateProductSaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProductSalePayload>[]
          }
          create: {
            args: Prisma.AffiliateProductSaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProductSalePayload>
          }
          createMany: {
            args: Prisma.AffiliateProductSaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AffiliateProductSaleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProductSalePayload>[]
          }
          delete: {
            args: Prisma.AffiliateProductSaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProductSalePayload>
          }
          update: {
            args: Prisma.AffiliateProductSaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProductSalePayload>
          }
          deleteMany: {
            args: Prisma.AffiliateProductSaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AffiliateProductSaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AffiliateProductSaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProductSalePayload>
          }
          aggregate: {
            args: Prisma.AffiliateProductSaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAffiliateProductSale>
          }
          groupBy: {
            args: Prisma.AffiliateProductSaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<AffiliateProductSaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.AffiliateProductSaleCountArgs<ExtArgs>
            result: $Utils.Optional<AffiliateProductSaleCountAggregateOutputType> | number
          }
        }
      }
      ActivityLogs: {
        payload: Prisma.$ActivityLogsPayload<ExtArgs>
        fields: Prisma.ActivityLogsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityLogsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityLogsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogsPayload>
          }
          findFirst: {
            args: Prisma.ActivityLogsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityLogsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogsPayload>
          }
          findMany: {
            args: Prisma.ActivityLogsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogsPayload>[]
          }
          create: {
            args: Prisma.ActivityLogsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogsPayload>
          }
          createMany: {
            args: Prisma.ActivityLogsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityLogsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogsPayload>[]
          }
          delete: {
            args: Prisma.ActivityLogsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogsPayload>
          }
          update: {
            args: Prisma.ActivityLogsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogsPayload>
          }
          deleteMany: {
            args: Prisma.ActivityLogsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityLogsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActivityLogsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogsPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityLogs>
          }
          groupBy: {
            args: Prisma.ActivityLogsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityLogsCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogsCountAggregateOutputType> | number
          }
        }
      }
      DuplicateCheckLogs: {
        payload: Prisma.$DuplicateCheckLogsPayload<ExtArgs>
        fields: Prisma.DuplicateCheckLogsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DuplicateCheckLogsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DuplicateCheckLogsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DuplicateCheckLogsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DuplicateCheckLogsPayload>
          }
          findFirst: {
            args: Prisma.DuplicateCheckLogsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DuplicateCheckLogsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DuplicateCheckLogsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DuplicateCheckLogsPayload>
          }
          findMany: {
            args: Prisma.DuplicateCheckLogsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DuplicateCheckLogsPayload>[]
          }
          create: {
            args: Prisma.DuplicateCheckLogsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DuplicateCheckLogsPayload>
          }
          createMany: {
            args: Prisma.DuplicateCheckLogsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DuplicateCheckLogsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DuplicateCheckLogsPayload>[]
          }
          delete: {
            args: Prisma.DuplicateCheckLogsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DuplicateCheckLogsPayload>
          }
          update: {
            args: Prisma.DuplicateCheckLogsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DuplicateCheckLogsPayload>
          }
          deleteMany: {
            args: Prisma.DuplicateCheckLogsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DuplicateCheckLogsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DuplicateCheckLogsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DuplicateCheckLogsPayload>
          }
          aggregate: {
            args: Prisma.DuplicateCheckLogsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDuplicateCheckLogs>
          }
          groupBy: {
            args: Prisma.DuplicateCheckLogsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DuplicateCheckLogsGroupByOutputType>[]
          }
          count: {
            args: Prisma.DuplicateCheckLogsCountArgs<ExtArgs>
            result: $Utils.Optional<DuplicateCheckLogsCountAggregateOutputType> | number
          }
        }
      }
      ImportMetadata: {
        payload: Prisma.$ImportMetadataPayload<ExtArgs>
        fields: Prisma.ImportMetadataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImportMetadataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportMetadataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImportMetadataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportMetadataPayload>
          }
          findFirst: {
            args: Prisma.ImportMetadataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportMetadataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImportMetadataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportMetadataPayload>
          }
          findMany: {
            args: Prisma.ImportMetadataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportMetadataPayload>[]
          }
          create: {
            args: Prisma.ImportMetadataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportMetadataPayload>
          }
          createMany: {
            args: Prisma.ImportMetadataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImportMetadataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportMetadataPayload>[]
          }
          delete: {
            args: Prisma.ImportMetadataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportMetadataPayload>
          }
          update: {
            args: Prisma.ImportMetadataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportMetadataPayload>
          }
          deleteMany: {
            args: Prisma.ImportMetadataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImportMetadataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ImportMetadataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportMetadataPayload>
          }
          aggregate: {
            args: Prisma.ImportMetadataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImportMetadata>
          }
          groupBy: {
            args: Prisma.ImportMetadataGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImportMetadataGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImportMetadataCountArgs<ExtArgs>
            result: $Utils.Optional<ImportMetadataCountAggregateOutputType> | number
          }
        }
      }
      Tailor: {
        payload: Prisma.$TailorPayload<ExtArgs>
        fields: Prisma.TailorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TailorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TailorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailorPayload>
          }
          findFirst: {
            args: Prisma.TailorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TailorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailorPayload>
          }
          findMany: {
            args: Prisma.TailorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailorPayload>[]
          }
          create: {
            args: Prisma.TailorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailorPayload>
          }
          createMany: {
            args: Prisma.TailorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TailorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailorPayload>[]
          }
          delete: {
            args: Prisma.TailorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailorPayload>
          }
          update: {
            args: Prisma.TailorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailorPayload>
          }
          deleteMany: {
            args: Prisma.TailorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TailorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TailorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailorPayload>
          }
          aggregate: {
            args: Prisma.TailorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTailor>
          }
          groupBy: {
            args: Prisma.TailorGroupByArgs<ExtArgs>
            result: $Utils.Optional<TailorGroupByOutputType>[]
          }
          count: {
            args: Prisma.TailorCountArgs<ExtArgs>
            result: $Utils.Optional<TailorCountAggregateOutputType> | number
          }
        }
      }
      TailorProduction: {
        payload: Prisma.$TailorProductionPayload<ExtArgs>
        fields: Prisma.TailorProductionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TailorProductionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailorProductionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TailorProductionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailorProductionPayload>
          }
          findFirst: {
            args: Prisma.TailorProductionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailorProductionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TailorProductionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailorProductionPayload>
          }
          findMany: {
            args: Prisma.TailorProductionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailorProductionPayload>[]
          }
          create: {
            args: Prisma.TailorProductionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailorProductionPayload>
          }
          createMany: {
            args: Prisma.TailorProductionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TailorProductionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailorProductionPayload>[]
          }
          delete: {
            args: Prisma.TailorProductionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailorProductionPayload>
          }
          update: {
            args: Prisma.TailorProductionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailorProductionPayload>
          }
          deleteMany: {
            args: Prisma.TailorProductionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TailorProductionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TailorProductionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TailorProductionPayload>
          }
          aggregate: {
            args: Prisma.TailorProductionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTailorProduction>
          }
          groupBy: {
            args: Prisma.TailorProductionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TailorProductionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TailorProductionCountArgs<ExtArgs>
            result: $Utils.Optional<TailorProductionCountAggregateOutputType> | number
          }
        }
      }
      ProductHPP: {
        payload: Prisma.$ProductHPPPayload<ExtArgs>
        fields: Prisma.ProductHPPFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductHPPFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductHPPPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductHPPFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductHPPPayload>
          }
          findFirst: {
            args: Prisma.ProductHPPFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductHPPPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductHPPFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductHPPPayload>
          }
          findMany: {
            args: Prisma.ProductHPPFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductHPPPayload>[]
          }
          create: {
            args: Prisma.ProductHPPCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductHPPPayload>
          }
          createMany: {
            args: Prisma.ProductHPPCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductHPPCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductHPPPayload>[]
          }
          delete: {
            args: Prisma.ProductHPPDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductHPPPayload>
          }
          update: {
            args: Prisma.ProductHPPUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductHPPPayload>
          }
          deleteMany: {
            args: Prisma.ProductHPPDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductHPPUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductHPPUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductHPPPayload>
          }
          aggregate: {
            args: Prisma.ProductHPPAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductHPP>
          }
          groupBy: {
            args: Prisma.ProductHPPGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductHPPGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductHPPCountArgs<ExtArgs>
            result: $Utils.Optional<ProductHPPCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProductDataCountOutputType
   */

  export type ProductDataCountOutputType = {
    stock_movements: number
  }

  export type ProductDataCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stock_movements?: boolean | ProductDataCountOutputTypeCountStock_movementsArgs
  }

  // Custom InputTypes
  /**
   * ProductDataCountOutputType without action
   */
  export type ProductDataCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductDataCountOutputType
     */
    select?: ProductDataCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductDataCountOutputType without action
   */
  export type ProductDataCountOutputTypeCountStock_movementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockDataWhereInput
  }


  /**
   * Count Type ImportBatchCountOutputType
   */

  export type ImportBatchCountOutputType = {
    sales_data: number
    product_data: number
    stock_data: number
    advertising_data: number
    advertising_settlement: number
    returns_and_cancellations: number
    marketplace_reimbursements: number
    commission_adjustments: number
    affiliate_samples: number
  }

  export type ImportBatchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales_data?: boolean | ImportBatchCountOutputTypeCountSales_dataArgs
    product_data?: boolean | ImportBatchCountOutputTypeCountProduct_dataArgs
    stock_data?: boolean | ImportBatchCountOutputTypeCountStock_dataArgs
    advertising_data?: boolean | ImportBatchCountOutputTypeCountAdvertising_dataArgs
    advertising_settlement?: boolean | ImportBatchCountOutputTypeCountAdvertising_settlementArgs
    returns_and_cancellations?: boolean | ImportBatchCountOutputTypeCountReturns_and_cancellationsArgs
    marketplace_reimbursements?: boolean | ImportBatchCountOutputTypeCountMarketplace_reimbursementsArgs
    commission_adjustments?: boolean | ImportBatchCountOutputTypeCountCommission_adjustmentsArgs
    affiliate_samples?: boolean | ImportBatchCountOutputTypeCountAffiliate_samplesArgs
  }

  // Custom InputTypes
  /**
   * ImportBatchCountOutputType without action
   */
  export type ImportBatchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportBatchCountOutputType
     */
    select?: ImportBatchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ImportBatchCountOutputType without action
   */
  export type ImportBatchCountOutputTypeCountSales_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesDataWhereInput
  }

  /**
   * ImportBatchCountOutputType without action
   */
  export type ImportBatchCountOutputTypeCountProduct_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductDataWhereInput
  }

  /**
   * ImportBatchCountOutputType without action
   */
  export type ImportBatchCountOutputTypeCountStock_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockDataWhereInput
  }

  /**
   * ImportBatchCountOutputType without action
   */
  export type ImportBatchCountOutputTypeCountAdvertising_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdvertisingDataWhereInput
  }

  /**
   * ImportBatchCountOutputType without action
   */
  export type ImportBatchCountOutputTypeCountAdvertising_settlementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdvertisingSettlementWhereInput
  }

  /**
   * ImportBatchCountOutputType without action
   */
  export type ImportBatchCountOutputTypeCountReturns_and_cancellationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReturnsAndCancellationsWhereInput
  }

  /**
   * ImportBatchCountOutputType without action
   */
  export type ImportBatchCountOutputTypeCountMarketplace_reimbursementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketplaceReimbursementWhereInput
  }

  /**
   * ImportBatchCountOutputType without action
   */
  export type ImportBatchCountOutputTypeCountCommission_adjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommissionAdjustmentsWhereInput
  }

  /**
   * ImportBatchCountOutputType without action
   */
  export type ImportBatchCountOutputTypeCountAffiliate_samplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateSamplesWhereInput
  }


  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    purchase_orders: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase_orders?: boolean | SupplierCountOutputTypeCountPurchase_ordersArgs
  }

  // Custom InputTypes
  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountPurchase_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }


  /**
   * Count Type PurchaseOrderCountOutputType
   */

  export type PurchaseOrderCountOutputType = {
    items: number
  }

  export type PurchaseOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PurchaseOrderCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderCountOutputType
     */
    select?: PurchaseOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderItemWhereInput
  }


  /**
   * Count Type ImportHistoryCountOutputType
   */

  export type ImportHistoryCountOutputType = {
    importMetadata: number
  }

  export type ImportHistoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    importMetadata?: boolean | ImportHistoryCountOutputTypeCountImportMetadataArgs
  }

  // Custom InputTypes
  /**
   * ImportHistoryCountOutputType without action
   */
  export type ImportHistoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportHistoryCountOutputType
     */
    select?: ImportHistoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ImportHistoryCountOutputType without action
   */
  export type ImportHistoryCountOutputTypeCountImportMetadataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImportMetadataWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    items: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | InvoiceCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }


  /**
   * Count Type AffiliateEndorsementCountOutputType
   */

  export type AffiliateEndorsementCountOutputType = {
    product_sales: number
  }

  export type AffiliateEndorsementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product_sales?: boolean | AffiliateEndorsementCountOutputTypeCountProduct_salesArgs
  }

  // Custom InputTypes
  /**
   * AffiliateEndorsementCountOutputType without action
   */
  export type AffiliateEndorsementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateEndorsementCountOutputType
     */
    select?: AffiliateEndorsementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AffiliateEndorsementCountOutputType without action
   */
  export type AffiliateEndorsementCountOutputTypeCountProduct_salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateProductSaleWhereInput
  }


  /**
   * Count Type TailorCountOutputType
   */

  export type TailorCountOutputType = {
    productions: number
  }

  export type TailorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productions?: boolean | TailorCountOutputTypeCountProductionsArgs
  }

  // Custom InputTypes
  /**
   * TailorCountOutputType without action
   */
  export type TailorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailorCountOutputType
     */
    select?: TailorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TailorCountOutputType without action
   */
  export type TailorCountOutputTypeCountProductionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TailorProductionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model SalesData
   */

  export type AggregateSalesData = {
    _count: SalesDataCountAggregateOutputType | null
    _avg: SalesDataAvgAggregateOutputType | null
    _sum: SalesDataSumAggregateOutputType | null
    _min: SalesDataMinAggregateOutputType | null
    _max: SalesDataMaxAggregateOutputType | null
  }

  export type SalesDataAvgAggregateOutputType = {
    quantity: number | null
    order_amount: number | null
    settlement_amount: number | null
    total_revenue: number | null
    hpp: number | null
    total: number | null
  }

  export type SalesDataSumAggregateOutputType = {
    quantity: number | null
    order_amount: number | null
    settlement_amount: number | null
    total_revenue: number | null
    hpp: number | null
    total: number | null
  }

  export type SalesDataMinAggregateOutputType = {
    id: string | null
    order_id: string | null
    seller_sku: string | null
    product_name: string | null
    color: string | null
    size: string | null
    quantity: number | null
    order_amount: number | null
    created_time: Date | null
    delivered_time: Date | null
    settlement_amount: number | null
    total_revenue: number | null
    hpp: number | null
    total: number | null
    marketplace: string | null
    customer: string | null
    province: string | null
    regency_city: string | null
    import_batch_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SalesDataMaxAggregateOutputType = {
    id: string | null
    order_id: string | null
    seller_sku: string | null
    product_name: string | null
    color: string | null
    size: string | null
    quantity: number | null
    order_amount: number | null
    created_time: Date | null
    delivered_time: Date | null
    settlement_amount: number | null
    total_revenue: number | null
    hpp: number | null
    total: number | null
    marketplace: string | null
    customer: string | null
    province: string | null
    regency_city: string | null
    import_batch_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SalesDataCountAggregateOutputType = {
    id: number
    order_id: number
    seller_sku: number
    product_name: number
    color: number
    size: number
    quantity: number
    order_amount: number
    created_time: number
    delivered_time: number
    settlement_amount: number
    total_revenue: number
    hpp: number
    total: number
    marketplace: number
    customer: number
    province: number
    regency_city: number
    import_batch_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SalesDataAvgAggregateInputType = {
    quantity?: true
    order_amount?: true
    settlement_amount?: true
    total_revenue?: true
    hpp?: true
    total?: true
  }

  export type SalesDataSumAggregateInputType = {
    quantity?: true
    order_amount?: true
    settlement_amount?: true
    total_revenue?: true
    hpp?: true
    total?: true
  }

  export type SalesDataMinAggregateInputType = {
    id?: true
    order_id?: true
    seller_sku?: true
    product_name?: true
    color?: true
    size?: true
    quantity?: true
    order_amount?: true
    created_time?: true
    delivered_time?: true
    settlement_amount?: true
    total_revenue?: true
    hpp?: true
    total?: true
    marketplace?: true
    customer?: true
    province?: true
    regency_city?: true
    import_batch_id?: true
    created_at?: true
    updated_at?: true
  }

  export type SalesDataMaxAggregateInputType = {
    id?: true
    order_id?: true
    seller_sku?: true
    product_name?: true
    color?: true
    size?: true
    quantity?: true
    order_amount?: true
    created_time?: true
    delivered_time?: true
    settlement_amount?: true
    total_revenue?: true
    hpp?: true
    total?: true
    marketplace?: true
    customer?: true
    province?: true
    regency_city?: true
    import_batch_id?: true
    created_at?: true
    updated_at?: true
  }

  export type SalesDataCountAggregateInputType = {
    id?: true
    order_id?: true
    seller_sku?: true
    product_name?: true
    color?: true
    size?: true
    quantity?: true
    order_amount?: true
    created_time?: true
    delivered_time?: true
    settlement_amount?: true
    total_revenue?: true
    hpp?: true
    total?: true
    marketplace?: true
    customer?: true
    province?: true
    regency_city?: true
    import_batch_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SalesDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesData to aggregate.
     */
    where?: SalesDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesData to fetch.
     */
    orderBy?: SalesDataOrderByWithRelationInput | SalesDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesData
    **/
    _count?: true | SalesDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesDataMaxAggregateInputType
  }

  export type GetSalesDataAggregateType<T extends SalesDataAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesData[P]>
      : GetScalarType<T[P], AggregateSalesData[P]>
  }




  export type SalesDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesDataWhereInput
    orderBy?: SalesDataOrderByWithAggregationInput | SalesDataOrderByWithAggregationInput[]
    by: SalesDataScalarFieldEnum[] | SalesDataScalarFieldEnum
    having?: SalesDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesDataCountAggregateInputType | true
    _avg?: SalesDataAvgAggregateInputType
    _sum?: SalesDataSumAggregateInputType
    _min?: SalesDataMinAggregateInputType
    _max?: SalesDataMaxAggregateInputType
  }

  export type SalesDataGroupByOutputType = {
    id: string
    order_id: string
    seller_sku: string
    product_name: string
    color: string
    size: string
    quantity: number
    order_amount: number
    created_time: Date
    delivered_time: Date | null
    settlement_amount: number | null
    total_revenue: number | null
    hpp: number | null
    total: number | null
    marketplace: string | null
    customer: string | null
    province: string | null
    regency_city: string | null
    import_batch_id: string | null
    created_at: Date
    updated_at: Date
    _count: SalesDataCountAggregateOutputType | null
    _avg: SalesDataAvgAggregateOutputType | null
    _sum: SalesDataSumAggregateOutputType | null
    _min: SalesDataMinAggregateOutputType | null
    _max: SalesDataMaxAggregateOutputType | null
  }

  type GetSalesDataGroupByPayload<T extends SalesDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesDataGroupByOutputType[P]>
            : GetScalarType<T[P], SalesDataGroupByOutputType[P]>
        }
      >
    >


  export type SalesDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order_id?: boolean
    seller_sku?: boolean
    product_name?: boolean
    color?: boolean
    size?: boolean
    quantity?: boolean
    order_amount?: boolean
    created_time?: boolean
    delivered_time?: boolean
    settlement_amount?: boolean
    total_revenue?: boolean
    hpp?: boolean
    total?: boolean
    marketplace?: boolean
    customer?: boolean
    province?: boolean
    regency_city?: boolean
    import_batch_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    import_batch?: boolean | SalesData$import_batchArgs<ExtArgs>
  }, ExtArgs["result"]["salesData"]>

  export type SalesDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    order_id?: boolean
    seller_sku?: boolean
    product_name?: boolean
    color?: boolean
    size?: boolean
    quantity?: boolean
    order_amount?: boolean
    created_time?: boolean
    delivered_time?: boolean
    settlement_amount?: boolean
    total_revenue?: boolean
    hpp?: boolean
    total?: boolean
    marketplace?: boolean
    customer?: boolean
    province?: boolean
    regency_city?: boolean
    import_batch_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    import_batch?: boolean | SalesData$import_batchArgs<ExtArgs>
  }, ExtArgs["result"]["salesData"]>

  export type SalesDataSelectScalar = {
    id?: boolean
    order_id?: boolean
    seller_sku?: boolean
    product_name?: boolean
    color?: boolean
    size?: boolean
    quantity?: boolean
    order_amount?: boolean
    created_time?: boolean
    delivered_time?: boolean
    settlement_amount?: boolean
    total_revenue?: boolean
    hpp?: boolean
    total?: boolean
    marketplace?: boolean
    customer?: boolean
    province?: boolean
    regency_city?: boolean
    import_batch_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type SalesDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    import_batch?: boolean | SalesData$import_batchArgs<ExtArgs>
  }
  export type SalesDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    import_batch?: boolean | SalesData$import_batchArgs<ExtArgs>
  }

  export type $SalesDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesData"
    objects: {
      import_batch: Prisma.$ImportBatchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      order_id: string
      seller_sku: string
      product_name: string
      color: string
      size: string
      quantity: number
      order_amount: number
      created_time: Date
      delivered_time: Date | null
      settlement_amount: number | null
      total_revenue: number | null
      hpp: number | null
      total: number | null
      marketplace: string | null
      customer: string | null
      province: string | null
      regency_city: string | null
      import_batch_id: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["salesData"]>
    composites: {}
  }

  type SalesDataGetPayload<S extends boolean | null | undefined | SalesDataDefaultArgs> = $Result.GetResult<Prisma.$SalesDataPayload, S>

  type SalesDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SalesDataFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SalesDataCountAggregateInputType | true
    }

  export interface SalesDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesData'], meta: { name: 'SalesData' } }
    /**
     * Find zero or one SalesData that matches the filter.
     * @param {SalesDataFindUniqueArgs} args - Arguments to find a SalesData
     * @example
     * // Get one SalesData
     * const salesData = await prisma.salesData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesDataFindUniqueArgs>(args: SelectSubset<T, SalesDataFindUniqueArgs<ExtArgs>>): Prisma__SalesDataClient<$Result.GetResult<Prisma.$SalesDataPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SalesData that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SalesDataFindUniqueOrThrowArgs} args - Arguments to find a SalesData
     * @example
     * // Get one SalesData
     * const salesData = await prisma.salesData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesDataFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesDataClient<$Result.GetResult<Prisma.$SalesDataPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SalesData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesDataFindFirstArgs} args - Arguments to find a SalesData
     * @example
     * // Get one SalesData
     * const salesData = await prisma.salesData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesDataFindFirstArgs>(args?: SelectSubset<T, SalesDataFindFirstArgs<ExtArgs>>): Prisma__SalesDataClient<$Result.GetResult<Prisma.$SalesDataPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SalesData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesDataFindFirstOrThrowArgs} args - Arguments to find a SalesData
     * @example
     * // Get one SalesData
     * const salesData = await prisma.salesData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesDataFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesDataClient<$Result.GetResult<Prisma.$SalesDataPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SalesData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesData
     * const salesData = await prisma.salesData.findMany()
     * 
     * // Get first 10 SalesData
     * const salesData = await prisma.salesData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesDataWithIdOnly = await prisma.salesData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesDataFindManyArgs>(args?: SelectSubset<T, SalesDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesDataPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SalesData.
     * @param {SalesDataCreateArgs} args - Arguments to create a SalesData.
     * @example
     * // Create one SalesData
     * const SalesData = await prisma.salesData.create({
     *   data: {
     *     // ... data to create a SalesData
     *   }
     * })
     * 
     */
    create<T extends SalesDataCreateArgs>(args: SelectSubset<T, SalesDataCreateArgs<ExtArgs>>): Prisma__SalesDataClient<$Result.GetResult<Prisma.$SalesDataPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SalesData.
     * @param {SalesDataCreateManyArgs} args - Arguments to create many SalesData.
     * @example
     * // Create many SalesData
     * const salesData = await prisma.salesData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesDataCreateManyArgs>(args?: SelectSubset<T, SalesDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesData and returns the data saved in the database.
     * @param {SalesDataCreateManyAndReturnArgs} args - Arguments to create many SalesData.
     * @example
     * // Create many SalesData
     * const salesData = await prisma.salesData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesData and only return the `id`
     * const salesDataWithIdOnly = await prisma.salesData.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesDataCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesDataPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SalesData.
     * @param {SalesDataDeleteArgs} args - Arguments to delete one SalesData.
     * @example
     * // Delete one SalesData
     * const SalesData = await prisma.salesData.delete({
     *   where: {
     *     // ... filter to delete one SalesData
     *   }
     * })
     * 
     */
    delete<T extends SalesDataDeleteArgs>(args: SelectSubset<T, SalesDataDeleteArgs<ExtArgs>>): Prisma__SalesDataClient<$Result.GetResult<Prisma.$SalesDataPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SalesData.
     * @param {SalesDataUpdateArgs} args - Arguments to update one SalesData.
     * @example
     * // Update one SalesData
     * const salesData = await prisma.salesData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesDataUpdateArgs>(args: SelectSubset<T, SalesDataUpdateArgs<ExtArgs>>): Prisma__SalesDataClient<$Result.GetResult<Prisma.$SalesDataPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SalesData.
     * @param {SalesDataDeleteManyArgs} args - Arguments to filter SalesData to delete.
     * @example
     * // Delete a few SalesData
     * const { count } = await prisma.salesData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesDataDeleteManyArgs>(args?: SelectSubset<T, SalesDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesData
     * const salesData = await prisma.salesData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesDataUpdateManyArgs>(args: SelectSubset<T, SalesDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SalesData.
     * @param {SalesDataUpsertArgs} args - Arguments to update or create a SalesData.
     * @example
     * // Update or create a SalesData
     * const salesData = await prisma.salesData.upsert({
     *   create: {
     *     // ... data to create a SalesData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesData we want to update
     *   }
     * })
     */
    upsert<T extends SalesDataUpsertArgs>(args: SelectSubset<T, SalesDataUpsertArgs<ExtArgs>>): Prisma__SalesDataClient<$Result.GetResult<Prisma.$SalesDataPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SalesData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesDataCountArgs} args - Arguments to filter SalesData to count.
     * @example
     * // Count the number of SalesData
     * const count = await prisma.salesData.count({
     *   where: {
     *     // ... the filter for the SalesData we want to count
     *   }
     * })
    **/
    count<T extends SalesDataCountArgs>(
      args?: Subset<T, SalesDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesDataAggregateArgs>(args: Subset<T, SalesDataAggregateArgs>): Prisma.PrismaPromise<GetSalesDataAggregateType<T>>

    /**
     * Group by SalesData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesDataGroupByArgs['orderBy'] }
        : { orderBy?: SalesDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesData model
   */
  readonly fields: SalesDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    import_batch<T extends SalesData$import_batchArgs<ExtArgs> = {}>(args?: Subset<T, SalesData$import_batchArgs<ExtArgs>>): Prisma__ImportBatchClient<$Result.GetResult<Prisma.$ImportBatchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesData model
   */ 
  interface SalesDataFieldRefs {
    readonly id: FieldRef<"SalesData", 'String'>
    readonly order_id: FieldRef<"SalesData", 'String'>
    readonly seller_sku: FieldRef<"SalesData", 'String'>
    readonly product_name: FieldRef<"SalesData", 'String'>
    readonly color: FieldRef<"SalesData", 'String'>
    readonly size: FieldRef<"SalesData", 'String'>
    readonly quantity: FieldRef<"SalesData", 'Int'>
    readonly order_amount: FieldRef<"SalesData", 'Float'>
    readonly created_time: FieldRef<"SalesData", 'DateTime'>
    readonly delivered_time: FieldRef<"SalesData", 'DateTime'>
    readonly settlement_amount: FieldRef<"SalesData", 'Float'>
    readonly total_revenue: FieldRef<"SalesData", 'Float'>
    readonly hpp: FieldRef<"SalesData", 'Float'>
    readonly total: FieldRef<"SalesData", 'Float'>
    readonly marketplace: FieldRef<"SalesData", 'String'>
    readonly customer: FieldRef<"SalesData", 'String'>
    readonly province: FieldRef<"SalesData", 'String'>
    readonly regency_city: FieldRef<"SalesData", 'String'>
    readonly import_batch_id: FieldRef<"SalesData", 'String'>
    readonly created_at: FieldRef<"SalesData", 'DateTime'>
    readonly updated_at: FieldRef<"SalesData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalesData findUnique
   */
  export type SalesDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesData
     */
    select?: SalesDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesDataInclude<ExtArgs> | null
    /**
     * Filter, which SalesData to fetch.
     */
    where: SalesDataWhereUniqueInput
  }

  /**
   * SalesData findUniqueOrThrow
   */
  export type SalesDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesData
     */
    select?: SalesDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesDataInclude<ExtArgs> | null
    /**
     * Filter, which SalesData to fetch.
     */
    where: SalesDataWhereUniqueInput
  }

  /**
   * SalesData findFirst
   */
  export type SalesDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesData
     */
    select?: SalesDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesDataInclude<ExtArgs> | null
    /**
     * Filter, which SalesData to fetch.
     */
    where?: SalesDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesData to fetch.
     */
    orderBy?: SalesDataOrderByWithRelationInput | SalesDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesData.
     */
    cursor?: SalesDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesData.
     */
    distinct?: SalesDataScalarFieldEnum | SalesDataScalarFieldEnum[]
  }

  /**
   * SalesData findFirstOrThrow
   */
  export type SalesDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesData
     */
    select?: SalesDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesDataInclude<ExtArgs> | null
    /**
     * Filter, which SalesData to fetch.
     */
    where?: SalesDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesData to fetch.
     */
    orderBy?: SalesDataOrderByWithRelationInput | SalesDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesData.
     */
    cursor?: SalesDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesData.
     */
    distinct?: SalesDataScalarFieldEnum | SalesDataScalarFieldEnum[]
  }

  /**
   * SalesData findMany
   */
  export type SalesDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesData
     */
    select?: SalesDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesDataInclude<ExtArgs> | null
    /**
     * Filter, which SalesData to fetch.
     */
    where?: SalesDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesData to fetch.
     */
    orderBy?: SalesDataOrderByWithRelationInput | SalesDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesData.
     */
    cursor?: SalesDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesData.
     */
    skip?: number
    distinct?: SalesDataScalarFieldEnum | SalesDataScalarFieldEnum[]
  }

  /**
   * SalesData create
   */
  export type SalesDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesData
     */
    select?: SalesDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesDataInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesData.
     */
    data: XOR<SalesDataCreateInput, SalesDataUncheckedCreateInput>
  }

  /**
   * SalesData createMany
   */
  export type SalesDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesData.
     */
    data: SalesDataCreateManyInput | SalesDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesData createManyAndReturn
   */
  export type SalesDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesData
     */
    select?: SalesDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SalesData.
     */
    data: SalesDataCreateManyInput | SalesDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesData update
   */
  export type SalesDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesData
     */
    select?: SalesDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesDataInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesData.
     */
    data: XOR<SalesDataUpdateInput, SalesDataUncheckedUpdateInput>
    /**
     * Choose, which SalesData to update.
     */
    where: SalesDataWhereUniqueInput
  }

  /**
   * SalesData updateMany
   */
  export type SalesDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesData.
     */
    data: XOR<SalesDataUpdateManyMutationInput, SalesDataUncheckedUpdateManyInput>
    /**
     * Filter which SalesData to update
     */
    where?: SalesDataWhereInput
  }

  /**
   * SalesData upsert
   */
  export type SalesDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesData
     */
    select?: SalesDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesDataInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesData to update in case it exists.
     */
    where: SalesDataWhereUniqueInput
    /**
     * In case the SalesData found by the `where` argument doesn't exist, create a new SalesData with this data.
     */
    create: XOR<SalesDataCreateInput, SalesDataUncheckedCreateInput>
    /**
     * In case the SalesData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesDataUpdateInput, SalesDataUncheckedUpdateInput>
  }

  /**
   * SalesData delete
   */
  export type SalesDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesData
     */
    select?: SalesDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesDataInclude<ExtArgs> | null
    /**
     * Filter which SalesData to delete.
     */
    where: SalesDataWhereUniqueInput
  }

  /**
   * SalesData deleteMany
   */
  export type SalesDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesData to delete
     */
    where?: SalesDataWhereInput
  }

  /**
   * SalesData.import_batch
   */
  export type SalesData$import_batchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportBatch
     */
    select?: ImportBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportBatchInclude<ExtArgs> | null
    where?: ImportBatchWhereInput
  }

  /**
   * SalesData without action
   */
  export type SalesDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesData
     */
    select?: SalesDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesDataInclude<ExtArgs> | null
  }


  /**
   * Model ProductData
   */

  export type AggregateProductData = {
    _count: ProductDataCountAggregateOutputType | null
    _avg: ProductDataAvgAggregateOutputType | null
    _sum: ProductDataSumAggregateOutputType | null
    _min: ProductDataMinAggregateOutputType | null
    _max: ProductDataMaxAggregateOutputType | null
  }

  export type ProductDataAvgAggregateOutputType = {
    price: number | null
    cost: number | null
    stock_quantity: number | null
    min_stock: number | null
  }

  export type ProductDataSumAggregateOutputType = {
    price: number | null
    cost: number | null
    stock_quantity: number | null
    min_stock: number | null
  }

  export type ProductDataMinAggregateOutputType = {
    id: string | null
    product_code: string | null
    product_name: string | null
    category: string | null
    brand: string | null
    size: string | null
    color: string | null
    price: number | null
    cost: number | null
    stock_quantity: number | null
    min_stock: number | null
    description: string | null
    import_batch_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProductDataMaxAggregateOutputType = {
    id: string | null
    product_code: string | null
    product_name: string | null
    category: string | null
    brand: string | null
    size: string | null
    color: string | null
    price: number | null
    cost: number | null
    stock_quantity: number | null
    min_stock: number | null
    description: string | null
    import_batch_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProductDataCountAggregateOutputType = {
    id: number
    product_code: number
    product_name: number
    category: number
    brand: number
    size: number
    color: number
    price: number
    cost: number
    stock_quantity: number
    min_stock: number
    description: number
    import_batch_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ProductDataAvgAggregateInputType = {
    price?: true
    cost?: true
    stock_quantity?: true
    min_stock?: true
  }

  export type ProductDataSumAggregateInputType = {
    price?: true
    cost?: true
    stock_quantity?: true
    min_stock?: true
  }

  export type ProductDataMinAggregateInputType = {
    id?: true
    product_code?: true
    product_name?: true
    category?: true
    brand?: true
    size?: true
    color?: true
    price?: true
    cost?: true
    stock_quantity?: true
    min_stock?: true
    description?: true
    import_batch_id?: true
    created_at?: true
    updated_at?: true
  }

  export type ProductDataMaxAggregateInputType = {
    id?: true
    product_code?: true
    product_name?: true
    category?: true
    brand?: true
    size?: true
    color?: true
    price?: true
    cost?: true
    stock_quantity?: true
    min_stock?: true
    description?: true
    import_batch_id?: true
    created_at?: true
    updated_at?: true
  }

  export type ProductDataCountAggregateInputType = {
    id?: true
    product_code?: true
    product_name?: true
    category?: true
    brand?: true
    size?: true
    color?: true
    price?: true
    cost?: true
    stock_quantity?: true
    min_stock?: true
    description?: true
    import_batch_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ProductDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductData to aggregate.
     */
    where?: ProductDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductData to fetch.
     */
    orderBy?: ProductDataOrderByWithRelationInput | ProductDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductData
    **/
    _count?: true | ProductDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductDataMaxAggregateInputType
  }

  export type GetProductDataAggregateType<T extends ProductDataAggregateArgs> = {
        [P in keyof T & keyof AggregateProductData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductData[P]>
      : GetScalarType<T[P], AggregateProductData[P]>
  }




  export type ProductDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductDataWhereInput
    orderBy?: ProductDataOrderByWithAggregationInput | ProductDataOrderByWithAggregationInput[]
    by: ProductDataScalarFieldEnum[] | ProductDataScalarFieldEnum
    having?: ProductDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductDataCountAggregateInputType | true
    _avg?: ProductDataAvgAggregateInputType
    _sum?: ProductDataSumAggregateInputType
    _min?: ProductDataMinAggregateInputType
    _max?: ProductDataMaxAggregateInputType
  }

  export type ProductDataGroupByOutputType = {
    id: string
    product_code: string
    product_name: string
    category: string
    brand: string
    size: string
    color: string
    price: number
    cost: number
    stock_quantity: number
    min_stock: number
    description: string | null
    import_batch_id: string | null
    created_at: Date
    updated_at: Date
    _count: ProductDataCountAggregateOutputType | null
    _avg: ProductDataAvgAggregateOutputType | null
    _sum: ProductDataSumAggregateOutputType | null
    _min: ProductDataMinAggregateOutputType | null
    _max: ProductDataMaxAggregateOutputType | null
  }

  type GetProductDataGroupByPayload<T extends ProductDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductDataGroupByOutputType[P]>
            : GetScalarType<T[P], ProductDataGroupByOutputType[P]>
        }
      >
    >


  export type ProductDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    product_code?: boolean
    product_name?: boolean
    category?: boolean
    brand?: boolean
    size?: boolean
    color?: boolean
    price?: boolean
    cost?: boolean
    stock_quantity?: boolean
    min_stock?: boolean
    description?: boolean
    import_batch_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    stock_movements?: boolean | ProductData$stock_movementsArgs<ExtArgs>
    import_batch?: boolean | ProductData$import_batchArgs<ExtArgs>
    _count?: boolean | ProductDataCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productData"]>

  export type ProductDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    product_code?: boolean
    product_name?: boolean
    category?: boolean
    brand?: boolean
    size?: boolean
    color?: boolean
    price?: boolean
    cost?: boolean
    stock_quantity?: boolean
    min_stock?: boolean
    description?: boolean
    import_batch_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    import_batch?: boolean | ProductData$import_batchArgs<ExtArgs>
  }, ExtArgs["result"]["productData"]>

  export type ProductDataSelectScalar = {
    id?: boolean
    product_code?: boolean
    product_name?: boolean
    category?: boolean
    brand?: boolean
    size?: boolean
    color?: boolean
    price?: boolean
    cost?: boolean
    stock_quantity?: boolean
    min_stock?: boolean
    description?: boolean
    import_batch_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ProductDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stock_movements?: boolean | ProductData$stock_movementsArgs<ExtArgs>
    import_batch?: boolean | ProductData$import_batchArgs<ExtArgs>
    _count?: boolean | ProductDataCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    import_batch?: boolean | ProductData$import_batchArgs<ExtArgs>
  }

  export type $ProductDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductData"
    objects: {
      stock_movements: Prisma.$StockDataPayload<ExtArgs>[]
      import_batch: Prisma.$ImportBatchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      product_code: string
      product_name: string
      category: string
      brand: string
      size: string
      color: string
      price: number
      cost: number
      stock_quantity: number
      min_stock: number
      description: string | null
      import_batch_id: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["productData"]>
    composites: {}
  }

  type ProductDataGetPayload<S extends boolean | null | undefined | ProductDataDefaultArgs> = $Result.GetResult<Prisma.$ProductDataPayload, S>

  type ProductDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductDataFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductDataCountAggregateInputType | true
    }

  export interface ProductDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductData'], meta: { name: 'ProductData' } }
    /**
     * Find zero or one ProductData that matches the filter.
     * @param {ProductDataFindUniqueArgs} args - Arguments to find a ProductData
     * @example
     * // Get one ProductData
     * const productData = await prisma.productData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductDataFindUniqueArgs>(args: SelectSubset<T, ProductDataFindUniqueArgs<ExtArgs>>): Prisma__ProductDataClient<$Result.GetResult<Prisma.$ProductDataPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductData that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductDataFindUniqueOrThrowArgs} args - Arguments to find a ProductData
     * @example
     * // Get one ProductData
     * const productData = await prisma.productData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductDataFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductDataClient<$Result.GetResult<Prisma.$ProductDataPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDataFindFirstArgs} args - Arguments to find a ProductData
     * @example
     * // Get one ProductData
     * const productData = await prisma.productData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductDataFindFirstArgs>(args?: SelectSubset<T, ProductDataFindFirstArgs<ExtArgs>>): Prisma__ProductDataClient<$Result.GetResult<Prisma.$ProductDataPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDataFindFirstOrThrowArgs} args - Arguments to find a ProductData
     * @example
     * // Get one ProductData
     * const productData = await prisma.productData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductDataFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductDataClient<$Result.GetResult<Prisma.$ProductDataPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductData
     * const productData = await prisma.productData.findMany()
     * 
     * // Get first 10 ProductData
     * const productData = await prisma.productData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productDataWithIdOnly = await prisma.productData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductDataFindManyArgs>(args?: SelectSubset<T, ProductDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductDataPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductData.
     * @param {ProductDataCreateArgs} args - Arguments to create a ProductData.
     * @example
     * // Create one ProductData
     * const ProductData = await prisma.productData.create({
     *   data: {
     *     // ... data to create a ProductData
     *   }
     * })
     * 
     */
    create<T extends ProductDataCreateArgs>(args: SelectSubset<T, ProductDataCreateArgs<ExtArgs>>): Prisma__ProductDataClient<$Result.GetResult<Prisma.$ProductDataPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductData.
     * @param {ProductDataCreateManyArgs} args - Arguments to create many ProductData.
     * @example
     * // Create many ProductData
     * const productData = await prisma.productData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductDataCreateManyArgs>(args?: SelectSubset<T, ProductDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductData and returns the data saved in the database.
     * @param {ProductDataCreateManyAndReturnArgs} args - Arguments to create many ProductData.
     * @example
     * // Create many ProductData
     * const productData = await prisma.productData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductData and only return the `id`
     * const productDataWithIdOnly = await prisma.productData.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductDataCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductDataPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProductData.
     * @param {ProductDataDeleteArgs} args - Arguments to delete one ProductData.
     * @example
     * // Delete one ProductData
     * const ProductData = await prisma.productData.delete({
     *   where: {
     *     // ... filter to delete one ProductData
     *   }
     * })
     * 
     */
    delete<T extends ProductDataDeleteArgs>(args: SelectSubset<T, ProductDataDeleteArgs<ExtArgs>>): Prisma__ProductDataClient<$Result.GetResult<Prisma.$ProductDataPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductData.
     * @param {ProductDataUpdateArgs} args - Arguments to update one ProductData.
     * @example
     * // Update one ProductData
     * const productData = await prisma.productData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductDataUpdateArgs>(args: SelectSubset<T, ProductDataUpdateArgs<ExtArgs>>): Prisma__ProductDataClient<$Result.GetResult<Prisma.$ProductDataPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductData.
     * @param {ProductDataDeleteManyArgs} args - Arguments to filter ProductData to delete.
     * @example
     * // Delete a few ProductData
     * const { count } = await prisma.productData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDataDeleteManyArgs>(args?: SelectSubset<T, ProductDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductData
     * const productData = await prisma.productData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductDataUpdateManyArgs>(args: SelectSubset<T, ProductDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductData.
     * @param {ProductDataUpsertArgs} args - Arguments to update or create a ProductData.
     * @example
     * // Update or create a ProductData
     * const productData = await prisma.productData.upsert({
     *   create: {
     *     // ... data to create a ProductData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductData we want to update
     *   }
     * })
     */
    upsert<T extends ProductDataUpsertArgs>(args: SelectSubset<T, ProductDataUpsertArgs<ExtArgs>>): Prisma__ProductDataClient<$Result.GetResult<Prisma.$ProductDataPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDataCountArgs} args - Arguments to filter ProductData to count.
     * @example
     * // Count the number of ProductData
     * const count = await prisma.productData.count({
     *   where: {
     *     // ... the filter for the ProductData we want to count
     *   }
     * })
    **/
    count<T extends ProductDataCountArgs>(
      args?: Subset<T, ProductDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductDataAggregateArgs>(args: Subset<T, ProductDataAggregateArgs>): Prisma.PrismaPromise<GetProductDataAggregateType<T>>

    /**
     * Group by ProductData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductDataGroupByArgs['orderBy'] }
        : { orderBy?: ProductDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductData model
   */
  readonly fields: ProductDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stock_movements<T extends ProductData$stock_movementsArgs<ExtArgs> = {}>(args?: Subset<T, ProductData$stock_movementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockDataPayload<ExtArgs>, T, "findMany"> | Null>
    import_batch<T extends ProductData$import_batchArgs<ExtArgs> = {}>(args?: Subset<T, ProductData$import_batchArgs<ExtArgs>>): Prisma__ImportBatchClient<$Result.GetResult<Prisma.$ImportBatchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductData model
   */ 
  interface ProductDataFieldRefs {
    readonly id: FieldRef<"ProductData", 'String'>
    readonly product_code: FieldRef<"ProductData", 'String'>
    readonly product_name: FieldRef<"ProductData", 'String'>
    readonly category: FieldRef<"ProductData", 'String'>
    readonly brand: FieldRef<"ProductData", 'String'>
    readonly size: FieldRef<"ProductData", 'String'>
    readonly color: FieldRef<"ProductData", 'String'>
    readonly price: FieldRef<"ProductData", 'Float'>
    readonly cost: FieldRef<"ProductData", 'Float'>
    readonly stock_quantity: FieldRef<"ProductData", 'Int'>
    readonly min_stock: FieldRef<"ProductData", 'Int'>
    readonly description: FieldRef<"ProductData", 'String'>
    readonly import_batch_id: FieldRef<"ProductData", 'String'>
    readonly created_at: FieldRef<"ProductData", 'DateTime'>
    readonly updated_at: FieldRef<"ProductData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductData findUnique
   */
  export type ProductDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductData
     */
    select?: ProductDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDataInclude<ExtArgs> | null
    /**
     * Filter, which ProductData to fetch.
     */
    where: ProductDataWhereUniqueInput
  }

  /**
   * ProductData findUniqueOrThrow
   */
  export type ProductDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductData
     */
    select?: ProductDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDataInclude<ExtArgs> | null
    /**
     * Filter, which ProductData to fetch.
     */
    where: ProductDataWhereUniqueInput
  }

  /**
   * ProductData findFirst
   */
  export type ProductDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductData
     */
    select?: ProductDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDataInclude<ExtArgs> | null
    /**
     * Filter, which ProductData to fetch.
     */
    where?: ProductDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductData to fetch.
     */
    orderBy?: ProductDataOrderByWithRelationInput | ProductDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductData.
     */
    cursor?: ProductDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductData.
     */
    distinct?: ProductDataScalarFieldEnum | ProductDataScalarFieldEnum[]
  }

  /**
   * ProductData findFirstOrThrow
   */
  export type ProductDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductData
     */
    select?: ProductDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDataInclude<ExtArgs> | null
    /**
     * Filter, which ProductData to fetch.
     */
    where?: ProductDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductData to fetch.
     */
    orderBy?: ProductDataOrderByWithRelationInput | ProductDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductData.
     */
    cursor?: ProductDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductData.
     */
    distinct?: ProductDataScalarFieldEnum | ProductDataScalarFieldEnum[]
  }

  /**
   * ProductData findMany
   */
  export type ProductDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductData
     */
    select?: ProductDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDataInclude<ExtArgs> | null
    /**
     * Filter, which ProductData to fetch.
     */
    where?: ProductDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductData to fetch.
     */
    orderBy?: ProductDataOrderByWithRelationInput | ProductDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductData.
     */
    cursor?: ProductDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductData.
     */
    skip?: number
    distinct?: ProductDataScalarFieldEnum | ProductDataScalarFieldEnum[]
  }

  /**
   * ProductData create
   */
  export type ProductDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductData
     */
    select?: ProductDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDataInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductData.
     */
    data: XOR<ProductDataCreateInput, ProductDataUncheckedCreateInput>
  }

  /**
   * ProductData createMany
   */
  export type ProductDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductData.
     */
    data: ProductDataCreateManyInput | ProductDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductData createManyAndReturn
   */
  export type ProductDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductData
     */
    select?: ProductDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProductData.
     */
    data: ProductDataCreateManyInput | ProductDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductData update
   */
  export type ProductDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductData
     */
    select?: ProductDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDataInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductData.
     */
    data: XOR<ProductDataUpdateInput, ProductDataUncheckedUpdateInput>
    /**
     * Choose, which ProductData to update.
     */
    where: ProductDataWhereUniqueInput
  }

  /**
   * ProductData updateMany
   */
  export type ProductDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductData.
     */
    data: XOR<ProductDataUpdateManyMutationInput, ProductDataUncheckedUpdateManyInput>
    /**
     * Filter which ProductData to update
     */
    where?: ProductDataWhereInput
  }

  /**
   * ProductData upsert
   */
  export type ProductDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductData
     */
    select?: ProductDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDataInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductData to update in case it exists.
     */
    where: ProductDataWhereUniqueInput
    /**
     * In case the ProductData found by the `where` argument doesn't exist, create a new ProductData with this data.
     */
    create: XOR<ProductDataCreateInput, ProductDataUncheckedCreateInput>
    /**
     * In case the ProductData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductDataUpdateInput, ProductDataUncheckedUpdateInput>
  }

  /**
   * ProductData delete
   */
  export type ProductDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductData
     */
    select?: ProductDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDataInclude<ExtArgs> | null
    /**
     * Filter which ProductData to delete.
     */
    where: ProductDataWhereUniqueInput
  }

  /**
   * ProductData deleteMany
   */
  export type ProductDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductData to delete
     */
    where?: ProductDataWhereInput
  }

  /**
   * ProductData.stock_movements
   */
  export type ProductData$stock_movementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockData
     */
    select?: StockDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockDataInclude<ExtArgs> | null
    where?: StockDataWhereInput
    orderBy?: StockDataOrderByWithRelationInput | StockDataOrderByWithRelationInput[]
    cursor?: StockDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockDataScalarFieldEnum | StockDataScalarFieldEnum[]
  }

  /**
   * ProductData.import_batch
   */
  export type ProductData$import_batchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportBatch
     */
    select?: ImportBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportBatchInclude<ExtArgs> | null
    where?: ImportBatchWhereInput
  }

  /**
   * ProductData without action
   */
  export type ProductDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductData
     */
    select?: ProductDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDataInclude<ExtArgs> | null
  }


  /**
   * Model StockData
   */

  export type AggregateStockData = {
    _count: StockDataCountAggregateOutputType | null
    _avg: StockDataAvgAggregateOutputType | null
    _sum: StockDataSumAggregateOutputType | null
    _min: StockDataMinAggregateOutputType | null
    _max: StockDataMaxAggregateOutputType | null
  }

  export type StockDataAvgAggregateOutputType = {
    quantity: number | null
  }

  export type StockDataSumAggregateOutputType = {
    quantity: number | null
  }

  export type StockDataMinAggregateOutputType = {
    id: string | null
    product_code: string | null
    movement_type: $Enums.StockMovementType | null
    quantity: number | null
    reference_number: string | null
    notes: string | null
    movement_date: Date | null
    import_batch_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StockDataMaxAggregateOutputType = {
    id: string | null
    product_code: string | null
    movement_type: $Enums.StockMovementType | null
    quantity: number | null
    reference_number: string | null
    notes: string | null
    movement_date: Date | null
    import_batch_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StockDataCountAggregateOutputType = {
    id: number
    product_code: number
    movement_type: number
    quantity: number
    reference_number: number
    notes: number
    movement_date: number
    import_batch_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type StockDataAvgAggregateInputType = {
    quantity?: true
  }

  export type StockDataSumAggregateInputType = {
    quantity?: true
  }

  export type StockDataMinAggregateInputType = {
    id?: true
    product_code?: true
    movement_type?: true
    quantity?: true
    reference_number?: true
    notes?: true
    movement_date?: true
    import_batch_id?: true
    created_at?: true
    updated_at?: true
  }

  export type StockDataMaxAggregateInputType = {
    id?: true
    product_code?: true
    movement_type?: true
    quantity?: true
    reference_number?: true
    notes?: true
    movement_date?: true
    import_batch_id?: true
    created_at?: true
    updated_at?: true
  }

  export type StockDataCountAggregateInputType = {
    id?: true
    product_code?: true
    movement_type?: true
    quantity?: true
    reference_number?: true
    notes?: true
    movement_date?: true
    import_batch_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type StockDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockData to aggregate.
     */
    where?: StockDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockData to fetch.
     */
    orderBy?: StockDataOrderByWithRelationInput | StockDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockData
    **/
    _count?: true | StockDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockDataMaxAggregateInputType
  }

  export type GetStockDataAggregateType<T extends StockDataAggregateArgs> = {
        [P in keyof T & keyof AggregateStockData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockData[P]>
      : GetScalarType<T[P], AggregateStockData[P]>
  }




  export type StockDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockDataWhereInput
    orderBy?: StockDataOrderByWithAggregationInput | StockDataOrderByWithAggregationInput[]
    by: StockDataScalarFieldEnum[] | StockDataScalarFieldEnum
    having?: StockDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockDataCountAggregateInputType | true
    _avg?: StockDataAvgAggregateInputType
    _sum?: StockDataSumAggregateInputType
    _min?: StockDataMinAggregateInputType
    _max?: StockDataMaxAggregateInputType
  }

  export type StockDataGroupByOutputType = {
    id: string
    product_code: string
    movement_type: $Enums.StockMovementType
    quantity: number
    reference_number: string | null
    notes: string | null
    movement_date: Date
    import_batch_id: string | null
    created_at: Date
    updated_at: Date
    _count: StockDataCountAggregateOutputType | null
    _avg: StockDataAvgAggregateOutputType | null
    _sum: StockDataSumAggregateOutputType | null
    _min: StockDataMinAggregateOutputType | null
    _max: StockDataMaxAggregateOutputType | null
  }

  type GetStockDataGroupByPayload<T extends StockDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockDataGroupByOutputType[P]>
            : GetScalarType<T[P], StockDataGroupByOutputType[P]>
        }
      >
    >


  export type StockDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    product_code?: boolean
    movement_type?: boolean
    quantity?: boolean
    reference_number?: boolean
    notes?: boolean
    movement_date?: boolean
    import_batch_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    product?: boolean | StockData$productArgs<ExtArgs>
    import_batch?: boolean | StockData$import_batchArgs<ExtArgs>
  }, ExtArgs["result"]["stockData"]>

  export type StockDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    product_code?: boolean
    movement_type?: boolean
    quantity?: boolean
    reference_number?: boolean
    notes?: boolean
    movement_date?: boolean
    import_batch_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    product?: boolean | StockData$productArgs<ExtArgs>
    import_batch?: boolean | StockData$import_batchArgs<ExtArgs>
  }, ExtArgs["result"]["stockData"]>

  export type StockDataSelectScalar = {
    id?: boolean
    product_code?: boolean
    movement_type?: boolean
    quantity?: boolean
    reference_number?: boolean
    notes?: boolean
    movement_date?: boolean
    import_batch_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type StockDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | StockData$productArgs<ExtArgs>
    import_batch?: boolean | StockData$import_batchArgs<ExtArgs>
  }
  export type StockDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | StockData$productArgs<ExtArgs>
    import_batch?: boolean | StockData$import_batchArgs<ExtArgs>
  }

  export type $StockDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockData"
    objects: {
      product: Prisma.$ProductDataPayload<ExtArgs> | null
      import_batch: Prisma.$ImportBatchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      product_code: string
      movement_type: $Enums.StockMovementType
      quantity: number
      reference_number: string | null
      notes: string | null
      movement_date: Date
      import_batch_id: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["stockData"]>
    composites: {}
  }

  type StockDataGetPayload<S extends boolean | null | undefined | StockDataDefaultArgs> = $Result.GetResult<Prisma.$StockDataPayload, S>

  type StockDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StockDataFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StockDataCountAggregateInputType | true
    }

  export interface StockDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockData'], meta: { name: 'StockData' } }
    /**
     * Find zero or one StockData that matches the filter.
     * @param {StockDataFindUniqueArgs} args - Arguments to find a StockData
     * @example
     * // Get one StockData
     * const stockData = await prisma.stockData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockDataFindUniqueArgs>(args: SelectSubset<T, StockDataFindUniqueArgs<ExtArgs>>): Prisma__StockDataClient<$Result.GetResult<Prisma.$StockDataPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StockData that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StockDataFindUniqueOrThrowArgs} args - Arguments to find a StockData
     * @example
     * // Get one StockData
     * const stockData = await prisma.stockData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockDataFindUniqueOrThrowArgs>(args: SelectSubset<T, StockDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockDataClient<$Result.GetResult<Prisma.$StockDataPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StockData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockDataFindFirstArgs} args - Arguments to find a StockData
     * @example
     * // Get one StockData
     * const stockData = await prisma.stockData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockDataFindFirstArgs>(args?: SelectSubset<T, StockDataFindFirstArgs<ExtArgs>>): Prisma__StockDataClient<$Result.GetResult<Prisma.$StockDataPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StockData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockDataFindFirstOrThrowArgs} args - Arguments to find a StockData
     * @example
     * // Get one StockData
     * const stockData = await prisma.stockData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockDataFindFirstOrThrowArgs>(args?: SelectSubset<T, StockDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockDataClient<$Result.GetResult<Prisma.$StockDataPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StockData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockData
     * const stockData = await prisma.stockData.findMany()
     * 
     * // Get first 10 StockData
     * const stockData = await prisma.stockData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockDataWithIdOnly = await prisma.stockData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockDataFindManyArgs>(args?: SelectSubset<T, StockDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockDataPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StockData.
     * @param {StockDataCreateArgs} args - Arguments to create a StockData.
     * @example
     * // Create one StockData
     * const StockData = await prisma.stockData.create({
     *   data: {
     *     // ... data to create a StockData
     *   }
     * })
     * 
     */
    create<T extends StockDataCreateArgs>(args: SelectSubset<T, StockDataCreateArgs<ExtArgs>>): Prisma__StockDataClient<$Result.GetResult<Prisma.$StockDataPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StockData.
     * @param {StockDataCreateManyArgs} args - Arguments to create many StockData.
     * @example
     * // Create many StockData
     * const stockData = await prisma.stockData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockDataCreateManyArgs>(args?: SelectSubset<T, StockDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockData and returns the data saved in the database.
     * @param {StockDataCreateManyAndReturnArgs} args - Arguments to create many StockData.
     * @example
     * // Create many StockData
     * const stockData = await prisma.stockData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockData and only return the `id`
     * const stockDataWithIdOnly = await prisma.stockData.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockDataCreateManyAndReturnArgs>(args?: SelectSubset<T, StockDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockDataPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StockData.
     * @param {StockDataDeleteArgs} args - Arguments to delete one StockData.
     * @example
     * // Delete one StockData
     * const StockData = await prisma.stockData.delete({
     *   where: {
     *     // ... filter to delete one StockData
     *   }
     * })
     * 
     */
    delete<T extends StockDataDeleteArgs>(args: SelectSubset<T, StockDataDeleteArgs<ExtArgs>>): Prisma__StockDataClient<$Result.GetResult<Prisma.$StockDataPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StockData.
     * @param {StockDataUpdateArgs} args - Arguments to update one StockData.
     * @example
     * // Update one StockData
     * const stockData = await prisma.stockData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockDataUpdateArgs>(args: SelectSubset<T, StockDataUpdateArgs<ExtArgs>>): Prisma__StockDataClient<$Result.GetResult<Prisma.$StockDataPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StockData.
     * @param {StockDataDeleteManyArgs} args - Arguments to filter StockData to delete.
     * @example
     * // Delete a few StockData
     * const { count } = await prisma.stockData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockDataDeleteManyArgs>(args?: SelectSubset<T, StockDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockData
     * const stockData = await prisma.stockData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockDataUpdateManyArgs>(args: SelectSubset<T, StockDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StockData.
     * @param {StockDataUpsertArgs} args - Arguments to update or create a StockData.
     * @example
     * // Update or create a StockData
     * const stockData = await prisma.stockData.upsert({
     *   create: {
     *     // ... data to create a StockData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockData we want to update
     *   }
     * })
     */
    upsert<T extends StockDataUpsertArgs>(args: SelectSubset<T, StockDataUpsertArgs<ExtArgs>>): Prisma__StockDataClient<$Result.GetResult<Prisma.$StockDataPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StockData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockDataCountArgs} args - Arguments to filter StockData to count.
     * @example
     * // Count the number of StockData
     * const count = await prisma.stockData.count({
     *   where: {
     *     // ... the filter for the StockData we want to count
     *   }
     * })
    **/
    count<T extends StockDataCountArgs>(
      args?: Subset<T, StockDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockDataAggregateArgs>(args: Subset<T, StockDataAggregateArgs>): Prisma.PrismaPromise<GetStockDataAggregateType<T>>

    /**
     * Group by StockData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockDataGroupByArgs['orderBy'] }
        : { orderBy?: StockDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockData model
   */
  readonly fields: StockDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends StockData$productArgs<ExtArgs> = {}>(args?: Subset<T, StockData$productArgs<ExtArgs>>): Prisma__ProductDataClient<$Result.GetResult<Prisma.$ProductDataPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    import_batch<T extends StockData$import_batchArgs<ExtArgs> = {}>(args?: Subset<T, StockData$import_batchArgs<ExtArgs>>): Prisma__ImportBatchClient<$Result.GetResult<Prisma.$ImportBatchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockData model
   */ 
  interface StockDataFieldRefs {
    readonly id: FieldRef<"StockData", 'String'>
    readonly product_code: FieldRef<"StockData", 'String'>
    readonly movement_type: FieldRef<"StockData", 'StockMovementType'>
    readonly quantity: FieldRef<"StockData", 'Int'>
    readonly reference_number: FieldRef<"StockData", 'String'>
    readonly notes: FieldRef<"StockData", 'String'>
    readonly movement_date: FieldRef<"StockData", 'DateTime'>
    readonly import_batch_id: FieldRef<"StockData", 'String'>
    readonly created_at: FieldRef<"StockData", 'DateTime'>
    readonly updated_at: FieldRef<"StockData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StockData findUnique
   */
  export type StockDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockData
     */
    select?: StockDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockDataInclude<ExtArgs> | null
    /**
     * Filter, which StockData to fetch.
     */
    where: StockDataWhereUniqueInput
  }

  /**
   * StockData findUniqueOrThrow
   */
  export type StockDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockData
     */
    select?: StockDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockDataInclude<ExtArgs> | null
    /**
     * Filter, which StockData to fetch.
     */
    where: StockDataWhereUniqueInput
  }

  /**
   * StockData findFirst
   */
  export type StockDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockData
     */
    select?: StockDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockDataInclude<ExtArgs> | null
    /**
     * Filter, which StockData to fetch.
     */
    where?: StockDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockData to fetch.
     */
    orderBy?: StockDataOrderByWithRelationInput | StockDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockData.
     */
    cursor?: StockDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockData.
     */
    distinct?: StockDataScalarFieldEnum | StockDataScalarFieldEnum[]
  }

  /**
   * StockData findFirstOrThrow
   */
  export type StockDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockData
     */
    select?: StockDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockDataInclude<ExtArgs> | null
    /**
     * Filter, which StockData to fetch.
     */
    where?: StockDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockData to fetch.
     */
    orderBy?: StockDataOrderByWithRelationInput | StockDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockData.
     */
    cursor?: StockDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockData.
     */
    distinct?: StockDataScalarFieldEnum | StockDataScalarFieldEnum[]
  }

  /**
   * StockData findMany
   */
  export type StockDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockData
     */
    select?: StockDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockDataInclude<ExtArgs> | null
    /**
     * Filter, which StockData to fetch.
     */
    where?: StockDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockData to fetch.
     */
    orderBy?: StockDataOrderByWithRelationInput | StockDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockData.
     */
    cursor?: StockDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockData.
     */
    skip?: number
    distinct?: StockDataScalarFieldEnum | StockDataScalarFieldEnum[]
  }

  /**
   * StockData create
   */
  export type StockDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockData
     */
    select?: StockDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockDataInclude<ExtArgs> | null
    /**
     * The data needed to create a StockData.
     */
    data: XOR<StockDataCreateInput, StockDataUncheckedCreateInput>
  }

  /**
   * StockData createMany
   */
  export type StockDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockData.
     */
    data: StockDataCreateManyInput | StockDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StockData createManyAndReturn
   */
  export type StockDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockData
     */
    select?: StockDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StockData.
     */
    data: StockDataCreateManyInput | StockDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockData update
   */
  export type StockDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockData
     */
    select?: StockDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockDataInclude<ExtArgs> | null
    /**
     * The data needed to update a StockData.
     */
    data: XOR<StockDataUpdateInput, StockDataUncheckedUpdateInput>
    /**
     * Choose, which StockData to update.
     */
    where: StockDataWhereUniqueInput
  }

  /**
   * StockData updateMany
   */
  export type StockDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockData.
     */
    data: XOR<StockDataUpdateManyMutationInput, StockDataUncheckedUpdateManyInput>
    /**
     * Filter which StockData to update
     */
    where?: StockDataWhereInput
  }

  /**
   * StockData upsert
   */
  export type StockDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockData
     */
    select?: StockDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockDataInclude<ExtArgs> | null
    /**
     * The filter to search for the StockData to update in case it exists.
     */
    where: StockDataWhereUniqueInput
    /**
     * In case the StockData found by the `where` argument doesn't exist, create a new StockData with this data.
     */
    create: XOR<StockDataCreateInput, StockDataUncheckedCreateInput>
    /**
     * In case the StockData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockDataUpdateInput, StockDataUncheckedUpdateInput>
  }

  /**
   * StockData delete
   */
  export type StockDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockData
     */
    select?: StockDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockDataInclude<ExtArgs> | null
    /**
     * Filter which StockData to delete.
     */
    where: StockDataWhereUniqueInput
  }

  /**
   * StockData deleteMany
   */
  export type StockDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockData to delete
     */
    where?: StockDataWhereInput
  }

  /**
   * StockData.product
   */
  export type StockData$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductData
     */
    select?: ProductDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDataInclude<ExtArgs> | null
    where?: ProductDataWhereInput
  }

  /**
   * StockData.import_batch
   */
  export type StockData$import_batchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportBatch
     */
    select?: ImportBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportBatchInclude<ExtArgs> | null
    where?: ImportBatchWhereInput
  }

  /**
   * StockData without action
   */
  export type StockDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockData
     */
    select?: StockDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockDataInclude<ExtArgs> | null
  }


  /**
   * Model ImportBatch
   */

  export type AggregateImportBatch = {
    _count: ImportBatchCountAggregateOutputType | null
    _avg: ImportBatchAvgAggregateOutputType | null
    _sum: ImportBatchSumAggregateOutputType | null
    _min: ImportBatchMinAggregateOutputType | null
    _max: ImportBatchMaxAggregateOutputType | null
  }

  export type ImportBatchAvgAggregateOutputType = {
    total_records: number | null
    valid_records: number | null
    invalid_records: number | null
    imported_records: number | null
  }

  export type ImportBatchSumAggregateOutputType = {
    total_records: number | null
    valid_records: number | null
    invalid_records: number | null
    imported_records: number | null
  }

  export type ImportBatchMinAggregateOutputType = {
    id: string | null
    batch_name: string | null
    import_type: $Enums.ImportType | null
    file_name: string | null
    file_type: string | null
    total_records: number | null
    valid_records: number | null
    invalid_records: number | null
    imported_records: number | null
    status: $Enums.ImportStatus | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ImportBatchMaxAggregateOutputType = {
    id: string | null
    batch_name: string | null
    import_type: $Enums.ImportType | null
    file_name: string | null
    file_type: string | null
    total_records: number | null
    valid_records: number | null
    invalid_records: number | null
    imported_records: number | null
    status: $Enums.ImportStatus | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ImportBatchCountAggregateOutputType = {
    id: number
    batch_name: number
    import_type: number
    file_name: number
    file_type: number
    total_records: number
    valid_records: number
    invalid_records: number
    imported_records: number
    status: number
    error_details: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ImportBatchAvgAggregateInputType = {
    total_records?: true
    valid_records?: true
    invalid_records?: true
    imported_records?: true
  }

  export type ImportBatchSumAggregateInputType = {
    total_records?: true
    valid_records?: true
    invalid_records?: true
    imported_records?: true
  }

  export type ImportBatchMinAggregateInputType = {
    id?: true
    batch_name?: true
    import_type?: true
    file_name?: true
    file_type?: true
    total_records?: true
    valid_records?: true
    invalid_records?: true
    imported_records?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type ImportBatchMaxAggregateInputType = {
    id?: true
    batch_name?: true
    import_type?: true
    file_name?: true
    file_type?: true
    total_records?: true
    valid_records?: true
    invalid_records?: true
    imported_records?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type ImportBatchCountAggregateInputType = {
    id?: true
    batch_name?: true
    import_type?: true
    file_name?: true
    file_type?: true
    total_records?: true
    valid_records?: true
    invalid_records?: true
    imported_records?: true
    status?: true
    error_details?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ImportBatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportBatch to aggregate.
     */
    where?: ImportBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportBatches to fetch.
     */
    orderBy?: ImportBatchOrderByWithRelationInput | ImportBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImportBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImportBatches
    **/
    _count?: true | ImportBatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImportBatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImportBatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImportBatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImportBatchMaxAggregateInputType
  }

  export type GetImportBatchAggregateType<T extends ImportBatchAggregateArgs> = {
        [P in keyof T & keyof AggregateImportBatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImportBatch[P]>
      : GetScalarType<T[P], AggregateImportBatch[P]>
  }




  export type ImportBatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImportBatchWhereInput
    orderBy?: ImportBatchOrderByWithAggregationInput | ImportBatchOrderByWithAggregationInput[]
    by: ImportBatchScalarFieldEnum[] | ImportBatchScalarFieldEnum
    having?: ImportBatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImportBatchCountAggregateInputType | true
    _avg?: ImportBatchAvgAggregateInputType
    _sum?: ImportBatchSumAggregateInputType
    _min?: ImportBatchMinAggregateInputType
    _max?: ImportBatchMaxAggregateInputType
  }

  export type ImportBatchGroupByOutputType = {
    id: string
    batch_name: string
    import_type: $Enums.ImportType
    file_name: string
    file_type: string
    total_records: number
    valid_records: number
    invalid_records: number
    imported_records: number
    status: $Enums.ImportStatus
    error_details: JsonValue | null
    created_at: Date
    updated_at: Date
    _count: ImportBatchCountAggregateOutputType | null
    _avg: ImportBatchAvgAggregateOutputType | null
    _sum: ImportBatchSumAggregateOutputType | null
    _min: ImportBatchMinAggregateOutputType | null
    _max: ImportBatchMaxAggregateOutputType | null
  }

  type GetImportBatchGroupByPayload<T extends ImportBatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImportBatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImportBatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImportBatchGroupByOutputType[P]>
            : GetScalarType<T[P], ImportBatchGroupByOutputType[P]>
        }
      >
    >


  export type ImportBatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batch_name?: boolean
    import_type?: boolean
    file_name?: boolean
    file_type?: boolean
    total_records?: boolean
    valid_records?: boolean
    invalid_records?: boolean
    imported_records?: boolean
    status?: boolean
    error_details?: boolean
    created_at?: boolean
    updated_at?: boolean
    sales_data?: boolean | ImportBatch$sales_dataArgs<ExtArgs>
    product_data?: boolean | ImportBatch$product_dataArgs<ExtArgs>
    stock_data?: boolean | ImportBatch$stock_dataArgs<ExtArgs>
    advertising_data?: boolean | ImportBatch$advertising_dataArgs<ExtArgs>
    advertising_settlement?: boolean | ImportBatch$advertising_settlementArgs<ExtArgs>
    returns_and_cancellations?: boolean | ImportBatch$returns_and_cancellationsArgs<ExtArgs>
    marketplace_reimbursements?: boolean | ImportBatch$marketplace_reimbursementsArgs<ExtArgs>
    commission_adjustments?: boolean | ImportBatch$commission_adjustmentsArgs<ExtArgs>
    affiliate_samples?: boolean | ImportBatch$affiliate_samplesArgs<ExtArgs>
    _count?: boolean | ImportBatchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["importBatch"]>

  export type ImportBatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    batch_name?: boolean
    import_type?: boolean
    file_name?: boolean
    file_type?: boolean
    total_records?: boolean
    valid_records?: boolean
    invalid_records?: boolean
    imported_records?: boolean
    status?: boolean
    error_details?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["importBatch"]>

  export type ImportBatchSelectScalar = {
    id?: boolean
    batch_name?: boolean
    import_type?: boolean
    file_name?: boolean
    file_type?: boolean
    total_records?: boolean
    valid_records?: boolean
    invalid_records?: boolean
    imported_records?: boolean
    status?: boolean
    error_details?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ImportBatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales_data?: boolean | ImportBatch$sales_dataArgs<ExtArgs>
    product_data?: boolean | ImportBatch$product_dataArgs<ExtArgs>
    stock_data?: boolean | ImportBatch$stock_dataArgs<ExtArgs>
    advertising_data?: boolean | ImportBatch$advertising_dataArgs<ExtArgs>
    advertising_settlement?: boolean | ImportBatch$advertising_settlementArgs<ExtArgs>
    returns_and_cancellations?: boolean | ImportBatch$returns_and_cancellationsArgs<ExtArgs>
    marketplace_reimbursements?: boolean | ImportBatch$marketplace_reimbursementsArgs<ExtArgs>
    commission_adjustments?: boolean | ImportBatch$commission_adjustmentsArgs<ExtArgs>
    affiliate_samples?: boolean | ImportBatch$affiliate_samplesArgs<ExtArgs>
    _count?: boolean | ImportBatchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ImportBatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ImportBatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImportBatch"
    objects: {
      sales_data: Prisma.$SalesDataPayload<ExtArgs>[]
      product_data: Prisma.$ProductDataPayload<ExtArgs>[]
      stock_data: Prisma.$StockDataPayload<ExtArgs>[]
      advertising_data: Prisma.$AdvertisingDataPayload<ExtArgs>[]
      advertising_settlement: Prisma.$AdvertisingSettlementPayload<ExtArgs>[]
      returns_and_cancellations: Prisma.$ReturnsAndCancellationsPayload<ExtArgs>[]
      marketplace_reimbursements: Prisma.$MarketplaceReimbursementPayload<ExtArgs>[]
      commission_adjustments: Prisma.$CommissionAdjustmentsPayload<ExtArgs>[]
      affiliate_samples: Prisma.$AffiliateSamplesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      batch_name: string
      import_type: $Enums.ImportType
      file_name: string
      file_type: string
      total_records: number
      valid_records: number
      invalid_records: number
      imported_records: number
      status: $Enums.ImportStatus
      error_details: Prisma.JsonValue | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["importBatch"]>
    composites: {}
  }

  type ImportBatchGetPayload<S extends boolean | null | undefined | ImportBatchDefaultArgs> = $Result.GetResult<Prisma.$ImportBatchPayload, S>

  type ImportBatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ImportBatchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ImportBatchCountAggregateInputType | true
    }

  export interface ImportBatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImportBatch'], meta: { name: 'ImportBatch' } }
    /**
     * Find zero or one ImportBatch that matches the filter.
     * @param {ImportBatchFindUniqueArgs} args - Arguments to find a ImportBatch
     * @example
     * // Get one ImportBatch
     * const importBatch = await prisma.importBatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImportBatchFindUniqueArgs>(args: SelectSubset<T, ImportBatchFindUniqueArgs<ExtArgs>>): Prisma__ImportBatchClient<$Result.GetResult<Prisma.$ImportBatchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ImportBatch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ImportBatchFindUniqueOrThrowArgs} args - Arguments to find a ImportBatch
     * @example
     * // Get one ImportBatch
     * const importBatch = await prisma.importBatch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImportBatchFindUniqueOrThrowArgs>(args: SelectSubset<T, ImportBatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImportBatchClient<$Result.GetResult<Prisma.$ImportBatchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ImportBatch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportBatchFindFirstArgs} args - Arguments to find a ImportBatch
     * @example
     * // Get one ImportBatch
     * const importBatch = await prisma.importBatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImportBatchFindFirstArgs>(args?: SelectSubset<T, ImportBatchFindFirstArgs<ExtArgs>>): Prisma__ImportBatchClient<$Result.GetResult<Prisma.$ImportBatchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ImportBatch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportBatchFindFirstOrThrowArgs} args - Arguments to find a ImportBatch
     * @example
     * // Get one ImportBatch
     * const importBatch = await prisma.importBatch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImportBatchFindFirstOrThrowArgs>(args?: SelectSubset<T, ImportBatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImportBatchClient<$Result.GetResult<Prisma.$ImportBatchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ImportBatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportBatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImportBatches
     * const importBatches = await prisma.importBatch.findMany()
     * 
     * // Get first 10 ImportBatches
     * const importBatches = await prisma.importBatch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const importBatchWithIdOnly = await prisma.importBatch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImportBatchFindManyArgs>(args?: SelectSubset<T, ImportBatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportBatchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ImportBatch.
     * @param {ImportBatchCreateArgs} args - Arguments to create a ImportBatch.
     * @example
     * // Create one ImportBatch
     * const ImportBatch = await prisma.importBatch.create({
     *   data: {
     *     // ... data to create a ImportBatch
     *   }
     * })
     * 
     */
    create<T extends ImportBatchCreateArgs>(args: SelectSubset<T, ImportBatchCreateArgs<ExtArgs>>): Prisma__ImportBatchClient<$Result.GetResult<Prisma.$ImportBatchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ImportBatches.
     * @param {ImportBatchCreateManyArgs} args - Arguments to create many ImportBatches.
     * @example
     * // Create many ImportBatches
     * const importBatch = await prisma.importBatch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImportBatchCreateManyArgs>(args?: SelectSubset<T, ImportBatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ImportBatches and returns the data saved in the database.
     * @param {ImportBatchCreateManyAndReturnArgs} args - Arguments to create many ImportBatches.
     * @example
     * // Create many ImportBatches
     * const importBatch = await prisma.importBatch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ImportBatches and only return the `id`
     * const importBatchWithIdOnly = await prisma.importBatch.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImportBatchCreateManyAndReturnArgs>(args?: SelectSubset<T, ImportBatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportBatchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ImportBatch.
     * @param {ImportBatchDeleteArgs} args - Arguments to delete one ImportBatch.
     * @example
     * // Delete one ImportBatch
     * const ImportBatch = await prisma.importBatch.delete({
     *   where: {
     *     // ... filter to delete one ImportBatch
     *   }
     * })
     * 
     */
    delete<T extends ImportBatchDeleteArgs>(args: SelectSubset<T, ImportBatchDeleteArgs<ExtArgs>>): Prisma__ImportBatchClient<$Result.GetResult<Prisma.$ImportBatchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ImportBatch.
     * @param {ImportBatchUpdateArgs} args - Arguments to update one ImportBatch.
     * @example
     * // Update one ImportBatch
     * const importBatch = await prisma.importBatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImportBatchUpdateArgs>(args: SelectSubset<T, ImportBatchUpdateArgs<ExtArgs>>): Prisma__ImportBatchClient<$Result.GetResult<Prisma.$ImportBatchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ImportBatches.
     * @param {ImportBatchDeleteManyArgs} args - Arguments to filter ImportBatches to delete.
     * @example
     * // Delete a few ImportBatches
     * const { count } = await prisma.importBatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImportBatchDeleteManyArgs>(args?: SelectSubset<T, ImportBatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImportBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportBatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImportBatches
     * const importBatch = await prisma.importBatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImportBatchUpdateManyArgs>(args: SelectSubset<T, ImportBatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ImportBatch.
     * @param {ImportBatchUpsertArgs} args - Arguments to update or create a ImportBatch.
     * @example
     * // Update or create a ImportBatch
     * const importBatch = await prisma.importBatch.upsert({
     *   create: {
     *     // ... data to create a ImportBatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImportBatch we want to update
     *   }
     * })
     */
    upsert<T extends ImportBatchUpsertArgs>(args: SelectSubset<T, ImportBatchUpsertArgs<ExtArgs>>): Prisma__ImportBatchClient<$Result.GetResult<Prisma.$ImportBatchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ImportBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportBatchCountArgs} args - Arguments to filter ImportBatches to count.
     * @example
     * // Count the number of ImportBatches
     * const count = await prisma.importBatch.count({
     *   where: {
     *     // ... the filter for the ImportBatches we want to count
     *   }
     * })
    **/
    count<T extends ImportBatchCountArgs>(
      args?: Subset<T, ImportBatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImportBatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImportBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportBatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImportBatchAggregateArgs>(args: Subset<T, ImportBatchAggregateArgs>): Prisma.PrismaPromise<GetImportBatchAggregateType<T>>

    /**
     * Group by ImportBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportBatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImportBatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImportBatchGroupByArgs['orderBy'] }
        : { orderBy?: ImportBatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImportBatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImportBatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImportBatch model
   */
  readonly fields: ImportBatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImportBatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImportBatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sales_data<T extends ImportBatch$sales_dataArgs<ExtArgs> = {}>(args?: Subset<T, ImportBatch$sales_dataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesDataPayload<ExtArgs>, T, "findMany"> | Null>
    product_data<T extends ImportBatch$product_dataArgs<ExtArgs> = {}>(args?: Subset<T, ImportBatch$product_dataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductDataPayload<ExtArgs>, T, "findMany"> | Null>
    stock_data<T extends ImportBatch$stock_dataArgs<ExtArgs> = {}>(args?: Subset<T, ImportBatch$stock_dataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockDataPayload<ExtArgs>, T, "findMany"> | Null>
    advertising_data<T extends ImportBatch$advertising_dataArgs<ExtArgs> = {}>(args?: Subset<T, ImportBatch$advertising_dataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvertisingDataPayload<ExtArgs>, T, "findMany"> | Null>
    advertising_settlement<T extends ImportBatch$advertising_settlementArgs<ExtArgs> = {}>(args?: Subset<T, ImportBatch$advertising_settlementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvertisingSettlementPayload<ExtArgs>, T, "findMany"> | Null>
    returns_and_cancellations<T extends ImportBatch$returns_and_cancellationsArgs<ExtArgs> = {}>(args?: Subset<T, ImportBatch$returns_and_cancellationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnsAndCancellationsPayload<ExtArgs>, T, "findMany"> | Null>
    marketplace_reimbursements<T extends ImportBatch$marketplace_reimbursementsArgs<ExtArgs> = {}>(args?: Subset<T, ImportBatch$marketplace_reimbursementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceReimbursementPayload<ExtArgs>, T, "findMany"> | Null>
    commission_adjustments<T extends ImportBatch$commission_adjustmentsArgs<ExtArgs> = {}>(args?: Subset<T, ImportBatch$commission_adjustmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionAdjustmentsPayload<ExtArgs>, T, "findMany"> | Null>
    affiliate_samples<T extends ImportBatch$affiliate_samplesArgs<ExtArgs> = {}>(args?: Subset<T, ImportBatch$affiliate_samplesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateSamplesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImportBatch model
   */ 
  interface ImportBatchFieldRefs {
    readonly id: FieldRef<"ImportBatch", 'String'>
    readonly batch_name: FieldRef<"ImportBatch", 'String'>
    readonly import_type: FieldRef<"ImportBatch", 'ImportType'>
    readonly file_name: FieldRef<"ImportBatch", 'String'>
    readonly file_type: FieldRef<"ImportBatch", 'String'>
    readonly total_records: FieldRef<"ImportBatch", 'Int'>
    readonly valid_records: FieldRef<"ImportBatch", 'Int'>
    readonly invalid_records: FieldRef<"ImportBatch", 'Int'>
    readonly imported_records: FieldRef<"ImportBatch", 'Int'>
    readonly status: FieldRef<"ImportBatch", 'ImportStatus'>
    readonly error_details: FieldRef<"ImportBatch", 'Json'>
    readonly created_at: FieldRef<"ImportBatch", 'DateTime'>
    readonly updated_at: FieldRef<"ImportBatch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ImportBatch findUnique
   */
  export type ImportBatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportBatch
     */
    select?: ImportBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportBatchInclude<ExtArgs> | null
    /**
     * Filter, which ImportBatch to fetch.
     */
    where: ImportBatchWhereUniqueInput
  }

  /**
   * ImportBatch findUniqueOrThrow
   */
  export type ImportBatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportBatch
     */
    select?: ImportBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportBatchInclude<ExtArgs> | null
    /**
     * Filter, which ImportBatch to fetch.
     */
    where: ImportBatchWhereUniqueInput
  }

  /**
   * ImportBatch findFirst
   */
  export type ImportBatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportBatch
     */
    select?: ImportBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportBatchInclude<ExtArgs> | null
    /**
     * Filter, which ImportBatch to fetch.
     */
    where?: ImportBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportBatches to fetch.
     */
    orderBy?: ImportBatchOrderByWithRelationInput | ImportBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportBatches.
     */
    cursor?: ImportBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportBatches.
     */
    distinct?: ImportBatchScalarFieldEnum | ImportBatchScalarFieldEnum[]
  }

  /**
   * ImportBatch findFirstOrThrow
   */
  export type ImportBatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportBatch
     */
    select?: ImportBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportBatchInclude<ExtArgs> | null
    /**
     * Filter, which ImportBatch to fetch.
     */
    where?: ImportBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportBatches to fetch.
     */
    orderBy?: ImportBatchOrderByWithRelationInput | ImportBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportBatches.
     */
    cursor?: ImportBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportBatches.
     */
    distinct?: ImportBatchScalarFieldEnum | ImportBatchScalarFieldEnum[]
  }

  /**
   * ImportBatch findMany
   */
  export type ImportBatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportBatch
     */
    select?: ImportBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportBatchInclude<ExtArgs> | null
    /**
     * Filter, which ImportBatches to fetch.
     */
    where?: ImportBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportBatches to fetch.
     */
    orderBy?: ImportBatchOrderByWithRelationInput | ImportBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImportBatches.
     */
    cursor?: ImportBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportBatches.
     */
    skip?: number
    distinct?: ImportBatchScalarFieldEnum | ImportBatchScalarFieldEnum[]
  }

  /**
   * ImportBatch create
   */
  export type ImportBatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportBatch
     */
    select?: ImportBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportBatchInclude<ExtArgs> | null
    /**
     * The data needed to create a ImportBatch.
     */
    data: XOR<ImportBatchCreateInput, ImportBatchUncheckedCreateInput>
  }

  /**
   * ImportBatch createMany
   */
  export type ImportBatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImportBatches.
     */
    data: ImportBatchCreateManyInput | ImportBatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ImportBatch createManyAndReturn
   */
  export type ImportBatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportBatch
     */
    select?: ImportBatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ImportBatches.
     */
    data: ImportBatchCreateManyInput | ImportBatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ImportBatch update
   */
  export type ImportBatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportBatch
     */
    select?: ImportBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportBatchInclude<ExtArgs> | null
    /**
     * The data needed to update a ImportBatch.
     */
    data: XOR<ImportBatchUpdateInput, ImportBatchUncheckedUpdateInput>
    /**
     * Choose, which ImportBatch to update.
     */
    where: ImportBatchWhereUniqueInput
  }

  /**
   * ImportBatch updateMany
   */
  export type ImportBatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImportBatches.
     */
    data: XOR<ImportBatchUpdateManyMutationInput, ImportBatchUncheckedUpdateManyInput>
    /**
     * Filter which ImportBatches to update
     */
    where?: ImportBatchWhereInput
  }

  /**
   * ImportBatch upsert
   */
  export type ImportBatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportBatch
     */
    select?: ImportBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportBatchInclude<ExtArgs> | null
    /**
     * The filter to search for the ImportBatch to update in case it exists.
     */
    where: ImportBatchWhereUniqueInput
    /**
     * In case the ImportBatch found by the `where` argument doesn't exist, create a new ImportBatch with this data.
     */
    create: XOR<ImportBatchCreateInput, ImportBatchUncheckedCreateInput>
    /**
     * In case the ImportBatch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImportBatchUpdateInput, ImportBatchUncheckedUpdateInput>
  }

  /**
   * ImportBatch delete
   */
  export type ImportBatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportBatch
     */
    select?: ImportBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportBatchInclude<ExtArgs> | null
    /**
     * Filter which ImportBatch to delete.
     */
    where: ImportBatchWhereUniqueInput
  }

  /**
   * ImportBatch deleteMany
   */
  export type ImportBatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportBatches to delete
     */
    where?: ImportBatchWhereInput
  }

  /**
   * ImportBatch.sales_data
   */
  export type ImportBatch$sales_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesData
     */
    select?: SalesDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesDataInclude<ExtArgs> | null
    where?: SalesDataWhereInput
    orderBy?: SalesDataOrderByWithRelationInput | SalesDataOrderByWithRelationInput[]
    cursor?: SalesDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesDataScalarFieldEnum | SalesDataScalarFieldEnum[]
  }

  /**
   * ImportBatch.product_data
   */
  export type ImportBatch$product_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductData
     */
    select?: ProductDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductDataInclude<ExtArgs> | null
    where?: ProductDataWhereInput
    orderBy?: ProductDataOrderByWithRelationInput | ProductDataOrderByWithRelationInput[]
    cursor?: ProductDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductDataScalarFieldEnum | ProductDataScalarFieldEnum[]
  }

  /**
   * ImportBatch.stock_data
   */
  export type ImportBatch$stock_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockData
     */
    select?: StockDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockDataInclude<ExtArgs> | null
    where?: StockDataWhereInput
    orderBy?: StockDataOrderByWithRelationInput | StockDataOrderByWithRelationInput[]
    cursor?: StockDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockDataScalarFieldEnum | StockDataScalarFieldEnum[]
  }

  /**
   * ImportBatch.advertising_data
   */
  export type ImportBatch$advertising_dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvertisingData
     */
    select?: AdvertisingDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisingDataInclude<ExtArgs> | null
    where?: AdvertisingDataWhereInput
    orderBy?: AdvertisingDataOrderByWithRelationInput | AdvertisingDataOrderByWithRelationInput[]
    cursor?: AdvertisingDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdvertisingDataScalarFieldEnum | AdvertisingDataScalarFieldEnum[]
  }

  /**
   * ImportBatch.advertising_settlement
   */
  export type ImportBatch$advertising_settlementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvertisingSettlement
     */
    select?: AdvertisingSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisingSettlementInclude<ExtArgs> | null
    where?: AdvertisingSettlementWhereInput
    orderBy?: AdvertisingSettlementOrderByWithRelationInput | AdvertisingSettlementOrderByWithRelationInput[]
    cursor?: AdvertisingSettlementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdvertisingSettlementScalarFieldEnum | AdvertisingSettlementScalarFieldEnum[]
  }

  /**
   * ImportBatch.returns_and_cancellations
   */
  export type ImportBatch$returns_and_cancellationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnsAndCancellations
     */
    select?: ReturnsAndCancellationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnsAndCancellationsInclude<ExtArgs> | null
    where?: ReturnsAndCancellationsWhereInput
    orderBy?: ReturnsAndCancellationsOrderByWithRelationInput | ReturnsAndCancellationsOrderByWithRelationInput[]
    cursor?: ReturnsAndCancellationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReturnsAndCancellationsScalarFieldEnum | ReturnsAndCancellationsScalarFieldEnum[]
  }

  /**
   * ImportBatch.marketplace_reimbursements
   */
  export type ImportBatch$marketplace_reimbursementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceReimbursement
     */
    select?: MarketplaceReimbursementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceReimbursementInclude<ExtArgs> | null
    where?: MarketplaceReimbursementWhereInput
    orderBy?: MarketplaceReimbursementOrderByWithRelationInput | MarketplaceReimbursementOrderByWithRelationInput[]
    cursor?: MarketplaceReimbursementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketplaceReimbursementScalarFieldEnum | MarketplaceReimbursementScalarFieldEnum[]
  }

  /**
   * ImportBatch.commission_adjustments
   */
  export type ImportBatch$commission_adjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionAdjustments
     */
    select?: CommissionAdjustmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionAdjustmentsInclude<ExtArgs> | null
    where?: CommissionAdjustmentsWhereInput
    orderBy?: CommissionAdjustmentsOrderByWithRelationInput | CommissionAdjustmentsOrderByWithRelationInput[]
    cursor?: CommissionAdjustmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommissionAdjustmentsScalarFieldEnum | CommissionAdjustmentsScalarFieldEnum[]
  }

  /**
   * ImportBatch.affiliate_samples
   */
  export type ImportBatch$affiliate_samplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateSamples
     */
    select?: AffiliateSamplesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateSamplesInclude<ExtArgs> | null
    where?: AffiliateSamplesWhereInput
    orderBy?: AffiliateSamplesOrderByWithRelationInput | AffiliateSamplesOrderByWithRelationInput[]
    cursor?: AffiliateSamplesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AffiliateSamplesScalarFieldEnum | AffiliateSamplesScalarFieldEnum[]
  }

  /**
   * ImportBatch without action
   */
  export type ImportBatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportBatch
     */
    select?: ImportBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportBatchInclude<ExtArgs> | null
  }


  /**
   * Model AdvertisingData
   */

  export type AggregateAdvertisingData = {
    _count: AdvertisingDataCountAggregateOutputType | null
    _avg: AdvertisingDataAvgAggregateOutputType | null
    _sum: AdvertisingDataSumAggregateOutputType | null
    _min: AdvertisingDataMinAggregateOutputType | null
    _max: AdvertisingDataMaxAggregateOutputType | null
  }

  export type AdvertisingDataAvgAggregateOutputType = {
    cost: number | null
    conversions: number | null
    cpa: number | null
    revenue: number | null
    roi: number | null
    impressions: number | null
    clicks: number | null
    ctr: number | null
    conversion_rate: number | null
  }

  export type AdvertisingDataSumAggregateOutputType = {
    cost: number | null
    conversions: number | null
    cpa: number | null
    revenue: number | null
    roi: number | null
    impressions: number | null
    clicks: number | null
    ctr: number | null
    conversion_rate: number | null
  }

  export type AdvertisingDataMinAggregateOutputType = {
    id: string | null
    campaign_name: string | null
    ad_creative_type: string | null
    ad_creative: string | null
    account_name: string | null
    cost: number | null
    conversions: number | null
    cpa: number | null
    revenue: number | null
    roi: number | null
    impressions: number | null
    clicks: number | null
    ctr: number | null
    conversion_rate: number | null
    date_start: Date | null
    date_end: Date | null
    marketplace: string | null
    nama_produk: string | null
    import_batch_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AdvertisingDataMaxAggregateOutputType = {
    id: string | null
    campaign_name: string | null
    ad_creative_type: string | null
    ad_creative: string | null
    account_name: string | null
    cost: number | null
    conversions: number | null
    cpa: number | null
    revenue: number | null
    roi: number | null
    impressions: number | null
    clicks: number | null
    ctr: number | null
    conversion_rate: number | null
    date_start: Date | null
    date_end: Date | null
    marketplace: string | null
    nama_produk: string | null
    import_batch_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AdvertisingDataCountAggregateOutputType = {
    id: number
    campaign_name: number
    ad_creative_type: number
    ad_creative: number
    account_name: number
    cost: number
    conversions: number
    cpa: number
    revenue: number
    roi: number
    impressions: number
    clicks: number
    ctr: number
    conversion_rate: number
    date_start: number
    date_end: number
    marketplace: number
    nama_produk: number
    import_batch_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AdvertisingDataAvgAggregateInputType = {
    cost?: true
    conversions?: true
    cpa?: true
    revenue?: true
    roi?: true
    impressions?: true
    clicks?: true
    ctr?: true
    conversion_rate?: true
  }

  export type AdvertisingDataSumAggregateInputType = {
    cost?: true
    conversions?: true
    cpa?: true
    revenue?: true
    roi?: true
    impressions?: true
    clicks?: true
    ctr?: true
    conversion_rate?: true
  }

  export type AdvertisingDataMinAggregateInputType = {
    id?: true
    campaign_name?: true
    ad_creative_type?: true
    ad_creative?: true
    account_name?: true
    cost?: true
    conversions?: true
    cpa?: true
    revenue?: true
    roi?: true
    impressions?: true
    clicks?: true
    ctr?: true
    conversion_rate?: true
    date_start?: true
    date_end?: true
    marketplace?: true
    nama_produk?: true
    import_batch_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AdvertisingDataMaxAggregateInputType = {
    id?: true
    campaign_name?: true
    ad_creative_type?: true
    ad_creative?: true
    account_name?: true
    cost?: true
    conversions?: true
    cpa?: true
    revenue?: true
    roi?: true
    impressions?: true
    clicks?: true
    ctr?: true
    conversion_rate?: true
    date_start?: true
    date_end?: true
    marketplace?: true
    nama_produk?: true
    import_batch_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AdvertisingDataCountAggregateInputType = {
    id?: true
    campaign_name?: true
    ad_creative_type?: true
    ad_creative?: true
    account_name?: true
    cost?: true
    conversions?: true
    cpa?: true
    revenue?: true
    roi?: true
    impressions?: true
    clicks?: true
    ctr?: true
    conversion_rate?: true
    date_start?: true
    date_end?: true
    marketplace?: true
    nama_produk?: true
    import_batch_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AdvertisingDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdvertisingData to aggregate.
     */
    where?: AdvertisingDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdvertisingData to fetch.
     */
    orderBy?: AdvertisingDataOrderByWithRelationInput | AdvertisingDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdvertisingDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdvertisingData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdvertisingData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdvertisingData
    **/
    _count?: true | AdvertisingDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdvertisingDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdvertisingDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdvertisingDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdvertisingDataMaxAggregateInputType
  }

  export type GetAdvertisingDataAggregateType<T extends AdvertisingDataAggregateArgs> = {
        [P in keyof T & keyof AggregateAdvertisingData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdvertisingData[P]>
      : GetScalarType<T[P], AggregateAdvertisingData[P]>
  }




  export type AdvertisingDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdvertisingDataWhereInput
    orderBy?: AdvertisingDataOrderByWithAggregationInput | AdvertisingDataOrderByWithAggregationInput[]
    by: AdvertisingDataScalarFieldEnum[] | AdvertisingDataScalarFieldEnum
    having?: AdvertisingDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdvertisingDataCountAggregateInputType | true
    _avg?: AdvertisingDataAvgAggregateInputType
    _sum?: AdvertisingDataSumAggregateInputType
    _min?: AdvertisingDataMinAggregateInputType
    _max?: AdvertisingDataMaxAggregateInputType
  }

  export type AdvertisingDataGroupByOutputType = {
    id: string
    campaign_name: string
    ad_creative_type: string | null
    ad_creative: string | null
    account_name: string | null
    cost: number
    conversions: number
    cpa: number | null
    revenue: number
    roi: number | null
    impressions: number
    clicks: number
    ctr: number | null
    conversion_rate: number | null
    date_start: Date
    date_end: Date
    marketplace: string | null
    nama_produk: string | null
    import_batch_id: string | null
    created_at: Date
    updated_at: Date
    _count: AdvertisingDataCountAggregateOutputType | null
    _avg: AdvertisingDataAvgAggregateOutputType | null
    _sum: AdvertisingDataSumAggregateOutputType | null
    _min: AdvertisingDataMinAggregateOutputType | null
    _max: AdvertisingDataMaxAggregateOutputType | null
  }

  type GetAdvertisingDataGroupByPayload<T extends AdvertisingDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdvertisingDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdvertisingDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdvertisingDataGroupByOutputType[P]>
            : GetScalarType<T[P], AdvertisingDataGroupByOutputType[P]>
        }
      >
    >


  export type AdvertisingDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaign_name?: boolean
    ad_creative_type?: boolean
    ad_creative?: boolean
    account_name?: boolean
    cost?: boolean
    conversions?: boolean
    cpa?: boolean
    revenue?: boolean
    roi?: boolean
    impressions?: boolean
    clicks?: boolean
    ctr?: boolean
    conversion_rate?: boolean
    date_start?: boolean
    date_end?: boolean
    marketplace?: boolean
    nama_produk?: boolean
    import_batch_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    import_batch?: boolean | AdvertisingData$import_batchArgs<ExtArgs>
  }, ExtArgs["result"]["advertisingData"]>

  export type AdvertisingDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaign_name?: boolean
    ad_creative_type?: boolean
    ad_creative?: boolean
    account_name?: boolean
    cost?: boolean
    conversions?: boolean
    cpa?: boolean
    revenue?: boolean
    roi?: boolean
    impressions?: boolean
    clicks?: boolean
    ctr?: boolean
    conversion_rate?: boolean
    date_start?: boolean
    date_end?: boolean
    marketplace?: boolean
    nama_produk?: boolean
    import_batch_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    import_batch?: boolean | AdvertisingData$import_batchArgs<ExtArgs>
  }, ExtArgs["result"]["advertisingData"]>

  export type AdvertisingDataSelectScalar = {
    id?: boolean
    campaign_name?: boolean
    ad_creative_type?: boolean
    ad_creative?: boolean
    account_name?: boolean
    cost?: boolean
    conversions?: boolean
    cpa?: boolean
    revenue?: boolean
    roi?: boolean
    impressions?: boolean
    clicks?: boolean
    ctr?: boolean
    conversion_rate?: boolean
    date_start?: boolean
    date_end?: boolean
    marketplace?: boolean
    nama_produk?: boolean
    import_batch_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type AdvertisingDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    import_batch?: boolean | AdvertisingData$import_batchArgs<ExtArgs>
  }
  export type AdvertisingDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    import_batch?: boolean | AdvertisingData$import_batchArgs<ExtArgs>
  }

  export type $AdvertisingDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdvertisingData"
    objects: {
      import_batch: Prisma.$ImportBatchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaign_name: string
      ad_creative_type: string | null
      ad_creative: string | null
      account_name: string | null
      cost: number
      conversions: number
      cpa: number | null
      revenue: number
      roi: number | null
      impressions: number
      clicks: number
      ctr: number | null
      conversion_rate: number | null
      date_start: Date
      date_end: Date
      marketplace: string | null
      nama_produk: string | null
      import_batch_id: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["advertisingData"]>
    composites: {}
  }

  type AdvertisingDataGetPayload<S extends boolean | null | undefined | AdvertisingDataDefaultArgs> = $Result.GetResult<Prisma.$AdvertisingDataPayload, S>

  type AdvertisingDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdvertisingDataFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdvertisingDataCountAggregateInputType | true
    }

  export interface AdvertisingDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdvertisingData'], meta: { name: 'AdvertisingData' } }
    /**
     * Find zero or one AdvertisingData that matches the filter.
     * @param {AdvertisingDataFindUniqueArgs} args - Arguments to find a AdvertisingData
     * @example
     * // Get one AdvertisingData
     * const advertisingData = await prisma.advertisingData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdvertisingDataFindUniqueArgs>(args: SelectSubset<T, AdvertisingDataFindUniqueArgs<ExtArgs>>): Prisma__AdvertisingDataClient<$Result.GetResult<Prisma.$AdvertisingDataPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdvertisingData that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdvertisingDataFindUniqueOrThrowArgs} args - Arguments to find a AdvertisingData
     * @example
     * // Get one AdvertisingData
     * const advertisingData = await prisma.advertisingData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdvertisingDataFindUniqueOrThrowArgs>(args: SelectSubset<T, AdvertisingDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdvertisingDataClient<$Result.GetResult<Prisma.$AdvertisingDataPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdvertisingData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisingDataFindFirstArgs} args - Arguments to find a AdvertisingData
     * @example
     * // Get one AdvertisingData
     * const advertisingData = await prisma.advertisingData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdvertisingDataFindFirstArgs>(args?: SelectSubset<T, AdvertisingDataFindFirstArgs<ExtArgs>>): Prisma__AdvertisingDataClient<$Result.GetResult<Prisma.$AdvertisingDataPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdvertisingData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisingDataFindFirstOrThrowArgs} args - Arguments to find a AdvertisingData
     * @example
     * // Get one AdvertisingData
     * const advertisingData = await prisma.advertisingData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdvertisingDataFindFirstOrThrowArgs>(args?: SelectSubset<T, AdvertisingDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdvertisingDataClient<$Result.GetResult<Prisma.$AdvertisingDataPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdvertisingData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisingDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdvertisingData
     * const advertisingData = await prisma.advertisingData.findMany()
     * 
     * // Get first 10 AdvertisingData
     * const advertisingData = await prisma.advertisingData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const advertisingDataWithIdOnly = await prisma.advertisingData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdvertisingDataFindManyArgs>(args?: SelectSubset<T, AdvertisingDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvertisingDataPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdvertisingData.
     * @param {AdvertisingDataCreateArgs} args - Arguments to create a AdvertisingData.
     * @example
     * // Create one AdvertisingData
     * const AdvertisingData = await prisma.advertisingData.create({
     *   data: {
     *     // ... data to create a AdvertisingData
     *   }
     * })
     * 
     */
    create<T extends AdvertisingDataCreateArgs>(args: SelectSubset<T, AdvertisingDataCreateArgs<ExtArgs>>): Prisma__AdvertisingDataClient<$Result.GetResult<Prisma.$AdvertisingDataPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdvertisingData.
     * @param {AdvertisingDataCreateManyArgs} args - Arguments to create many AdvertisingData.
     * @example
     * // Create many AdvertisingData
     * const advertisingData = await prisma.advertisingData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdvertisingDataCreateManyArgs>(args?: SelectSubset<T, AdvertisingDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdvertisingData and returns the data saved in the database.
     * @param {AdvertisingDataCreateManyAndReturnArgs} args - Arguments to create many AdvertisingData.
     * @example
     * // Create many AdvertisingData
     * const advertisingData = await prisma.advertisingData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdvertisingData and only return the `id`
     * const advertisingDataWithIdOnly = await prisma.advertisingData.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdvertisingDataCreateManyAndReturnArgs>(args?: SelectSubset<T, AdvertisingDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvertisingDataPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdvertisingData.
     * @param {AdvertisingDataDeleteArgs} args - Arguments to delete one AdvertisingData.
     * @example
     * // Delete one AdvertisingData
     * const AdvertisingData = await prisma.advertisingData.delete({
     *   where: {
     *     // ... filter to delete one AdvertisingData
     *   }
     * })
     * 
     */
    delete<T extends AdvertisingDataDeleteArgs>(args: SelectSubset<T, AdvertisingDataDeleteArgs<ExtArgs>>): Prisma__AdvertisingDataClient<$Result.GetResult<Prisma.$AdvertisingDataPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdvertisingData.
     * @param {AdvertisingDataUpdateArgs} args - Arguments to update one AdvertisingData.
     * @example
     * // Update one AdvertisingData
     * const advertisingData = await prisma.advertisingData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdvertisingDataUpdateArgs>(args: SelectSubset<T, AdvertisingDataUpdateArgs<ExtArgs>>): Prisma__AdvertisingDataClient<$Result.GetResult<Prisma.$AdvertisingDataPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdvertisingData.
     * @param {AdvertisingDataDeleteManyArgs} args - Arguments to filter AdvertisingData to delete.
     * @example
     * // Delete a few AdvertisingData
     * const { count } = await prisma.advertisingData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdvertisingDataDeleteManyArgs>(args?: SelectSubset<T, AdvertisingDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdvertisingData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisingDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdvertisingData
     * const advertisingData = await prisma.advertisingData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdvertisingDataUpdateManyArgs>(args: SelectSubset<T, AdvertisingDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdvertisingData.
     * @param {AdvertisingDataUpsertArgs} args - Arguments to update or create a AdvertisingData.
     * @example
     * // Update or create a AdvertisingData
     * const advertisingData = await prisma.advertisingData.upsert({
     *   create: {
     *     // ... data to create a AdvertisingData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdvertisingData we want to update
     *   }
     * })
     */
    upsert<T extends AdvertisingDataUpsertArgs>(args: SelectSubset<T, AdvertisingDataUpsertArgs<ExtArgs>>): Prisma__AdvertisingDataClient<$Result.GetResult<Prisma.$AdvertisingDataPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdvertisingData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisingDataCountArgs} args - Arguments to filter AdvertisingData to count.
     * @example
     * // Count the number of AdvertisingData
     * const count = await prisma.advertisingData.count({
     *   where: {
     *     // ... the filter for the AdvertisingData we want to count
     *   }
     * })
    **/
    count<T extends AdvertisingDataCountArgs>(
      args?: Subset<T, AdvertisingDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdvertisingDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdvertisingData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisingDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdvertisingDataAggregateArgs>(args: Subset<T, AdvertisingDataAggregateArgs>): Prisma.PrismaPromise<GetAdvertisingDataAggregateType<T>>

    /**
     * Group by AdvertisingData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisingDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdvertisingDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdvertisingDataGroupByArgs['orderBy'] }
        : { orderBy?: AdvertisingDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdvertisingDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdvertisingDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdvertisingData model
   */
  readonly fields: AdvertisingDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdvertisingData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdvertisingDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    import_batch<T extends AdvertisingData$import_batchArgs<ExtArgs> = {}>(args?: Subset<T, AdvertisingData$import_batchArgs<ExtArgs>>): Prisma__ImportBatchClient<$Result.GetResult<Prisma.$ImportBatchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdvertisingData model
   */ 
  interface AdvertisingDataFieldRefs {
    readonly id: FieldRef<"AdvertisingData", 'String'>
    readonly campaign_name: FieldRef<"AdvertisingData", 'String'>
    readonly ad_creative_type: FieldRef<"AdvertisingData", 'String'>
    readonly ad_creative: FieldRef<"AdvertisingData", 'String'>
    readonly account_name: FieldRef<"AdvertisingData", 'String'>
    readonly cost: FieldRef<"AdvertisingData", 'Float'>
    readonly conversions: FieldRef<"AdvertisingData", 'Int'>
    readonly cpa: FieldRef<"AdvertisingData", 'Float'>
    readonly revenue: FieldRef<"AdvertisingData", 'Float'>
    readonly roi: FieldRef<"AdvertisingData", 'Float'>
    readonly impressions: FieldRef<"AdvertisingData", 'Int'>
    readonly clicks: FieldRef<"AdvertisingData", 'Int'>
    readonly ctr: FieldRef<"AdvertisingData", 'Float'>
    readonly conversion_rate: FieldRef<"AdvertisingData", 'Float'>
    readonly date_start: FieldRef<"AdvertisingData", 'DateTime'>
    readonly date_end: FieldRef<"AdvertisingData", 'DateTime'>
    readonly marketplace: FieldRef<"AdvertisingData", 'String'>
    readonly nama_produk: FieldRef<"AdvertisingData", 'String'>
    readonly import_batch_id: FieldRef<"AdvertisingData", 'String'>
    readonly created_at: FieldRef<"AdvertisingData", 'DateTime'>
    readonly updated_at: FieldRef<"AdvertisingData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdvertisingData findUnique
   */
  export type AdvertisingDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvertisingData
     */
    select?: AdvertisingDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisingDataInclude<ExtArgs> | null
    /**
     * Filter, which AdvertisingData to fetch.
     */
    where: AdvertisingDataWhereUniqueInput
  }

  /**
   * AdvertisingData findUniqueOrThrow
   */
  export type AdvertisingDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvertisingData
     */
    select?: AdvertisingDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisingDataInclude<ExtArgs> | null
    /**
     * Filter, which AdvertisingData to fetch.
     */
    where: AdvertisingDataWhereUniqueInput
  }

  /**
   * AdvertisingData findFirst
   */
  export type AdvertisingDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvertisingData
     */
    select?: AdvertisingDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisingDataInclude<ExtArgs> | null
    /**
     * Filter, which AdvertisingData to fetch.
     */
    where?: AdvertisingDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdvertisingData to fetch.
     */
    orderBy?: AdvertisingDataOrderByWithRelationInput | AdvertisingDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdvertisingData.
     */
    cursor?: AdvertisingDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdvertisingData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdvertisingData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdvertisingData.
     */
    distinct?: AdvertisingDataScalarFieldEnum | AdvertisingDataScalarFieldEnum[]
  }

  /**
   * AdvertisingData findFirstOrThrow
   */
  export type AdvertisingDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvertisingData
     */
    select?: AdvertisingDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisingDataInclude<ExtArgs> | null
    /**
     * Filter, which AdvertisingData to fetch.
     */
    where?: AdvertisingDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdvertisingData to fetch.
     */
    orderBy?: AdvertisingDataOrderByWithRelationInput | AdvertisingDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdvertisingData.
     */
    cursor?: AdvertisingDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdvertisingData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdvertisingData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdvertisingData.
     */
    distinct?: AdvertisingDataScalarFieldEnum | AdvertisingDataScalarFieldEnum[]
  }

  /**
   * AdvertisingData findMany
   */
  export type AdvertisingDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvertisingData
     */
    select?: AdvertisingDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisingDataInclude<ExtArgs> | null
    /**
     * Filter, which AdvertisingData to fetch.
     */
    where?: AdvertisingDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdvertisingData to fetch.
     */
    orderBy?: AdvertisingDataOrderByWithRelationInput | AdvertisingDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdvertisingData.
     */
    cursor?: AdvertisingDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdvertisingData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdvertisingData.
     */
    skip?: number
    distinct?: AdvertisingDataScalarFieldEnum | AdvertisingDataScalarFieldEnum[]
  }

  /**
   * AdvertisingData create
   */
  export type AdvertisingDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvertisingData
     */
    select?: AdvertisingDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisingDataInclude<ExtArgs> | null
    /**
     * The data needed to create a AdvertisingData.
     */
    data: XOR<AdvertisingDataCreateInput, AdvertisingDataUncheckedCreateInput>
  }

  /**
   * AdvertisingData createMany
   */
  export type AdvertisingDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdvertisingData.
     */
    data: AdvertisingDataCreateManyInput | AdvertisingDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdvertisingData createManyAndReturn
   */
  export type AdvertisingDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvertisingData
     */
    select?: AdvertisingDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdvertisingData.
     */
    data: AdvertisingDataCreateManyInput | AdvertisingDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisingDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdvertisingData update
   */
  export type AdvertisingDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvertisingData
     */
    select?: AdvertisingDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisingDataInclude<ExtArgs> | null
    /**
     * The data needed to update a AdvertisingData.
     */
    data: XOR<AdvertisingDataUpdateInput, AdvertisingDataUncheckedUpdateInput>
    /**
     * Choose, which AdvertisingData to update.
     */
    where: AdvertisingDataWhereUniqueInput
  }

  /**
   * AdvertisingData updateMany
   */
  export type AdvertisingDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdvertisingData.
     */
    data: XOR<AdvertisingDataUpdateManyMutationInput, AdvertisingDataUncheckedUpdateManyInput>
    /**
     * Filter which AdvertisingData to update
     */
    where?: AdvertisingDataWhereInput
  }

  /**
   * AdvertisingData upsert
   */
  export type AdvertisingDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvertisingData
     */
    select?: AdvertisingDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisingDataInclude<ExtArgs> | null
    /**
     * The filter to search for the AdvertisingData to update in case it exists.
     */
    where: AdvertisingDataWhereUniqueInput
    /**
     * In case the AdvertisingData found by the `where` argument doesn't exist, create a new AdvertisingData with this data.
     */
    create: XOR<AdvertisingDataCreateInput, AdvertisingDataUncheckedCreateInput>
    /**
     * In case the AdvertisingData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdvertisingDataUpdateInput, AdvertisingDataUncheckedUpdateInput>
  }

  /**
   * AdvertisingData delete
   */
  export type AdvertisingDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvertisingData
     */
    select?: AdvertisingDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisingDataInclude<ExtArgs> | null
    /**
     * Filter which AdvertisingData to delete.
     */
    where: AdvertisingDataWhereUniqueInput
  }

  /**
   * AdvertisingData deleteMany
   */
  export type AdvertisingDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdvertisingData to delete
     */
    where?: AdvertisingDataWhereInput
  }

  /**
   * AdvertisingData.import_batch
   */
  export type AdvertisingData$import_batchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportBatch
     */
    select?: ImportBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportBatchInclude<ExtArgs> | null
    where?: ImportBatchWhereInput
  }

  /**
   * AdvertisingData without action
   */
  export type AdvertisingDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvertisingData
     */
    select?: AdvertisingDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisingDataInclude<ExtArgs> | null
  }


  /**
   * Model AdvertisingSettlement
   */

  export type AggregateAdvertisingSettlement = {
    _count: AdvertisingSettlementCountAggregateOutputType | null
    _avg: AdvertisingSettlementAvgAggregateOutputType | null
    _sum: AdvertisingSettlementSumAggregateOutputType | null
    _min: AdvertisingSettlementMinAggregateOutputType | null
    _max: AdvertisingSettlementMaxAggregateOutputType | null
  }

  export type AdvertisingSettlementAvgAggregateOutputType = {
    settlement_amount: number | null
  }

  export type AdvertisingSettlementSumAggregateOutputType = {
    settlement_amount: number | null
  }

  export type AdvertisingSettlementMinAggregateOutputType = {
    order_id: string | null
    type: string | null
    order_created_time: Date | null
    order_settled_time: Date | null
    settlement_amount: number | null
    settlement_period: string | null
    account_name: string | null
    marketplace: string | null
    currency: string | null
    import_batch_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AdvertisingSettlementMaxAggregateOutputType = {
    order_id: string | null
    type: string | null
    order_created_time: Date | null
    order_settled_time: Date | null
    settlement_amount: number | null
    settlement_period: string | null
    account_name: string | null
    marketplace: string | null
    currency: string | null
    import_batch_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AdvertisingSettlementCountAggregateOutputType = {
    order_id: number
    type: number
    order_created_time: number
    order_settled_time: number
    settlement_amount: number
    settlement_period: number
    account_name: number
    marketplace: number
    currency: number
    import_batch_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AdvertisingSettlementAvgAggregateInputType = {
    settlement_amount?: true
  }

  export type AdvertisingSettlementSumAggregateInputType = {
    settlement_amount?: true
  }

  export type AdvertisingSettlementMinAggregateInputType = {
    order_id?: true
    type?: true
    order_created_time?: true
    order_settled_time?: true
    settlement_amount?: true
    settlement_period?: true
    account_name?: true
    marketplace?: true
    currency?: true
    import_batch_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AdvertisingSettlementMaxAggregateInputType = {
    order_id?: true
    type?: true
    order_created_time?: true
    order_settled_time?: true
    settlement_amount?: true
    settlement_period?: true
    account_name?: true
    marketplace?: true
    currency?: true
    import_batch_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AdvertisingSettlementCountAggregateInputType = {
    order_id?: true
    type?: true
    order_created_time?: true
    order_settled_time?: true
    settlement_amount?: true
    settlement_period?: true
    account_name?: true
    marketplace?: true
    currency?: true
    import_batch_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AdvertisingSettlementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdvertisingSettlement to aggregate.
     */
    where?: AdvertisingSettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdvertisingSettlements to fetch.
     */
    orderBy?: AdvertisingSettlementOrderByWithRelationInput | AdvertisingSettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdvertisingSettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdvertisingSettlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdvertisingSettlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdvertisingSettlements
    **/
    _count?: true | AdvertisingSettlementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdvertisingSettlementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdvertisingSettlementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdvertisingSettlementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdvertisingSettlementMaxAggregateInputType
  }

  export type GetAdvertisingSettlementAggregateType<T extends AdvertisingSettlementAggregateArgs> = {
        [P in keyof T & keyof AggregateAdvertisingSettlement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdvertisingSettlement[P]>
      : GetScalarType<T[P], AggregateAdvertisingSettlement[P]>
  }




  export type AdvertisingSettlementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdvertisingSettlementWhereInput
    orderBy?: AdvertisingSettlementOrderByWithAggregationInput | AdvertisingSettlementOrderByWithAggregationInput[]
    by: AdvertisingSettlementScalarFieldEnum[] | AdvertisingSettlementScalarFieldEnum
    having?: AdvertisingSettlementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdvertisingSettlementCountAggregateInputType | true
    _avg?: AdvertisingSettlementAvgAggregateInputType
    _sum?: AdvertisingSettlementSumAggregateInputType
    _min?: AdvertisingSettlementMinAggregateInputType
    _max?: AdvertisingSettlementMaxAggregateInputType
  }

  export type AdvertisingSettlementGroupByOutputType = {
    order_id: string
    type: string | null
    order_created_time: Date
    order_settled_time: Date
    settlement_amount: number
    settlement_period: string | null
    account_name: string | null
    marketplace: string | null
    currency: string | null
    import_batch_id: string | null
    created_at: Date
    updated_at: Date
    _count: AdvertisingSettlementCountAggregateOutputType | null
    _avg: AdvertisingSettlementAvgAggregateOutputType | null
    _sum: AdvertisingSettlementSumAggregateOutputType | null
    _min: AdvertisingSettlementMinAggregateOutputType | null
    _max: AdvertisingSettlementMaxAggregateOutputType | null
  }

  type GetAdvertisingSettlementGroupByPayload<T extends AdvertisingSettlementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdvertisingSettlementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdvertisingSettlementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdvertisingSettlementGroupByOutputType[P]>
            : GetScalarType<T[P], AdvertisingSettlementGroupByOutputType[P]>
        }
      >
    >


  export type AdvertisingSettlementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    order_id?: boolean
    type?: boolean
    order_created_time?: boolean
    order_settled_time?: boolean
    settlement_amount?: boolean
    settlement_period?: boolean
    account_name?: boolean
    marketplace?: boolean
    currency?: boolean
    import_batch_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    import_batch?: boolean | AdvertisingSettlement$import_batchArgs<ExtArgs>
  }, ExtArgs["result"]["advertisingSettlement"]>

  export type AdvertisingSettlementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    order_id?: boolean
    type?: boolean
    order_created_time?: boolean
    order_settled_time?: boolean
    settlement_amount?: boolean
    settlement_period?: boolean
    account_name?: boolean
    marketplace?: boolean
    currency?: boolean
    import_batch_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    import_batch?: boolean | AdvertisingSettlement$import_batchArgs<ExtArgs>
  }, ExtArgs["result"]["advertisingSettlement"]>

  export type AdvertisingSettlementSelectScalar = {
    order_id?: boolean
    type?: boolean
    order_created_time?: boolean
    order_settled_time?: boolean
    settlement_amount?: boolean
    settlement_period?: boolean
    account_name?: boolean
    marketplace?: boolean
    currency?: boolean
    import_batch_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type AdvertisingSettlementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    import_batch?: boolean | AdvertisingSettlement$import_batchArgs<ExtArgs>
  }
  export type AdvertisingSettlementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    import_batch?: boolean | AdvertisingSettlement$import_batchArgs<ExtArgs>
  }

  export type $AdvertisingSettlementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdvertisingSettlement"
    objects: {
      import_batch: Prisma.$ImportBatchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      order_id: string
      type: string | null
      order_created_time: Date
      order_settled_time: Date
      settlement_amount: number
      settlement_period: string | null
      account_name: string | null
      marketplace: string | null
      currency: string | null
      import_batch_id: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["advertisingSettlement"]>
    composites: {}
  }

  type AdvertisingSettlementGetPayload<S extends boolean | null | undefined | AdvertisingSettlementDefaultArgs> = $Result.GetResult<Prisma.$AdvertisingSettlementPayload, S>

  type AdvertisingSettlementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdvertisingSettlementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdvertisingSettlementCountAggregateInputType | true
    }

  export interface AdvertisingSettlementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdvertisingSettlement'], meta: { name: 'AdvertisingSettlement' } }
    /**
     * Find zero or one AdvertisingSettlement that matches the filter.
     * @param {AdvertisingSettlementFindUniqueArgs} args - Arguments to find a AdvertisingSettlement
     * @example
     * // Get one AdvertisingSettlement
     * const advertisingSettlement = await prisma.advertisingSettlement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdvertisingSettlementFindUniqueArgs>(args: SelectSubset<T, AdvertisingSettlementFindUniqueArgs<ExtArgs>>): Prisma__AdvertisingSettlementClient<$Result.GetResult<Prisma.$AdvertisingSettlementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdvertisingSettlement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdvertisingSettlementFindUniqueOrThrowArgs} args - Arguments to find a AdvertisingSettlement
     * @example
     * // Get one AdvertisingSettlement
     * const advertisingSettlement = await prisma.advertisingSettlement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdvertisingSettlementFindUniqueOrThrowArgs>(args: SelectSubset<T, AdvertisingSettlementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdvertisingSettlementClient<$Result.GetResult<Prisma.$AdvertisingSettlementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdvertisingSettlement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisingSettlementFindFirstArgs} args - Arguments to find a AdvertisingSettlement
     * @example
     * // Get one AdvertisingSettlement
     * const advertisingSettlement = await prisma.advertisingSettlement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdvertisingSettlementFindFirstArgs>(args?: SelectSubset<T, AdvertisingSettlementFindFirstArgs<ExtArgs>>): Prisma__AdvertisingSettlementClient<$Result.GetResult<Prisma.$AdvertisingSettlementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdvertisingSettlement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisingSettlementFindFirstOrThrowArgs} args - Arguments to find a AdvertisingSettlement
     * @example
     * // Get one AdvertisingSettlement
     * const advertisingSettlement = await prisma.advertisingSettlement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdvertisingSettlementFindFirstOrThrowArgs>(args?: SelectSubset<T, AdvertisingSettlementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdvertisingSettlementClient<$Result.GetResult<Prisma.$AdvertisingSettlementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdvertisingSettlements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisingSettlementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdvertisingSettlements
     * const advertisingSettlements = await prisma.advertisingSettlement.findMany()
     * 
     * // Get first 10 AdvertisingSettlements
     * const advertisingSettlements = await prisma.advertisingSettlement.findMany({ take: 10 })
     * 
     * // Only select the `order_id`
     * const advertisingSettlementWithOrder_idOnly = await prisma.advertisingSettlement.findMany({ select: { order_id: true } })
     * 
     */
    findMany<T extends AdvertisingSettlementFindManyArgs>(args?: SelectSubset<T, AdvertisingSettlementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvertisingSettlementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdvertisingSettlement.
     * @param {AdvertisingSettlementCreateArgs} args - Arguments to create a AdvertisingSettlement.
     * @example
     * // Create one AdvertisingSettlement
     * const AdvertisingSettlement = await prisma.advertisingSettlement.create({
     *   data: {
     *     // ... data to create a AdvertisingSettlement
     *   }
     * })
     * 
     */
    create<T extends AdvertisingSettlementCreateArgs>(args: SelectSubset<T, AdvertisingSettlementCreateArgs<ExtArgs>>): Prisma__AdvertisingSettlementClient<$Result.GetResult<Prisma.$AdvertisingSettlementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdvertisingSettlements.
     * @param {AdvertisingSettlementCreateManyArgs} args - Arguments to create many AdvertisingSettlements.
     * @example
     * // Create many AdvertisingSettlements
     * const advertisingSettlement = await prisma.advertisingSettlement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdvertisingSettlementCreateManyArgs>(args?: SelectSubset<T, AdvertisingSettlementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdvertisingSettlements and returns the data saved in the database.
     * @param {AdvertisingSettlementCreateManyAndReturnArgs} args - Arguments to create many AdvertisingSettlements.
     * @example
     * // Create many AdvertisingSettlements
     * const advertisingSettlement = await prisma.advertisingSettlement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdvertisingSettlements and only return the `order_id`
     * const advertisingSettlementWithOrder_idOnly = await prisma.advertisingSettlement.createManyAndReturn({ 
     *   select: { order_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdvertisingSettlementCreateManyAndReturnArgs>(args?: SelectSubset<T, AdvertisingSettlementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvertisingSettlementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdvertisingSettlement.
     * @param {AdvertisingSettlementDeleteArgs} args - Arguments to delete one AdvertisingSettlement.
     * @example
     * // Delete one AdvertisingSettlement
     * const AdvertisingSettlement = await prisma.advertisingSettlement.delete({
     *   where: {
     *     // ... filter to delete one AdvertisingSettlement
     *   }
     * })
     * 
     */
    delete<T extends AdvertisingSettlementDeleteArgs>(args: SelectSubset<T, AdvertisingSettlementDeleteArgs<ExtArgs>>): Prisma__AdvertisingSettlementClient<$Result.GetResult<Prisma.$AdvertisingSettlementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdvertisingSettlement.
     * @param {AdvertisingSettlementUpdateArgs} args - Arguments to update one AdvertisingSettlement.
     * @example
     * // Update one AdvertisingSettlement
     * const advertisingSettlement = await prisma.advertisingSettlement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdvertisingSettlementUpdateArgs>(args: SelectSubset<T, AdvertisingSettlementUpdateArgs<ExtArgs>>): Prisma__AdvertisingSettlementClient<$Result.GetResult<Prisma.$AdvertisingSettlementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdvertisingSettlements.
     * @param {AdvertisingSettlementDeleteManyArgs} args - Arguments to filter AdvertisingSettlements to delete.
     * @example
     * // Delete a few AdvertisingSettlements
     * const { count } = await prisma.advertisingSettlement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdvertisingSettlementDeleteManyArgs>(args?: SelectSubset<T, AdvertisingSettlementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdvertisingSettlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisingSettlementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdvertisingSettlements
     * const advertisingSettlement = await prisma.advertisingSettlement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdvertisingSettlementUpdateManyArgs>(args: SelectSubset<T, AdvertisingSettlementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdvertisingSettlement.
     * @param {AdvertisingSettlementUpsertArgs} args - Arguments to update or create a AdvertisingSettlement.
     * @example
     * // Update or create a AdvertisingSettlement
     * const advertisingSettlement = await prisma.advertisingSettlement.upsert({
     *   create: {
     *     // ... data to create a AdvertisingSettlement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdvertisingSettlement we want to update
     *   }
     * })
     */
    upsert<T extends AdvertisingSettlementUpsertArgs>(args: SelectSubset<T, AdvertisingSettlementUpsertArgs<ExtArgs>>): Prisma__AdvertisingSettlementClient<$Result.GetResult<Prisma.$AdvertisingSettlementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdvertisingSettlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisingSettlementCountArgs} args - Arguments to filter AdvertisingSettlements to count.
     * @example
     * // Count the number of AdvertisingSettlements
     * const count = await prisma.advertisingSettlement.count({
     *   where: {
     *     // ... the filter for the AdvertisingSettlements we want to count
     *   }
     * })
    **/
    count<T extends AdvertisingSettlementCountArgs>(
      args?: Subset<T, AdvertisingSettlementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdvertisingSettlementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdvertisingSettlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisingSettlementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdvertisingSettlementAggregateArgs>(args: Subset<T, AdvertisingSettlementAggregateArgs>): Prisma.PrismaPromise<GetAdvertisingSettlementAggregateType<T>>

    /**
     * Group by AdvertisingSettlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisingSettlementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdvertisingSettlementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdvertisingSettlementGroupByArgs['orderBy'] }
        : { orderBy?: AdvertisingSettlementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdvertisingSettlementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdvertisingSettlementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdvertisingSettlement model
   */
  readonly fields: AdvertisingSettlementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdvertisingSettlement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdvertisingSettlementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    import_batch<T extends AdvertisingSettlement$import_batchArgs<ExtArgs> = {}>(args?: Subset<T, AdvertisingSettlement$import_batchArgs<ExtArgs>>): Prisma__ImportBatchClient<$Result.GetResult<Prisma.$ImportBatchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdvertisingSettlement model
   */ 
  interface AdvertisingSettlementFieldRefs {
    readonly order_id: FieldRef<"AdvertisingSettlement", 'String'>
    readonly type: FieldRef<"AdvertisingSettlement", 'String'>
    readonly order_created_time: FieldRef<"AdvertisingSettlement", 'DateTime'>
    readonly order_settled_time: FieldRef<"AdvertisingSettlement", 'DateTime'>
    readonly settlement_amount: FieldRef<"AdvertisingSettlement", 'Float'>
    readonly settlement_period: FieldRef<"AdvertisingSettlement", 'String'>
    readonly account_name: FieldRef<"AdvertisingSettlement", 'String'>
    readonly marketplace: FieldRef<"AdvertisingSettlement", 'String'>
    readonly currency: FieldRef<"AdvertisingSettlement", 'String'>
    readonly import_batch_id: FieldRef<"AdvertisingSettlement", 'String'>
    readonly created_at: FieldRef<"AdvertisingSettlement", 'DateTime'>
    readonly updated_at: FieldRef<"AdvertisingSettlement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdvertisingSettlement findUnique
   */
  export type AdvertisingSettlementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvertisingSettlement
     */
    select?: AdvertisingSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisingSettlementInclude<ExtArgs> | null
    /**
     * Filter, which AdvertisingSettlement to fetch.
     */
    where: AdvertisingSettlementWhereUniqueInput
  }

  /**
   * AdvertisingSettlement findUniqueOrThrow
   */
  export type AdvertisingSettlementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvertisingSettlement
     */
    select?: AdvertisingSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisingSettlementInclude<ExtArgs> | null
    /**
     * Filter, which AdvertisingSettlement to fetch.
     */
    where: AdvertisingSettlementWhereUniqueInput
  }

  /**
   * AdvertisingSettlement findFirst
   */
  export type AdvertisingSettlementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvertisingSettlement
     */
    select?: AdvertisingSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisingSettlementInclude<ExtArgs> | null
    /**
     * Filter, which AdvertisingSettlement to fetch.
     */
    where?: AdvertisingSettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdvertisingSettlements to fetch.
     */
    orderBy?: AdvertisingSettlementOrderByWithRelationInput | AdvertisingSettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdvertisingSettlements.
     */
    cursor?: AdvertisingSettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdvertisingSettlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdvertisingSettlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdvertisingSettlements.
     */
    distinct?: AdvertisingSettlementScalarFieldEnum | AdvertisingSettlementScalarFieldEnum[]
  }

  /**
   * AdvertisingSettlement findFirstOrThrow
   */
  export type AdvertisingSettlementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvertisingSettlement
     */
    select?: AdvertisingSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisingSettlementInclude<ExtArgs> | null
    /**
     * Filter, which AdvertisingSettlement to fetch.
     */
    where?: AdvertisingSettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdvertisingSettlements to fetch.
     */
    orderBy?: AdvertisingSettlementOrderByWithRelationInput | AdvertisingSettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdvertisingSettlements.
     */
    cursor?: AdvertisingSettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdvertisingSettlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdvertisingSettlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdvertisingSettlements.
     */
    distinct?: AdvertisingSettlementScalarFieldEnum | AdvertisingSettlementScalarFieldEnum[]
  }

  /**
   * AdvertisingSettlement findMany
   */
  export type AdvertisingSettlementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvertisingSettlement
     */
    select?: AdvertisingSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisingSettlementInclude<ExtArgs> | null
    /**
     * Filter, which AdvertisingSettlements to fetch.
     */
    where?: AdvertisingSettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdvertisingSettlements to fetch.
     */
    orderBy?: AdvertisingSettlementOrderByWithRelationInput | AdvertisingSettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdvertisingSettlements.
     */
    cursor?: AdvertisingSettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdvertisingSettlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdvertisingSettlements.
     */
    skip?: number
    distinct?: AdvertisingSettlementScalarFieldEnum | AdvertisingSettlementScalarFieldEnum[]
  }

  /**
   * AdvertisingSettlement create
   */
  export type AdvertisingSettlementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvertisingSettlement
     */
    select?: AdvertisingSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisingSettlementInclude<ExtArgs> | null
    /**
     * The data needed to create a AdvertisingSettlement.
     */
    data: XOR<AdvertisingSettlementCreateInput, AdvertisingSettlementUncheckedCreateInput>
  }

  /**
   * AdvertisingSettlement createMany
   */
  export type AdvertisingSettlementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdvertisingSettlements.
     */
    data: AdvertisingSettlementCreateManyInput | AdvertisingSettlementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdvertisingSettlement createManyAndReturn
   */
  export type AdvertisingSettlementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvertisingSettlement
     */
    select?: AdvertisingSettlementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdvertisingSettlements.
     */
    data: AdvertisingSettlementCreateManyInput | AdvertisingSettlementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisingSettlementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdvertisingSettlement update
   */
  export type AdvertisingSettlementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvertisingSettlement
     */
    select?: AdvertisingSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisingSettlementInclude<ExtArgs> | null
    /**
     * The data needed to update a AdvertisingSettlement.
     */
    data: XOR<AdvertisingSettlementUpdateInput, AdvertisingSettlementUncheckedUpdateInput>
    /**
     * Choose, which AdvertisingSettlement to update.
     */
    where: AdvertisingSettlementWhereUniqueInput
  }

  /**
   * AdvertisingSettlement updateMany
   */
  export type AdvertisingSettlementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdvertisingSettlements.
     */
    data: XOR<AdvertisingSettlementUpdateManyMutationInput, AdvertisingSettlementUncheckedUpdateManyInput>
    /**
     * Filter which AdvertisingSettlements to update
     */
    where?: AdvertisingSettlementWhereInput
  }

  /**
   * AdvertisingSettlement upsert
   */
  export type AdvertisingSettlementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvertisingSettlement
     */
    select?: AdvertisingSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisingSettlementInclude<ExtArgs> | null
    /**
     * The filter to search for the AdvertisingSettlement to update in case it exists.
     */
    where: AdvertisingSettlementWhereUniqueInput
    /**
     * In case the AdvertisingSettlement found by the `where` argument doesn't exist, create a new AdvertisingSettlement with this data.
     */
    create: XOR<AdvertisingSettlementCreateInput, AdvertisingSettlementUncheckedCreateInput>
    /**
     * In case the AdvertisingSettlement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdvertisingSettlementUpdateInput, AdvertisingSettlementUncheckedUpdateInput>
  }

  /**
   * AdvertisingSettlement delete
   */
  export type AdvertisingSettlementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvertisingSettlement
     */
    select?: AdvertisingSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisingSettlementInclude<ExtArgs> | null
    /**
     * Filter which AdvertisingSettlement to delete.
     */
    where: AdvertisingSettlementWhereUniqueInput
  }

  /**
   * AdvertisingSettlement deleteMany
   */
  export type AdvertisingSettlementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdvertisingSettlements to delete
     */
    where?: AdvertisingSettlementWhereInput
  }

  /**
   * AdvertisingSettlement.import_batch
   */
  export type AdvertisingSettlement$import_batchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportBatch
     */
    select?: ImportBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportBatchInclude<ExtArgs> | null
    where?: ImportBatchWhereInput
  }

  /**
   * AdvertisingSettlement without action
   */
  export type AdvertisingSettlementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvertisingSettlement
     */
    select?: AdvertisingSettlementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdvertisingSettlementInclude<ExtArgs> | null
  }


  /**
   * Model ReturnsAndCancellations
   */

  export type AggregateReturnsAndCancellations = {
    _count: ReturnsAndCancellationsCountAggregateOutputType | null
    _avg: ReturnsAndCancellationsAvgAggregateOutputType | null
    _sum: ReturnsAndCancellationsSumAggregateOutputType | null
    _min: ReturnsAndCancellationsMinAggregateOutputType | null
    _max: ReturnsAndCancellationsMaxAggregateOutputType | null
  }

  export type ReturnsAndCancellationsAvgAggregateOutputType = {
    returned_amount: number | null
    refund_amount: number | null
    restocking_fee: number | null
    shipping_cost_loss: number | null
    quantity_returned: number | null
    original_price: number | null
  }

  export type ReturnsAndCancellationsSumAggregateOutputType = {
    returned_amount: number | null
    refund_amount: number | null
    restocking_fee: number | null
    shipping_cost_loss: number | null
    quantity_returned: number | null
    original_price: number | null
  }

  export type ReturnsAndCancellationsMinAggregateOutputType = {
    id: string | null
    original_order_id: string | null
    original_sales_id: string | null
    type: string | null
    reason: string | null
    return_date: Date | null
    returned_amount: number | null
    refund_amount: number | null
    restocking_fee: number | null
    shipping_cost_loss: number | null
    product_name: string | null
    quantity_returned: number | null
    original_price: number | null
    marketplace: string | null
    product_condition: string | null
    resellable: boolean | null
    import_batch_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ReturnsAndCancellationsMaxAggregateOutputType = {
    id: string | null
    original_order_id: string | null
    original_sales_id: string | null
    type: string | null
    reason: string | null
    return_date: Date | null
    returned_amount: number | null
    refund_amount: number | null
    restocking_fee: number | null
    shipping_cost_loss: number | null
    product_name: string | null
    quantity_returned: number | null
    original_price: number | null
    marketplace: string | null
    product_condition: string | null
    resellable: boolean | null
    import_batch_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ReturnsAndCancellationsCountAggregateOutputType = {
    id: number
    original_order_id: number
    original_sales_id: number
    type: number
    reason: number
    return_date: number
    returned_amount: number
    refund_amount: number
    restocking_fee: number
    shipping_cost_loss: number
    product_name: number
    quantity_returned: number
    original_price: number
    marketplace: number
    product_condition: number
    resellable: number
    import_batch_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ReturnsAndCancellationsAvgAggregateInputType = {
    returned_amount?: true
    refund_amount?: true
    restocking_fee?: true
    shipping_cost_loss?: true
    quantity_returned?: true
    original_price?: true
  }

  export type ReturnsAndCancellationsSumAggregateInputType = {
    returned_amount?: true
    refund_amount?: true
    restocking_fee?: true
    shipping_cost_loss?: true
    quantity_returned?: true
    original_price?: true
  }

  export type ReturnsAndCancellationsMinAggregateInputType = {
    id?: true
    original_order_id?: true
    original_sales_id?: true
    type?: true
    reason?: true
    return_date?: true
    returned_amount?: true
    refund_amount?: true
    restocking_fee?: true
    shipping_cost_loss?: true
    product_name?: true
    quantity_returned?: true
    original_price?: true
    marketplace?: true
    product_condition?: true
    resellable?: true
    import_batch_id?: true
    created_at?: true
    updated_at?: true
  }

  export type ReturnsAndCancellationsMaxAggregateInputType = {
    id?: true
    original_order_id?: true
    original_sales_id?: true
    type?: true
    reason?: true
    return_date?: true
    returned_amount?: true
    refund_amount?: true
    restocking_fee?: true
    shipping_cost_loss?: true
    product_name?: true
    quantity_returned?: true
    original_price?: true
    marketplace?: true
    product_condition?: true
    resellable?: true
    import_batch_id?: true
    created_at?: true
    updated_at?: true
  }

  export type ReturnsAndCancellationsCountAggregateInputType = {
    id?: true
    original_order_id?: true
    original_sales_id?: true
    type?: true
    reason?: true
    return_date?: true
    returned_amount?: true
    refund_amount?: true
    restocking_fee?: true
    shipping_cost_loss?: true
    product_name?: true
    quantity_returned?: true
    original_price?: true
    marketplace?: true
    product_condition?: true
    resellable?: true
    import_batch_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ReturnsAndCancellationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReturnsAndCancellations to aggregate.
     */
    where?: ReturnsAndCancellationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnsAndCancellations to fetch.
     */
    orderBy?: ReturnsAndCancellationsOrderByWithRelationInput | ReturnsAndCancellationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReturnsAndCancellationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnsAndCancellations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnsAndCancellations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReturnsAndCancellations
    **/
    _count?: true | ReturnsAndCancellationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReturnsAndCancellationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReturnsAndCancellationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReturnsAndCancellationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReturnsAndCancellationsMaxAggregateInputType
  }

  export type GetReturnsAndCancellationsAggregateType<T extends ReturnsAndCancellationsAggregateArgs> = {
        [P in keyof T & keyof AggregateReturnsAndCancellations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReturnsAndCancellations[P]>
      : GetScalarType<T[P], AggregateReturnsAndCancellations[P]>
  }




  export type ReturnsAndCancellationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReturnsAndCancellationsWhereInput
    orderBy?: ReturnsAndCancellationsOrderByWithAggregationInput | ReturnsAndCancellationsOrderByWithAggregationInput[]
    by: ReturnsAndCancellationsScalarFieldEnum[] | ReturnsAndCancellationsScalarFieldEnum
    having?: ReturnsAndCancellationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReturnsAndCancellationsCountAggregateInputType | true
    _avg?: ReturnsAndCancellationsAvgAggregateInputType
    _sum?: ReturnsAndCancellationsSumAggregateInputType
    _min?: ReturnsAndCancellationsMinAggregateInputType
    _max?: ReturnsAndCancellationsMaxAggregateInputType
  }

  export type ReturnsAndCancellationsGroupByOutputType = {
    id: string
    original_order_id: string | null
    original_sales_id: string | null
    type: string
    reason: string | null
    return_date: Date
    returned_amount: number
    refund_amount: number
    restocking_fee: number
    shipping_cost_loss: number
    product_name: string
    quantity_returned: number
    original_price: number
    marketplace: string | null
    product_condition: string | null
    resellable: boolean
    import_batch_id: string | null
    created_at: Date
    updated_at: Date
    _count: ReturnsAndCancellationsCountAggregateOutputType | null
    _avg: ReturnsAndCancellationsAvgAggregateOutputType | null
    _sum: ReturnsAndCancellationsSumAggregateOutputType | null
    _min: ReturnsAndCancellationsMinAggregateOutputType | null
    _max: ReturnsAndCancellationsMaxAggregateOutputType | null
  }

  type GetReturnsAndCancellationsGroupByPayload<T extends ReturnsAndCancellationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReturnsAndCancellationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReturnsAndCancellationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReturnsAndCancellationsGroupByOutputType[P]>
            : GetScalarType<T[P], ReturnsAndCancellationsGroupByOutputType[P]>
        }
      >
    >


  export type ReturnsAndCancellationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    original_order_id?: boolean
    original_sales_id?: boolean
    type?: boolean
    reason?: boolean
    return_date?: boolean
    returned_amount?: boolean
    refund_amount?: boolean
    restocking_fee?: boolean
    shipping_cost_loss?: boolean
    product_name?: boolean
    quantity_returned?: boolean
    original_price?: boolean
    marketplace?: boolean
    product_condition?: boolean
    resellable?: boolean
    import_batch_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    import_batch?: boolean | ReturnsAndCancellations$import_batchArgs<ExtArgs>
  }, ExtArgs["result"]["returnsAndCancellations"]>

  export type ReturnsAndCancellationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    original_order_id?: boolean
    original_sales_id?: boolean
    type?: boolean
    reason?: boolean
    return_date?: boolean
    returned_amount?: boolean
    refund_amount?: boolean
    restocking_fee?: boolean
    shipping_cost_loss?: boolean
    product_name?: boolean
    quantity_returned?: boolean
    original_price?: boolean
    marketplace?: boolean
    product_condition?: boolean
    resellable?: boolean
    import_batch_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    import_batch?: boolean | ReturnsAndCancellations$import_batchArgs<ExtArgs>
  }, ExtArgs["result"]["returnsAndCancellations"]>

  export type ReturnsAndCancellationsSelectScalar = {
    id?: boolean
    original_order_id?: boolean
    original_sales_id?: boolean
    type?: boolean
    reason?: boolean
    return_date?: boolean
    returned_amount?: boolean
    refund_amount?: boolean
    restocking_fee?: boolean
    shipping_cost_loss?: boolean
    product_name?: boolean
    quantity_returned?: boolean
    original_price?: boolean
    marketplace?: boolean
    product_condition?: boolean
    resellable?: boolean
    import_batch_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ReturnsAndCancellationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    import_batch?: boolean | ReturnsAndCancellations$import_batchArgs<ExtArgs>
  }
  export type ReturnsAndCancellationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    import_batch?: boolean | ReturnsAndCancellations$import_batchArgs<ExtArgs>
  }

  export type $ReturnsAndCancellationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReturnsAndCancellations"
    objects: {
      import_batch: Prisma.$ImportBatchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      original_order_id: string | null
      original_sales_id: string | null
      type: string
      reason: string | null
      return_date: Date
      returned_amount: number
      refund_amount: number
      restocking_fee: number
      shipping_cost_loss: number
      product_name: string
      quantity_returned: number
      original_price: number
      marketplace: string | null
      product_condition: string | null
      resellable: boolean
      import_batch_id: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["returnsAndCancellations"]>
    composites: {}
  }

  type ReturnsAndCancellationsGetPayload<S extends boolean | null | undefined | ReturnsAndCancellationsDefaultArgs> = $Result.GetResult<Prisma.$ReturnsAndCancellationsPayload, S>

  type ReturnsAndCancellationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReturnsAndCancellationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReturnsAndCancellationsCountAggregateInputType | true
    }

  export interface ReturnsAndCancellationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReturnsAndCancellations'], meta: { name: 'ReturnsAndCancellations' } }
    /**
     * Find zero or one ReturnsAndCancellations that matches the filter.
     * @param {ReturnsAndCancellationsFindUniqueArgs} args - Arguments to find a ReturnsAndCancellations
     * @example
     * // Get one ReturnsAndCancellations
     * const returnsAndCancellations = await prisma.returnsAndCancellations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReturnsAndCancellationsFindUniqueArgs>(args: SelectSubset<T, ReturnsAndCancellationsFindUniqueArgs<ExtArgs>>): Prisma__ReturnsAndCancellationsClient<$Result.GetResult<Prisma.$ReturnsAndCancellationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReturnsAndCancellations that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReturnsAndCancellationsFindUniqueOrThrowArgs} args - Arguments to find a ReturnsAndCancellations
     * @example
     * // Get one ReturnsAndCancellations
     * const returnsAndCancellations = await prisma.returnsAndCancellations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReturnsAndCancellationsFindUniqueOrThrowArgs>(args: SelectSubset<T, ReturnsAndCancellationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReturnsAndCancellationsClient<$Result.GetResult<Prisma.$ReturnsAndCancellationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReturnsAndCancellations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnsAndCancellationsFindFirstArgs} args - Arguments to find a ReturnsAndCancellations
     * @example
     * // Get one ReturnsAndCancellations
     * const returnsAndCancellations = await prisma.returnsAndCancellations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReturnsAndCancellationsFindFirstArgs>(args?: SelectSubset<T, ReturnsAndCancellationsFindFirstArgs<ExtArgs>>): Prisma__ReturnsAndCancellationsClient<$Result.GetResult<Prisma.$ReturnsAndCancellationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReturnsAndCancellations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnsAndCancellationsFindFirstOrThrowArgs} args - Arguments to find a ReturnsAndCancellations
     * @example
     * // Get one ReturnsAndCancellations
     * const returnsAndCancellations = await prisma.returnsAndCancellations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReturnsAndCancellationsFindFirstOrThrowArgs>(args?: SelectSubset<T, ReturnsAndCancellationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReturnsAndCancellationsClient<$Result.GetResult<Prisma.$ReturnsAndCancellationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReturnsAndCancellations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnsAndCancellationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReturnsAndCancellations
     * const returnsAndCancellations = await prisma.returnsAndCancellations.findMany()
     * 
     * // Get first 10 ReturnsAndCancellations
     * const returnsAndCancellations = await prisma.returnsAndCancellations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const returnsAndCancellationsWithIdOnly = await prisma.returnsAndCancellations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReturnsAndCancellationsFindManyArgs>(args?: SelectSubset<T, ReturnsAndCancellationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnsAndCancellationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReturnsAndCancellations.
     * @param {ReturnsAndCancellationsCreateArgs} args - Arguments to create a ReturnsAndCancellations.
     * @example
     * // Create one ReturnsAndCancellations
     * const ReturnsAndCancellations = await prisma.returnsAndCancellations.create({
     *   data: {
     *     // ... data to create a ReturnsAndCancellations
     *   }
     * })
     * 
     */
    create<T extends ReturnsAndCancellationsCreateArgs>(args: SelectSubset<T, ReturnsAndCancellationsCreateArgs<ExtArgs>>): Prisma__ReturnsAndCancellationsClient<$Result.GetResult<Prisma.$ReturnsAndCancellationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReturnsAndCancellations.
     * @param {ReturnsAndCancellationsCreateManyArgs} args - Arguments to create many ReturnsAndCancellations.
     * @example
     * // Create many ReturnsAndCancellations
     * const returnsAndCancellations = await prisma.returnsAndCancellations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReturnsAndCancellationsCreateManyArgs>(args?: SelectSubset<T, ReturnsAndCancellationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReturnsAndCancellations and returns the data saved in the database.
     * @param {ReturnsAndCancellationsCreateManyAndReturnArgs} args - Arguments to create many ReturnsAndCancellations.
     * @example
     * // Create many ReturnsAndCancellations
     * const returnsAndCancellations = await prisma.returnsAndCancellations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReturnsAndCancellations and only return the `id`
     * const returnsAndCancellationsWithIdOnly = await prisma.returnsAndCancellations.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReturnsAndCancellationsCreateManyAndReturnArgs>(args?: SelectSubset<T, ReturnsAndCancellationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnsAndCancellationsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReturnsAndCancellations.
     * @param {ReturnsAndCancellationsDeleteArgs} args - Arguments to delete one ReturnsAndCancellations.
     * @example
     * // Delete one ReturnsAndCancellations
     * const ReturnsAndCancellations = await prisma.returnsAndCancellations.delete({
     *   where: {
     *     // ... filter to delete one ReturnsAndCancellations
     *   }
     * })
     * 
     */
    delete<T extends ReturnsAndCancellationsDeleteArgs>(args: SelectSubset<T, ReturnsAndCancellationsDeleteArgs<ExtArgs>>): Prisma__ReturnsAndCancellationsClient<$Result.GetResult<Prisma.$ReturnsAndCancellationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReturnsAndCancellations.
     * @param {ReturnsAndCancellationsUpdateArgs} args - Arguments to update one ReturnsAndCancellations.
     * @example
     * // Update one ReturnsAndCancellations
     * const returnsAndCancellations = await prisma.returnsAndCancellations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReturnsAndCancellationsUpdateArgs>(args: SelectSubset<T, ReturnsAndCancellationsUpdateArgs<ExtArgs>>): Prisma__ReturnsAndCancellationsClient<$Result.GetResult<Prisma.$ReturnsAndCancellationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReturnsAndCancellations.
     * @param {ReturnsAndCancellationsDeleteManyArgs} args - Arguments to filter ReturnsAndCancellations to delete.
     * @example
     * // Delete a few ReturnsAndCancellations
     * const { count } = await prisma.returnsAndCancellations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReturnsAndCancellationsDeleteManyArgs>(args?: SelectSubset<T, ReturnsAndCancellationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReturnsAndCancellations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnsAndCancellationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReturnsAndCancellations
     * const returnsAndCancellations = await prisma.returnsAndCancellations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReturnsAndCancellationsUpdateManyArgs>(args: SelectSubset<T, ReturnsAndCancellationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReturnsAndCancellations.
     * @param {ReturnsAndCancellationsUpsertArgs} args - Arguments to update or create a ReturnsAndCancellations.
     * @example
     * // Update or create a ReturnsAndCancellations
     * const returnsAndCancellations = await prisma.returnsAndCancellations.upsert({
     *   create: {
     *     // ... data to create a ReturnsAndCancellations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReturnsAndCancellations we want to update
     *   }
     * })
     */
    upsert<T extends ReturnsAndCancellationsUpsertArgs>(args: SelectSubset<T, ReturnsAndCancellationsUpsertArgs<ExtArgs>>): Prisma__ReturnsAndCancellationsClient<$Result.GetResult<Prisma.$ReturnsAndCancellationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReturnsAndCancellations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnsAndCancellationsCountArgs} args - Arguments to filter ReturnsAndCancellations to count.
     * @example
     * // Count the number of ReturnsAndCancellations
     * const count = await prisma.returnsAndCancellations.count({
     *   where: {
     *     // ... the filter for the ReturnsAndCancellations we want to count
     *   }
     * })
    **/
    count<T extends ReturnsAndCancellationsCountArgs>(
      args?: Subset<T, ReturnsAndCancellationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReturnsAndCancellationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReturnsAndCancellations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnsAndCancellationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReturnsAndCancellationsAggregateArgs>(args: Subset<T, ReturnsAndCancellationsAggregateArgs>): Prisma.PrismaPromise<GetReturnsAndCancellationsAggregateType<T>>

    /**
     * Group by ReturnsAndCancellations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnsAndCancellationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReturnsAndCancellationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReturnsAndCancellationsGroupByArgs['orderBy'] }
        : { orderBy?: ReturnsAndCancellationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReturnsAndCancellationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReturnsAndCancellationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReturnsAndCancellations model
   */
  readonly fields: ReturnsAndCancellationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReturnsAndCancellations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReturnsAndCancellationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    import_batch<T extends ReturnsAndCancellations$import_batchArgs<ExtArgs> = {}>(args?: Subset<T, ReturnsAndCancellations$import_batchArgs<ExtArgs>>): Prisma__ImportBatchClient<$Result.GetResult<Prisma.$ImportBatchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReturnsAndCancellations model
   */ 
  interface ReturnsAndCancellationsFieldRefs {
    readonly id: FieldRef<"ReturnsAndCancellations", 'String'>
    readonly original_order_id: FieldRef<"ReturnsAndCancellations", 'String'>
    readonly original_sales_id: FieldRef<"ReturnsAndCancellations", 'String'>
    readonly type: FieldRef<"ReturnsAndCancellations", 'String'>
    readonly reason: FieldRef<"ReturnsAndCancellations", 'String'>
    readonly return_date: FieldRef<"ReturnsAndCancellations", 'DateTime'>
    readonly returned_amount: FieldRef<"ReturnsAndCancellations", 'Float'>
    readonly refund_amount: FieldRef<"ReturnsAndCancellations", 'Float'>
    readonly restocking_fee: FieldRef<"ReturnsAndCancellations", 'Float'>
    readonly shipping_cost_loss: FieldRef<"ReturnsAndCancellations", 'Float'>
    readonly product_name: FieldRef<"ReturnsAndCancellations", 'String'>
    readonly quantity_returned: FieldRef<"ReturnsAndCancellations", 'Int'>
    readonly original_price: FieldRef<"ReturnsAndCancellations", 'Float'>
    readonly marketplace: FieldRef<"ReturnsAndCancellations", 'String'>
    readonly product_condition: FieldRef<"ReturnsAndCancellations", 'String'>
    readonly resellable: FieldRef<"ReturnsAndCancellations", 'Boolean'>
    readonly import_batch_id: FieldRef<"ReturnsAndCancellations", 'String'>
    readonly created_at: FieldRef<"ReturnsAndCancellations", 'DateTime'>
    readonly updated_at: FieldRef<"ReturnsAndCancellations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReturnsAndCancellations findUnique
   */
  export type ReturnsAndCancellationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnsAndCancellations
     */
    select?: ReturnsAndCancellationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnsAndCancellationsInclude<ExtArgs> | null
    /**
     * Filter, which ReturnsAndCancellations to fetch.
     */
    where: ReturnsAndCancellationsWhereUniqueInput
  }

  /**
   * ReturnsAndCancellations findUniqueOrThrow
   */
  export type ReturnsAndCancellationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnsAndCancellations
     */
    select?: ReturnsAndCancellationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnsAndCancellationsInclude<ExtArgs> | null
    /**
     * Filter, which ReturnsAndCancellations to fetch.
     */
    where: ReturnsAndCancellationsWhereUniqueInput
  }

  /**
   * ReturnsAndCancellations findFirst
   */
  export type ReturnsAndCancellationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnsAndCancellations
     */
    select?: ReturnsAndCancellationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnsAndCancellationsInclude<ExtArgs> | null
    /**
     * Filter, which ReturnsAndCancellations to fetch.
     */
    where?: ReturnsAndCancellationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnsAndCancellations to fetch.
     */
    orderBy?: ReturnsAndCancellationsOrderByWithRelationInput | ReturnsAndCancellationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReturnsAndCancellations.
     */
    cursor?: ReturnsAndCancellationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnsAndCancellations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnsAndCancellations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReturnsAndCancellations.
     */
    distinct?: ReturnsAndCancellationsScalarFieldEnum | ReturnsAndCancellationsScalarFieldEnum[]
  }

  /**
   * ReturnsAndCancellations findFirstOrThrow
   */
  export type ReturnsAndCancellationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnsAndCancellations
     */
    select?: ReturnsAndCancellationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnsAndCancellationsInclude<ExtArgs> | null
    /**
     * Filter, which ReturnsAndCancellations to fetch.
     */
    where?: ReturnsAndCancellationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnsAndCancellations to fetch.
     */
    orderBy?: ReturnsAndCancellationsOrderByWithRelationInput | ReturnsAndCancellationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReturnsAndCancellations.
     */
    cursor?: ReturnsAndCancellationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnsAndCancellations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnsAndCancellations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReturnsAndCancellations.
     */
    distinct?: ReturnsAndCancellationsScalarFieldEnum | ReturnsAndCancellationsScalarFieldEnum[]
  }

  /**
   * ReturnsAndCancellations findMany
   */
  export type ReturnsAndCancellationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnsAndCancellations
     */
    select?: ReturnsAndCancellationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnsAndCancellationsInclude<ExtArgs> | null
    /**
     * Filter, which ReturnsAndCancellations to fetch.
     */
    where?: ReturnsAndCancellationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnsAndCancellations to fetch.
     */
    orderBy?: ReturnsAndCancellationsOrderByWithRelationInput | ReturnsAndCancellationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReturnsAndCancellations.
     */
    cursor?: ReturnsAndCancellationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnsAndCancellations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnsAndCancellations.
     */
    skip?: number
    distinct?: ReturnsAndCancellationsScalarFieldEnum | ReturnsAndCancellationsScalarFieldEnum[]
  }

  /**
   * ReturnsAndCancellations create
   */
  export type ReturnsAndCancellationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnsAndCancellations
     */
    select?: ReturnsAndCancellationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnsAndCancellationsInclude<ExtArgs> | null
    /**
     * The data needed to create a ReturnsAndCancellations.
     */
    data: XOR<ReturnsAndCancellationsCreateInput, ReturnsAndCancellationsUncheckedCreateInput>
  }

  /**
   * ReturnsAndCancellations createMany
   */
  export type ReturnsAndCancellationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReturnsAndCancellations.
     */
    data: ReturnsAndCancellationsCreateManyInput | ReturnsAndCancellationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReturnsAndCancellations createManyAndReturn
   */
  export type ReturnsAndCancellationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnsAndCancellations
     */
    select?: ReturnsAndCancellationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReturnsAndCancellations.
     */
    data: ReturnsAndCancellationsCreateManyInput | ReturnsAndCancellationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnsAndCancellationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReturnsAndCancellations update
   */
  export type ReturnsAndCancellationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnsAndCancellations
     */
    select?: ReturnsAndCancellationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnsAndCancellationsInclude<ExtArgs> | null
    /**
     * The data needed to update a ReturnsAndCancellations.
     */
    data: XOR<ReturnsAndCancellationsUpdateInput, ReturnsAndCancellationsUncheckedUpdateInput>
    /**
     * Choose, which ReturnsAndCancellations to update.
     */
    where: ReturnsAndCancellationsWhereUniqueInput
  }

  /**
   * ReturnsAndCancellations updateMany
   */
  export type ReturnsAndCancellationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReturnsAndCancellations.
     */
    data: XOR<ReturnsAndCancellationsUpdateManyMutationInput, ReturnsAndCancellationsUncheckedUpdateManyInput>
    /**
     * Filter which ReturnsAndCancellations to update
     */
    where?: ReturnsAndCancellationsWhereInput
  }

  /**
   * ReturnsAndCancellations upsert
   */
  export type ReturnsAndCancellationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnsAndCancellations
     */
    select?: ReturnsAndCancellationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnsAndCancellationsInclude<ExtArgs> | null
    /**
     * The filter to search for the ReturnsAndCancellations to update in case it exists.
     */
    where: ReturnsAndCancellationsWhereUniqueInput
    /**
     * In case the ReturnsAndCancellations found by the `where` argument doesn't exist, create a new ReturnsAndCancellations with this data.
     */
    create: XOR<ReturnsAndCancellationsCreateInput, ReturnsAndCancellationsUncheckedCreateInput>
    /**
     * In case the ReturnsAndCancellations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReturnsAndCancellationsUpdateInput, ReturnsAndCancellationsUncheckedUpdateInput>
  }

  /**
   * ReturnsAndCancellations delete
   */
  export type ReturnsAndCancellationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnsAndCancellations
     */
    select?: ReturnsAndCancellationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnsAndCancellationsInclude<ExtArgs> | null
    /**
     * Filter which ReturnsAndCancellations to delete.
     */
    where: ReturnsAndCancellationsWhereUniqueInput
  }

  /**
   * ReturnsAndCancellations deleteMany
   */
  export type ReturnsAndCancellationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReturnsAndCancellations to delete
     */
    where?: ReturnsAndCancellationsWhereInput
  }

  /**
   * ReturnsAndCancellations.import_batch
   */
  export type ReturnsAndCancellations$import_batchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportBatch
     */
    select?: ImportBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportBatchInclude<ExtArgs> | null
    where?: ImportBatchWhereInput
  }

  /**
   * ReturnsAndCancellations without action
   */
  export type ReturnsAndCancellationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnsAndCancellations
     */
    select?: ReturnsAndCancellationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnsAndCancellationsInclude<ExtArgs> | null
  }


  /**
   * Model MarketplaceReimbursement
   */

  export type AggregateMarketplaceReimbursement = {
    _count: MarketplaceReimbursementCountAggregateOutputType | null
    _avg: MarketplaceReimbursementAvgAggregateOutputType | null
    _sum: MarketplaceReimbursementSumAggregateOutputType | null
    _min: MarketplaceReimbursementMinAggregateOutputType | null
    _max: MarketplaceReimbursementMaxAggregateOutputType | null
  }

  export type MarketplaceReimbursementAvgAggregateOutputType = {
    claim_amount: number | null
    approved_amount: number | null
    received_amount: number | null
    processing_fee: number | null
  }

  export type MarketplaceReimbursementSumAggregateOutputType = {
    claim_amount: number | null
    approved_amount: number | null
    received_amount: number | null
    processing_fee: number | null
  }

  export type MarketplaceReimbursementMinAggregateOutputType = {
    id: string | null
    claim_id: string | null
    reimbursement_type: string | null
    claim_amount: number | null
    approved_amount: number | null
    received_amount: number | null
    processing_fee: number | null
    incident_date: Date | null
    claim_date: Date | null
    approval_date: Date | null
    received_date: Date | null
    affected_order_id: string | null
    product_name: string | null
    marketplace: string | null
    status: string | null
    notes: string | null
    evidence_provided: string | null
    import_batch_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MarketplaceReimbursementMaxAggregateOutputType = {
    id: string | null
    claim_id: string | null
    reimbursement_type: string | null
    claim_amount: number | null
    approved_amount: number | null
    received_amount: number | null
    processing_fee: number | null
    incident_date: Date | null
    claim_date: Date | null
    approval_date: Date | null
    received_date: Date | null
    affected_order_id: string | null
    product_name: string | null
    marketplace: string | null
    status: string | null
    notes: string | null
    evidence_provided: string | null
    import_batch_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MarketplaceReimbursementCountAggregateOutputType = {
    id: number
    claim_id: number
    reimbursement_type: number
    claim_amount: number
    approved_amount: number
    received_amount: number
    processing_fee: number
    incident_date: number
    claim_date: number
    approval_date: number
    received_date: number
    affected_order_id: number
    product_name: number
    marketplace: number
    status: number
    notes: number
    evidence_provided: number
    import_batch_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type MarketplaceReimbursementAvgAggregateInputType = {
    claim_amount?: true
    approved_amount?: true
    received_amount?: true
    processing_fee?: true
  }

  export type MarketplaceReimbursementSumAggregateInputType = {
    claim_amount?: true
    approved_amount?: true
    received_amount?: true
    processing_fee?: true
  }

  export type MarketplaceReimbursementMinAggregateInputType = {
    id?: true
    claim_id?: true
    reimbursement_type?: true
    claim_amount?: true
    approved_amount?: true
    received_amount?: true
    processing_fee?: true
    incident_date?: true
    claim_date?: true
    approval_date?: true
    received_date?: true
    affected_order_id?: true
    product_name?: true
    marketplace?: true
    status?: true
    notes?: true
    evidence_provided?: true
    import_batch_id?: true
    created_at?: true
    updated_at?: true
  }

  export type MarketplaceReimbursementMaxAggregateInputType = {
    id?: true
    claim_id?: true
    reimbursement_type?: true
    claim_amount?: true
    approved_amount?: true
    received_amount?: true
    processing_fee?: true
    incident_date?: true
    claim_date?: true
    approval_date?: true
    received_date?: true
    affected_order_id?: true
    product_name?: true
    marketplace?: true
    status?: true
    notes?: true
    evidence_provided?: true
    import_batch_id?: true
    created_at?: true
    updated_at?: true
  }

  export type MarketplaceReimbursementCountAggregateInputType = {
    id?: true
    claim_id?: true
    reimbursement_type?: true
    claim_amount?: true
    approved_amount?: true
    received_amount?: true
    processing_fee?: true
    incident_date?: true
    claim_date?: true
    approval_date?: true
    received_date?: true
    affected_order_id?: true
    product_name?: true
    marketplace?: true
    status?: true
    notes?: true
    evidence_provided?: true
    import_batch_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type MarketplaceReimbursementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketplaceReimbursement to aggregate.
     */
    where?: MarketplaceReimbursementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceReimbursements to fetch.
     */
    orderBy?: MarketplaceReimbursementOrderByWithRelationInput | MarketplaceReimbursementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketplaceReimbursementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceReimbursements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceReimbursements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketplaceReimbursements
    **/
    _count?: true | MarketplaceReimbursementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketplaceReimbursementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketplaceReimbursementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketplaceReimbursementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketplaceReimbursementMaxAggregateInputType
  }

  export type GetMarketplaceReimbursementAggregateType<T extends MarketplaceReimbursementAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketplaceReimbursement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketplaceReimbursement[P]>
      : GetScalarType<T[P], AggregateMarketplaceReimbursement[P]>
  }




  export type MarketplaceReimbursementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketplaceReimbursementWhereInput
    orderBy?: MarketplaceReimbursementOrderByWithAggregationInput | MarketplaceReimbursementOrderByWithAggregationInput[]
    by: MarketplaceReimbursementScalarFieldEnum[] | MarketplaceReimbursementScalarFieldEnum
    having?: MarketplaceReimbursementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketplaceReimbursementCountAggregateInputType | true
    _avg?: MarketplaceReimbursementAvgAggregateInputType
    _sum?: MarketplaceReimbursementSumAggregateInputType
    _min?: MarketplaceReimbursementMinAggregateInputType
    _max?: MarketplaceReimbursementMaxAggregateInputType
  }

  export type MarketplaceReimbursementGroupByOutputType = {
    id: string
    claim_id: string | null
    reimbursement_type: string
    claim_amount: number
    approved_amount: number
    received_amount: number
    processing_fee: number
    incident_date: Date
    claim_date: Date
    approval_date: Date | null
    received_date: Date | null
    affected_order_id: string | null
    product_name: string | null
    marketplace: string
    status: string
    notes: string | null
    evidence_provided: string | null
    import_batch_id: string | null
    created_at: Date
    updated_at: Date
    _count: MarketplaceReimbursementCountAggregateOutputType | null
    _avg: MarketplaceReimbursementAvgAggregateOutputType | null
    _sum: MarketplaceReimbursementSumAggregateOutputType | null
    _min: MarketplaceReimbursementMinAggregateOutputType | null
    _max: MarketplaceReimbursementMaxAggregateOutputType | null
  }

  type GetMarketplaceReimbursementGroupByPayload<T extends MarketplaceReimbursementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketplaceReimbursementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketplaceReimbursementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketplaceReimbursementGroupByOutputType[P]>
            : GetScalarType<T[P], MarketplaceReimbursementGroupByOutputType[P]>
        }
      >
    >


  export type MarketplaceReimbursementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claim_id?: boolean
    reimbursement_type?: boolean
    claim_amount?: boolean
    approved_amount?: boolean
    received_amount?: boolean
    processing_fee?: boolean
    incident_date?: boolean
    claim_date?: boolean
    approval_date?: boolean
    received_date?: boolean
    affected_order_id?: boolean
    product_name?: boolean
    marketplace?: boolean
    status?: boolean
    notes?: boolean
    evidence_provided?: boolean
    import_batch_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    import_batch?: boolean | MarketplaceReimbursement$import_batchArgs<ExtArgs>
  }, ExtArgs["result"]["marketplaceReimbursement"]>

  export type MarketplaceReimbursementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claim_id?: boolean
    reimbursement_type?: boolean
    claim_amount?: boolean
    approved_amount?: boolean
    received_amount?: boolean
    processing_fee?: boolean
    incident_date?: boolean
    claim_date?: boolean
    approval_date?: boolean
    received_date?: boolean
    affected_order_id?: boolean
    product_name?: boolean
    marketplace?: boolean
    status?: boolean
    notes?: boolean
    evidence_provided?: boolean
    import_batch_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    import_batch?: boolean | MarketplaceReimbursement$import_batchArgs<ExtArgs>
  }, ExtArgs["result"]["marketplaceReimbursement"]>

  export type MarketplaceReimbursementSelectScalar = {
    id?: boolean
    claim_id?: boolean
    reimbursement_type?: boolean
    claim_amount?: boolean
    approved_amount?: boolean
    received_amount?: boolean
    processing_fee?: boolean
    incident_date?: boolean
    claim_date?: boolean
    approval_date?: boolean
    received_date?: boolean
    affected_order_id?: boolean
    product_name?: boolean
    marketplace?: boolean
    status?: boolean
    notes?: boolean
    evidence_provided?: boolean
    import_batch_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type MarketplaceReimbursementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    import_batch?: boolean | MarketplaceReimbursement$import_batchArgs<ExtArgs>
  }
  export type MarketplaceReimbursementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    import_batch?: boolean | MarketplaceReimbursement$import_batchArgs<ExtArgs>
  }

  export type $MarketplaceReimbursementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketplaceReimbursement"
    objects: {
      import_batch: Prisma.$ImportBatchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      claim_id: string | null
      reimbursement_type: string
      claim_amount: number
      approved_amount: number
      received_amount: number
      processing_fee: number
      incident_date: Date
      claim_date: Date
      approval_date: Date | null
      received_date: Date | null
      affected_order_id: string | null
      product_name: string | null
      marketplace: string
      status: string
      notes: string | null
      evidence_provided: string | null
      import_batch_id: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["marketplaceReimbursement"]>
    composites: {}
  }

  type MarketplaceReimbursementGetPayload<S extends boolean | null | undefined | MarketplaceReimbursementDefaultArgs> = $Result.GetResult<Prisma.$MarketplaceReimbursementPayload, S>

  type MarketplaceReimbursementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MarketplaceReimbursementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MarketplaceReimbursementCountAggregateInputType | true
    }

  export interface MarketplaceReimbursementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketplaceReimbursement'], meta: { name: 'MarketplaceReimbursement' } }
    /**
     * Find zero or one MarketplaceReimbursement that matches the filter.
     * @param {MarketplaceReimbursementFindUniqueArgs} args - Arguments to find a MarketplaceReimbursement
     * @example
     * // Get one MarketplaceReimbursement
     * const marketplaceReimbursement = await prisma.marketplaceReimbursement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketplaceReimbursementFindUniqueArgs>(args: SelectSubset<T, MarketplaceReimbursementFindUniqueArgs<ExtArgs>>): Prisma__MarketplaceReimbursementClient<$Result.GetResult<Prisma.$MarketplaceReimbursementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MarketplaceReimbursement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MarketplaceReimbursementFindUniqueOrThrowArgs} args - Arguments to find a MarketplaceReimbursement
     * @example
     * // Get one MarketplaceReimbursement
     * const marketplaceReimbursement = await prisma.marketplaceReimbursement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketplaceReimbursementFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketplaceReimbursementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketplaceReimbursementClient<$Result.GetResult<Prisma.$MarketplaceReimbursementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MarketplaceReimbursement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceReimbursementFindFirstArgs} args - Arguments to find a MarketplaceReimbursement
     * @example
     * // Get one MarketplaceReimbursement
     * const marketplaceReimbursement = await prisma.marketplaceReimbursement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketplaceReimbursementFindFirstArgs>(args?: SelectSubset<T, MarketplaceReimbursementFindFirstArgs<ExtArgs>>): Prisma__MarketplaceReimbursementClient<$Result.GetResult<Prisma.$MarketplaceReimbursementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MarketplaceReimbursement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceReimbursementFindFirstOrThrowArgs} args - Arguments to find a MarketplaceReimbursement
     * @example
     * // Get one MarketplaceReimbursement
     * const marketplaceReimbursement = await prisma.marketplaceReimbursement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketplaceReimbursementFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketplaceReimbursementFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketplaceReimbursementClient<$Result.GetResult<Prisma.$MarketplaceReimbursementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MarketplaceReimbursements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceReimbursementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketplaceReimbursements
     * const marketplaceReimbursements = await prisma.marketplaceReimbursement.findMany()
     * 
     * // Get first 10 MarketplaceReimbursements
     * const marketplaceReimbursements = await prisma.marketplaceReimbursement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketplaceReimbursementWithIdOnly = await prisma.marketplaceReimbursement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketplaceReimbursementFindManyArgs>(args?: SelectSubset<T, MarketplaceReimbursementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceReimbursementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MarketplaceReimbursement.
     * @param {MarketplaceReimbursementCreateArgs} args - Arguments to create a MarketplaceReimbursement.
     * @example
     * // Create one MarketplaceReimbursement
     * const MarketplaceReimbursement = await prisma.marketplaceReimbursement.create({
     *   data: {
     *     // ... data to create a MarketplaceReimbursement
     *   }
     * })
     * 
     */
    create<T extends MarketplaceReimbursementCreateArgs>(args: SelectSubset<T, MarketplaceReimbursementCreateArgs<ExtArgs>>): Prisma__MarketplaceReimbursementClient<$Result.GetResult<Prisma.$MarketplaceReimbursementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MarketplaceReimbursements.
     * @param {MarketplaceReimbursementCreateManyArgs} args - Arguments to create many MarketplaceReimbursements.
     * @example
     * // Create many MarketplaceReimbursements
     * const marketplaceReimbursement = await prisma.marketplaceReimbursement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketplaceReimbursementCreateManyArgs>(args?: SelectSubset<T, MarketplaceReimbursementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarketplaceReimbursements and returns the data saved in the database.
     * @param {MarketplaceReimbursementCreateManyAndReturnArgs} args - Arguments to create many MarketplaceReimbursements.
     * @example
     * // Create many MarketplaceReimbursements
     * const marketplaceReimbursement = await prisma.marketplaceReimbursement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarketplaceReimbursements and only return the `id`
     * const marketplaceReimbursementWithIdOnly = await prisma.marketplaceReimbursement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketplaceReimbursementCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketplaceReimbursementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketplaceReimbursementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MarketplaceReimbursement.
     * @param {MarketplaceReimbursementDeleteArgs} args - Arguments to delete one MarketplaceReimbursement.
     * @example
     * // Delete one MarketplaceReimbursement
     * const MarketplaceReimbursement = await prisma.marketplaceReimbursement.delete({
     *   where: {
     *     // ... filter to delete one MarketplaceReimbursement
     *   }
     * })
     * 
     */
    delete<T extends MarketplaceReimbursementDeleteArgs>(args: SelectSubset<T, MarketplaceReimbursementDeleteArgs<ExtArgs>>): Prisma__MarketplaceReimbursementClient<$Result.GetResult<Prisma.$MarketplaceReimbursementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MarketplaceReimbursement.
     * @param {MarketplaceReimbursementUpdateArgs} args - Arguments to update one MarketplaceReimbursement.
     * @example
     * // Update one MarketplaceReimbursement
     * const marketplaceReimbursement = await prisma.marketplaceReimbursement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketplaceReimbursementUpdateArgs>(args: SelectSubset<T, MarketplaceReimbursementUpdateArgs<ExtArgs>>): Prisma__MarketplaceReimbursementClient<$Result.GetResult<Prisma.$MarketplaceReimbursementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MarketplaceReimbursements.
     * @param {MarketplaceReimbursementDeleteManyArgs} args - Arguments to filter MarketplaceReimbursements to delete.
     * @example
     * // Delete a few MarketplaceReimbursements
     * const { count } = await prisma.marketplaceReimbursement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketplaceReimbursementDeleteManyArgs>(args?: SelectSubset<T, MarketplaceReimbursementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketplaceReimbursements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceReimbursementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketplaceReimbursements
     * const marketplaceReimbursement = await prisma.marketplaceReimbursement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketplaceReimbursementUpdateManyArgs>(args: SelectSubset<T, MarketplaceReimbursementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MarketplaceReimbursement.
     * @param {MarketplaceReimbursementUpsertArgs} args - Arguments to update or create a MarketplaceReimbursement.
     * @example
     * // Update or create a MarketplaceReimbursement
     * const marketplaceReimbursement = await prisma.marketplaceReimbursement.upsert({
     *   create: {
     *     // ... data to create a MarketplaceReimbursement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketplaceReimbursement we want to update
     *   }
     * })
     */
    upsert<T extends MarketplaceReimbursementUpsertArgs>(args: SelectSubset<T, MarketplaceReimbursementUpsertArgs<ExtArgs>>): Prisma__MarketplaceReimbursementClient<$Result.GetResult<Prisma.$MarketplaceReimbursementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MarketplaceReimbursements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceReimbursementCountArgs} args - Arguments to filter MarketplaceReimbursements to count.
     * @example
     * // Count the number of MarketplaceReimbursements
     * const count = await prisma.marketplaceReimbursement.count({
     *   where: {
     *     // ... the filter for the MarketplaceReimbursements we want to count
     *   }
     * })
    **/
    count<T extends MarketplaceReimbursementCountArgs>(
      args?: Subset<T, MarketplaceReimbursementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketplaceReimbursementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketplaceReimbursement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceReimbursementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketplaceReimbursementAggregateArgs>(args: Subset<T, MarketplaceReimbursementAggregateArgs>): Prisma.PrismaPromise<GetMarketplaceReimbursementAggregateType<T>>

    /**
     * Group by MarketplaceReimbursement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketplaceReimbursementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketplaceReimbursementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketplaceReimbursementGroupByArgs['orderBy'] }
        : { orderBy?: MarketplaceReimbursementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketplaceReimbursementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketplaceReimbursementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketplaceReimbursement model
   */
  readonly fields: MarketplaceReimbursementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketplaceReimbursement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketplaceReimbursementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    import_batch<T extends MarketplaceReimbursement$import_batchArgs<ExtArgs> = {}>(args?: Subset<T, MarketplaceReimbursement$import_batchArgs<ExtArgs>>): Prisma__ImportBatchClient<$Result.GetResult<Prisma.$ImportBatchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketplaceReimbursement model
   */ 
  interface MarketplaceReimbursementFieldRefs {
    readonly id: FieldRef<"MarketplaceReimbursement", 'String'>
    readonly claim_id: FieldRef<"MarketplaceReimbursement", 'String'>
    readonly reimbursement_type: FieldRef<"MarketplaceReimbursement", 'String'>
    readonly claim_amount: FieldRef<"MarketplaceReimbursement", 'Float'>
    readonly approved_amount: FieldRef<"MarketplaceReimbursement", 'Float'>
    readonly received_amount: FieldRef<"MarketplaceReimbursement", 'Float'>
    readonly processing_fee: FieldRef<"MarketplaceReimbursement", 'Float'>
    readonly incident_date: FieldRef<"MarketplaceReimbursement", 'DateTime'>
    readonly claim_date: FieldRef<"MarketplaceReimbursement", 'DateTime'>
    readonly approval_date: FieldRef<"MarketplaceReimbursement", 'DateTime'>
    readonly received_date: FieldRef<"MarketplaceReimbursement", 'DateTime'>
    readonly affected_order_id: FieldRef<"MarketplaceReimbursement", 'String'>
    readonly product_name: FieldRef<"MarketplaceReimbursement", 'String'>
    readonly marketplace: FieldRef<"MarketplaceReimbursement", 'String'>
    readonly status: FieldRef<"MarketplaceReimbursement", 'String'>
    readonly notes: FieldRef<"MarketplaceReimbursement", 'String'>
    readonly evidence_provided: FieldRef<"MarketplaceReimbursement", 'String'>
    readonly import_batch_id: FieldRef<"MarketplaceReimbursement", 'String'>
    readonly created_at: FieldRef<"MarketplaceReimbursement", 'DateTime'>
    readonly updated_at: FieldRef<"MarketplaceReimbursement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MarketplaceReimbursement findUnique
   */
  export type MarketplaceReimbursementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceReimbursement
     */
    select?: MarketplaceReimbursementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceReimbursementInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceReimbursement to fetch.
     */
    where: MarketplaceReimbursementWhereUniqueInput
  }

  /**
   * MarketplaceReimbursement findUniqueOrThrow
   */
  export type MarketplaceReimbursementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceReimbursement
     */
    select?: MarketplaceReimbursementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceReimbursementInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceReimbursement to fetch.
     */
    where: MarketplaceReimbursementWhereUniqueInput
  }

  /**
   * MarketplaceReimbursement findFirst
   */
  export type MarketplaceReimbursementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceReimbursement
     */
    select?: MarketplaceReimbursementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceReimbursementInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceReimbursement to fetch.
     */
    where?: MarketplaceReimbursementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceReimbursements to fetch.
     */
    orderBy?: MarketplaceReimbursementOrderByWithRelationInput | MarketplaceReimbursementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketplaceReimbursements.
     */
    cursor?: MarketplaceReimbursementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceReimbursements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceReimbursements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketplaceReimbursements.
     */
    distinct?: MarketplaceReimbursementScalarFieldEnum | MarketplaceReimbursementScalarFieldEnum[]
  }

  /**
   * MarketplaceReimbursement findFirstOrThrow
   */
  export type MarketplaceReimbursementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceReimbursement
     */
    select?: MarketplaceReimbursementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceReimbursementInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceReimbursement to fetch.
     */
    where?: MarketplaceReimbursementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceReimbursements to fetch.
     */
    orderBy?: MarketplaceReimbursementOrderByWithRelationInput | MarketplaceReimbursementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketplaceReimbursements.
     */
    cursor?: MarketplaceReimbursementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceReimbursements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceReimbursements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketplaceReimbursements.
     */
    distinct?: MarketplaceReimbursementScalarFieldEnum | MarketplaceReimbursementScalarFieldEnum[]
  }

  /**
   * MarketplaceReimbursement findMany
   */
  export type MarketplaceReimbursementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceReimbursement
     */
    select?: MarketplaceReimbursementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceReimbursementInclude<ExtArgs> | null
    /**
     * Filter, which MarketplaceReimbursements to fetch.
     */
    where?: MarketplaceReimbursementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketplaceReimbursements to fetch.
     */
    orderBy?: MarketplaceReimbursementOrderByWithRelationInput | MarketplaceReimbursementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketplaceReimbursements.
     */
    cursor?: MarketplaceReimbursementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketplaceReimbursements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketplaceReimbursements.
     */
    skip?: number
    distinct?: MarketplaceReimbursementScalarFieldEnum | MarketplaceReimbursementScalarFieldEnum[]
  }

  /**
   * MarketplaceReimbursement create
   */
  export type MarketplaceReimbursementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceReimbursement
     */
    select?: MarketplaceReimbursementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceReimbursementInclude<ExtArgs> | null
    /**
     * The data needed to create a MarketplaceReimbursement.
     */
    data: XOR<MarketplaceReimbursementCreateInput, MarketplaceReimbursementUncheckedCreateInput>
  }

  /**
   * MarketplaceReimbursement createMany
   */
  export type MarketplaceReimbursementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketplaceReimbursements.
     */
    data: MarketplaceReimbursementCreateManyInput | MarketplaceReimbursementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketplaceReimbursement createManyAndReturn
   */
  export type MarketplaceReimbursementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceReimbursement
     */
    select?: MarketplaceReimbursementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MarketplaceReimbursements.
     */
    data: MarketplaceReimbursementCreateManyInput | MarketplaceReimbursementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceReimbursementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MarketplaceReimbursement update
   */
  export type MarketplaceReimbursementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceReimbursement
     */
    select?: MarketplaceReimbursementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceReimbursementInclude<ExtArgs> | null
    /**
     * The data needed to update a MarketplaceReimbursement.
     */
    data: XOR<MarketplaceReimbursementUpdateInput, MarketplaceReimbursementUncheckedUpdateInput>
    /**
     * Choose, which MarketplaceReimbursement to update.
     */
    where: MarketplaceReimbursementWhereUniqueInput
  }

  /**
   * MarketplaceReimbursement updateMany
   */
  export type MarketplaceReimbursementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketplaceReimbursements.
     */
    data: XOR<MarketplaceReimbursementUpdateManyMutationInput, MarketplaceReimbursementUncheckedUpdateManyInput>
    /**
     * Filter which MarketplaceReimbursements to update
     */
    where?: MarketplaceReimbursementWhereInput
  }

  /**
   * MarketplaceReimbursement upsert
   */
  export type MarketplaceReimbursementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceReimbursement
     */
    select?: MarketplaceReimbursementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceReimbursementInclude<ExtArgs> | null
    /**
     * The filter to search for the MarketplaceReimbursement to update in case it exists.
     */
    where: MarketplaceReimbursementWhereUniqueInput
    /**
     * In case the MarketplaceReimbursement found by the `where` argument doesn't exist, create a new MarketplaceReimbursement with this data.
     */
    create: XOR<MarketplaceReimbursementCreateInput, MarketplaceReimbursementUncheckedCreateInput>
    /**
     * In case the MarketplaceReimbursement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketplaceReimbursementUpdateInput, MarketplaceReimbursementUncheckedUpdateInput>
  }

  /**
   * MarketplaceReimbursement delete
   */
  export type MarketplaceReimbursementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceReimbursement
     */
    select?: MarketplaceReimbursementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceReimbursementInclude<ExtArgs> | null
    /**
     * Filter which MarketplaceReimbursement to delete.
     */
    where: MarketplaceReimbursementWhereUniqueInput
  }

  /**
   * MarketplaceReimbursement deleteMany
   */
  export type MarketplaceReimbursementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketplaceReimbursements to delete
     */
    where?: MarketplaceReimbursementWhereInput
  }

  /**
   * MarketplaceReimbursement.import_batch
   */
  export type MarketplaceReimbursement$import_batchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportBatch
     */
    select?: ImportBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportBatchInclude<ExtArgs> | null
    where?: ImportBatchWhereInput
  }

  /**
   * MarketplaceReimbursement without action
   */
  export type MarketplaceReimbursementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketplaceReimbursement
     */
    select?: MarketplaceReimbursementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketplaceReimbursementInclude<ExtArgs> | null
  }


  /**
   * Model CommissionAdjustments
   */

  export type AggregateCommissionAdjustments = {
    _count: CommissionAdjustmentsCountAggregateOutputType | null
    _avg: CommissionAdjustmentsAvgAggregateOutputType | null
    _sum: CommissionAdjustmentsSumAggregateOutputType | null
    _min: CommissionAdjustmentsMinAggregateOutputType | null
    _max: CommissionAdjustmentsMaxAggregateOutputType | null
  }

  export type CommissionAdjustmentsAvgAggregateOutputType = {
    original_commission: number | null
    adjustment_amount: number | null
    final_commission: number | null
    commission_rate: number | null
    quantity: number | null
    product_price: number | null
  }

  export type CommissionAdjustmentsSumAggregateOutputType = {
    original_commission: number | null
    adjustment_amount: number | null
    final_commission: number | null
    commission_rate: number | null
    quantity: number | null
    product_price: number | null
  }

  export type CommissionAdjustmentsMinAggregateOutputType = {
    id: string | null
    original_order_id: string | null
    original_sales_id: string | null
    adjustment_type: string | null
    reason: string | null
    original_commission: number | null
    adjustment_amount: number | null
    final_commission: number | null
    marketplace: string | null
    commission_rate: number | null
    dynamic_rate_applied: boolean | null
    transaction_date: Date | null
    adjustment_date: Date | null
    product_name: string | null
    quantity: number | null
    product_price: number | null
    import_batch_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CommissionAdjustmentsMaxAggregateOutputType = {
    id: string | null
    original_order_id: string | null
    original_sales_id: string | null
    adjustment_type: string | null
    reason: string | null
    original_commission: number | null
    adjustment_amount: number | null
    final_commission: number | null
    marketplace: string | null
    commission_rate: number | null
    dynamic_rate_applied: boolean | null
    transaction_date: Date | null
    adjustment_date: Date | null
    product_name: string | null
    quantity: number | null
    product_price: number | null
    import_batch_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CommissionAdjustmentsCountAggregateOutputType = {
    id: number
    original_order_id: number
    original_sales_id: number
    adjustment_type: number
    reason: number
    original_commission: number
    adjustment_amount: number
    final_commission: number
    marketplace: number
    commission_rate: number
    dynamic_rate_applied: number
    transaction_date: number
    adjustment_date: number
    product_name: number
    quantity: number
    product_price: number
    import_batch_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CommissionAdjustmentsAvgAggregateInputType = {
    original_commission?: true
    adjustment_amount?: true
    final_commission?: true
    commission_rate?: true
    quantity?: true
    product_price?: true
  }

  export type CommissionAdjustmentsSumAggregateInputType = {
    original_commission?: true
    adjustment_amount?: true
    final_commission?: true
    commission_rate?: true
    quantity?: true
    product_price?: true
  }

  export type CommissionAdjustmentsMinAggregateInputType = {
    id?: true
    original_order_id?: true
    original_sales_id?: true
    adjustment_type?: true
    reason?: true
    original_commission?: true
    adjustment_amount?: true
    final_commission?: true
    marketplace?: true
    commission_rate?: true
    dynamic_rate_applied?: true
    transaction_date?: true
    adjustment_date?: true
    product_name?: true
    quantity?: true
    product_price?: true
    import_batch_id?: true
    created_at?: true
    updated_at?: true
  }

  export type CommissionAdjustmentsMaxAggregateInputType = {
    id?: true
    original_order_id?: true
    original_sales_id?: true
    adjustment_type?: true
    reason?: true
    original_commission?: true
    adjustment_amount?: true
    final_commission?: true
    marketplace?: true
    commission_rate?: true
    dynamic_rate_applied?: true
    transaction_date?: true
    adjustment_date?: true
    product_name?: true
    quantity?: true
    product_price?: true
    import_batch_id?: true
    created_at?: true
    updated_at?: true
  }

  export type CommissionAdjustmentsCountAggregateInputType = {
    id?: true
    original_order_id?: true
    original_sales_id?: true
    adjustment_type?: true
    reason?: true
    original_commission?: true
    adjustment_amount?: true
    final_commission?: true
    marketplace?: true
    commission_rate?: true
    dynamic_rate_applied?: true
    transaction_date?: true
    adjustment_date?: true
    product_name?: true
    quantity?: true
    product_price?: true
    import_batch_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CommissionAdjustmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommissionAdjustments to aggregate.
     */
    where?: CommissionAdjustmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommissionAdjustments to fetch.
     */
    orderBy?: CommissionAdjustmentsOrderByWithRelationInput | CommissionAdjustmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommissionAdjustmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommissionAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommissionAdjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommissionAdjustments
    **/
    _count?: true | CommissionAdjustmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommissionAdjustmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommissionAdjustmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommissionAdjustmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommissionAdjustmentsMaxAggregateInputType
  }

  export type GetCommissionAdjustmentsAggregateType<T extends CommissionAdjustmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateCommissionAdjustments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommissionAdjustments[P]>
      : GetScalarType<T[P], AggregateCommissionAdjustments[P]>
  }




  export type CommissionAdjustmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommissionAdjustmentsWhereInput
    orderBy?: CommissionAdjustmentsOrderByWithAggregationInput | CommissionAdjustmentsOrderByWithAggregationInput[]
    by: CommissionAdjustmentsScalarFieldEnum[] | CommissionAdjustmentsScalarFieldEnum
    having?: CommissionAdjustmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommissionAdjustmentsCountAggregateInputType | true
    _avg?: CommissionAdjustmentsAvgAggregateInputType
    _sum?: CommissionAdjustmentsSumAggregateInputType
    _min?: CommissionAdjustmentsMinAggregateInputType
    _max?: CommissionAdjustmentsMaxAggregateInputType
  }

  export type CommissionAdjustmentsGroupByOutputType = {
    id: string
    original_order_id: string | null
    original_sales_id: string | null
    adjustment_type: string
    reason: string | null
    original_commission: number
    adjustment_amount: number
    final_commission: number
    marketplace: string
    commission_rate: number | null
    dynamic_rate_applied: boolean
    transaction_date: Date
    adjustment_date: Date
    product_name: string | null
    quantity: number
    product_price: number
    import_batch_id: string | null
    created_at: Date
    updated_at: Date
    _count: CommissionAdjustmentsCountAggregateOutputType | null
    _avg: CommissionAdjustmentsAvgAggregateOutputType | null
    _sum: CommissionAdjustmentsSumAggregateOutputType | null
    _min: CommissionAdjustmentsMinAggregateOutputType | null
    _max: CommissionAdjustmentsMaxAggregateOutputType | null
  }

  type GetCommissionAdjustmentsGroupByPayload<T extends CommissionAdjustmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommissionAdjustmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommissionAdjustmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommissionAdjustmentsGroupByOutputType[P]>
            : GetScalarType<T[P], CommissionAdjustmentsGroupByOutputType[P]>
        }
      >
    >


  export type CommissionAdjustmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    original_order_id?: boolean
    original_sales_id?: boolean
    adjustment_type?: boolean
    reason?: boolean
    original_commission?: boolean
    adjustment_amount?: boolean
    final_commission?: boolean
    marketplace?: boolean
    commission_rate?: boolean
    dynamic_rate_applied?: boolean
    transaction_date?: boolean
    adjustment_date?: boolean
    product_name?: boolean
    quantity?: boolean
    product_price?: boolean
    import_batch_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    import_batch?: boolean | CommissionAdjustments$import_batchArgs<ExtArgs>
  }, ExtArgs["result"]["commissionAdjustments"]>

  export type CommissionAdjustmentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    original_order_id?: boolean
    original_sales_id?: boolean
    adjustment_type?: boolean
    reason?: boolean
    original_commission?: boolean
    adjustment_amount?: boolean
    final_commission?: boolean
    marketplace?: boolean
    commission_rate?: boolean
    dynamic_rate_applied?: boolean
    transaction_date?: boolean
    adjustment_date?: boolean
    product_name?: boolean
    quantity?: boolean
    product_price?: boolean
    import_batch_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    import_batch?: boolean | CommissionAdjustments$import_batchArgs<ExtArgs>
  }, ExtArgs["result"]["commissionAdjustments"]>

  export type CommissionAdjustmentsSelectScalar = {
    id?: boolean
    original_order_id?: boolean
    original_sales_id?: boolean
    adjustment_type?: boolean
    reason?: boolean
    original_commission?: boolean
    adjustment_amount?: boolean
    final_commission?: boolean
    marketplace?: boolean
    commission_rate?: boolean
    dynamic_rate_applied?: boolean
    transaction_date?: boolean
    adjustment_date?: boolean
    product_name?: boolean
    quantity?: boolean
    product_price?: boolean
    import_batch_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type CommissionAdjustmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    import_batch?: boolean | CommissionAdjustments$import_batchArgs<ExtArgs>
  }
  export type CommissionAdjustmentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    import_batch?: boolean | CommissionAdjustments$import_batchArgs<ExtArgs>
  }

  export type $CommissionAdjustmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommissionAdjustments"
    objects: {
      import_batch: Prisma.$ImportBatchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      original_order_id: string | null
      original_sales_id: string | null
      adjustment_type: string
      reason: string | null
      original_commission: number
      adjustment_amount: number
      final_commission: number
      marketplace: string
      commission_rate: number | null
      dynamic_rate_applied: boolean
      transaction_date: Date
      adjustment_date: Date
      product_name: string | null
      quantity: number
      product_price: number
      import_batch_id: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["commissionAdjustments"]>
    composites: {}
  }

  type CommissionAdjustmentsGetPayload<S extends boolean | null | undefined | CommissionAdjustmentsDefaultArgs> = $Result.GetResult<Prisma.$CommissionAdjustmentsPayload, S>

  type CommissionAdjustmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommissionAdjustmentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommissionAdjustmentsCountAggregateInputType | true
    }

  export interface CommissionAdjustmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommissionAdjustments'], meta: { name: 'CommissionAdjustments' } }
    /**
     * Find zero or one CommissionAdjustments that matches the filter.
     * @param {CommissionAdjustmentsFindUniqueArgs} args - Arguments to find a CommissionAdjustments
     * @example
     * // Get one CommissionAdjustments
     * const commissionAdjustments = await prisma.commissionAdjustments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommissionAdjustmentsFindUniqueArgs>(args: SelectSubset<T, CommissionAdjustmentsFindUniqueArgs<ExtArgs>>): Prisma__CommissionAdjustmentsClient<$Result.GetResult<Prisma.$CommissionAdjustmentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CommissionAdjustments that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommissionAdjustmentsFindUniqueOrThrowArgs} args - Arguments to find a CommissionAdjustments
     * @example
     * // Get one CommissionAdjustments
     * const commissionAdjustments = await prisma.commissionAdjustments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommissionAdjustmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, CommissionAdjustmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommissionAdjustmentsClient<$Result.GetResult<Prisma.$CommissionAdjustmentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CommissionAdjustments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionAdjustmentsFindFirstArgs} args - Arguments to find a CommissionAdjustments
     * @example
     * // Get one CommissionAdjustments
     * const commissionAdjustments = await prisma.commissionAdjustments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommissionAdjustmentsFindFirstArgs>(args?: SelectSubset<T, CommissionAdjustmentsFindFirstArgs<ExtArgs>>): Prisma__CommissionAdjustmentsClient<$Result.GetResult<Prisma.$CommissionAdjustmentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CommissionAdjustments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionAdjustmentsFindFirstOrThrowArgs} args - Arguments to find a CommissionAdjustments
     * @example
     * // Get one CommissionAdjustments
     * const commissionAdjustments = await prisma.commissionAdjustments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommissionAdjustmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, CommissionAdjustmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommissionAdjustmentsClient<$Result.GetResult<Prisma.$CommissionAdjustmentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CommissionAdjustments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionAdjustmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommissionAdjustments
     * const commissionAdjustments = await prisma.commissionAdjustments.findMany()
     * 
     * // Get first 10 CommissionAdjustments
     * const commissionAdjustments = await prisma.commissionAdjustments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commissionAdjustmentsWithIdOnly = await prisma.commissionAdjustments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommissionAdjustmentsFindManyArgs>(args?: SelectSubset<T, CommissionAdjustmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionAdjustmentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CommissionAdjustments.
     * @param {CommissionAdjustmentsCreateArgs} args - Arguments to create a CommissionAdjustments.
     * @example
     * // Create one CommissionAdjustments
     * const CommissionAdjustments = await prisma.commissionAdjustments.create({
     *   data: {
     *     // ... data to create a CommissionAdjustments
     *   }
     * })
     * 
     */
    create<T extends CommissionAdjustmentsCreateArgs>(args: SelectSubset<T, CommissionAdjustmentsCreateArgs<ExtArgs>>): Prisma__CommissionAdjustmentsClient<$Result.GetResult<Prisma.$CommissionAdjustmentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CommissionAdjustments.
     * @param {CommissionAdjustmentsCreateManyArgs} args - Arguments to create many CommissionAdjustments.
     * @example
     * // Create many CommissionAdjustments
     * const commissionAdjustments = await prisma.commissionAdjustments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommissionAdjustmentsCreateManyArgs>(args?: SelectSubset<T, CommissionAdjustmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommissionAdjustments and returns the data saved in the database.
     * @param {CommissionAdjustmentsCreateManyAndReturnArgs} args - Arguments to create many CommissionAdjustments.
     * @example
     * // Create many CommissionAdjustments
     * const commissionAdjustments = await prisma.commissionAdjustments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommissionAdjustments and only return the `id`
     * const commissionAdjustmentsWithIdOnly = await prisma.commissionAdjustments.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommissionAdjustmentsCreateManyAndReturnArgs>(args?: SelectSubset<T, CommissionAdjustmentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionAdjustmentsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CommissionAdjustments.
     * @param {CommissionAdjustmentsDeleteArgs} args - Arguments to delete one CommissionAdjustments.
     * @example
     * // Delete one CommissionAdjustments
     * const CommissionAdjustments = await prisma.commissionAdjustments.delete({
     *   where: {
     *     // ... filter to delete one CommissionAdjustments
     *   }
     * })
     * 
     */
    delete<T extends CommissionAdjustmentsDeleteArgs>(args: SelectSubset<T, CommissionAdjustmentsDeleteArgs<ExtArgs>>): Prisma__CommissionAdjustmentsClient<$Result.GetResult<Prisma.$CommissionAdjustmentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CommissionAdjustments.
     * @param {CommissionAdjustmentsUpdateArgs} args - Arguments to update one CommissionAdjustments.
     * @example
     * // Update one CommissionAdjustments
     * const commissionAdjustments = await prisma.commissionAdjustments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommissionAdjustmentsUpdateArgs>(args: SelectSubset<T, CommissionAdjustmentsUpdateArgs<ExtArgs>>): Prisma__CommissionAdjustmentsClient<$Result.GetResult<Prisma.$CommissionAdjustmentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CommissionAdjustments.
     * @param {CommissionAdjustmentsDeleteManyArgs} args - Arguments to filter CommissionAdjustments to delete.
     * @example
     * // Delete a few CommissionAdjustments
     * const { count } = await prisma.commissionAdjustments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommissionAdjustmentsDeleteManyArgs>(args?: SelectSubset<T, CommissionAdjustmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommissionAdjustments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionAdjustmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommissionAdjustments
     * const commissionAdjustments = await prisma.commissionAdjustments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommissionAdjustmentsUpdateManyArgs>(args: SelectSubset<T, CommissionAdjustmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommissionAdjustments.
     * @param {CommissionAdjustmentsUpsertArgs} args - Arguments to update or create a CommissionAdjustments.
     * @example
     * // Update or create a CommissionAdjustments
     * const commissionAdjustments = await prisma.commissionAdjustments.upsert({
     *   create: {
     *     // ... data to create a CommissionAdjustments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommissionAdjustments we want to update
     *   }
     * })
     */
    upsert<T extends CommissionAdjustmentsUpsertArgs>(args: SelectSubset<T, CommissionAdjustmentsUpsertArgs<ExtArgs>>): Prisma__CommissionAdjustmentsClient<$Result.GetResult<Prisma.$CommissionAdjustmentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CommissionAdjustments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionAdjustmentsCountArgs} args - Arguments to filter CommissionAdjustments to count.
     * @example
     * // Count the number of CommissionAdjustments
     * const count = await prisma.commissionAdjustments.count({
     *   where: {
     *     // ... the filter for the CommissionAdjustments we want to count
     *   }
     * })
    **/
    count<T extends CommissionAdjustmentsCountArgs>(
      args?: Subset<T, CommissionAdjustmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommissionAdjustmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommissionAdjustments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionAdjustmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommissionAdjustmentsAggregateArgs>(args: Subset<T, CommissionAdjustmentsAggregateArgs>): Prisma.PrismaPromise<GetCommissionAdjustmentsAggregateType<T>>

    /**
     * Group by CommissionAdjustments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionAdjustmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommissionAdjustmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommissionAdjustmentsGroupByArgs['orderBy'] }
        : { orderBy?: CommissionAdjustmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommissionAdjustmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommissionAdjustmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommissionAdjustments model
   */
  readonly fields: CommissionAdjustmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommissionAdjustments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommissionAdjustmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    import_batch<T extends CommissionAdjustments$import_batchArgs<ExtArgs> = {}>(args?: Subset<T, CommissionAdjustments$import_batchArgs<ExtArgs>>): Prisma__ImportBatchClient<$Result.GetResult<Prisma.$ImportBatchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommissionAdjustments model
   */ 
  interface CommissionAdjustmentsFieldRefs {
    readonly id: FieldRef<"CommissionAdjustments", 'String'>
    readonly original_order_id: FieldRef<"CommissionAdjustments", 'String'>
    readonly original_sales_id: FieldRef<"CommissionAdjustments", 'String'>
    readonly adjustment_type: FieldRef<"CommissionAdjustments", 'String'>
    readonly reason: FieldRef<"CommissionAdjustments", 'String'>
    readonly original_commission: FieldRef<"CommissionAdjustments", 'Float'>
    readonly adjustment_amount: FieldRef<"CommissionAdjustments", 'Float'>
    readonly final_commission: FieldRef<"CommissionAdjustments", 'Float'>
    readonly marketplace: FieldRef<"CommissionAdjustments", 'String'>
    readonly commission_rate: FieldRef<"CommissionAdjustments", 'Float'>
    readonly dynamic_rate_applied: FieldRef<"CommissionAdjustments", 'Boolean'>
    readonly transaction_date: FieldRef<"CommissionAdjustments", 'DateTime'>
    readonly adjustment_date: FieldRef<"CommissionAdjustments", 'DateTime'>
    readonly product_name: FieldRef<"CommissionAdjustments", 'String'>
    readonly quantity: FieldRef<"CommissionAdjustments", 'Int'>
    readonly product_price: FieldRef<"CommissionAdjustments", 'Float'>
    readonly import_batch_id: FieldRef<"CommissionAdjustments", 'String'>
    readonly created_at: FieldRef<"CommissionAdjustments", 'DateTime'>
    readonly updated_at: FieldRef<"CommissionAdjustments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommissionAdjustments findUnique
   */
  export type CommissionAdjustmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionAdjustments
     */
    select?: CommissionAdjustmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionAdjustmentsInclude<ExtArgs> | null
    /**
     * Filter, which CommissionAdjustments to fetch.
     */
    where: CommissionAdjustmentsWhereUniqueInput
  }

  /**
   * CommissionAdjustments findUniqueOrThrow
   */
  export type CommissionAdjustmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionAdjustments
     */
    select?: CommissionAdjustmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionAdjustmentsInclude<ExtArgs> | null
    /**
     * Filter, which CommissionAdjustments to fetch.
     */
    where: CommissionAdjustmentsWhereUniqueInput
  }

  /**
   * CommissionAdjustments findFirst
   */
  export type CommissionAdjustmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionAdjustments
     */
    select?: CommissionAdjustmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionAdjustmentsInclude<ExtArgs> | null
    /**
     * Filter, which CommissionAdjustments to fetch.
     */
    where?: CommissionAdjustmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommissionAdjustments to fetch.
     */
    orderBy?: CommissionAdjustmentsOrderByWithRelationInput | CommissionAdjustmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommissionAdjustments.
     */
    cursor?: CommissionAdjustmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommissionAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommissionAdjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommissionAdjustments.
     */
    distinct?: CommissionAdjustmentsScalarFieldEnum | CommissionAdjustmentsScalarFieldEnum[]
  }

  /**
   * CommissionAdjustments findFirstOrThrow
   */
  export type CommissionAdjustmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionAdjustments
     */
    select?: CommissionAdjustmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionAdjustmentsInclude<ExtArgs> | null
    /**
     * Filter, which CommissionAdjustments to fetch.
     */
    where?: CommissionAdjustmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommissionAdjustments to fetch.
     */
    orderBy?: CommissionAdjustmentsOrderByWithRelationInput | CommissionAdjustmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommissionAdjustments.
     */
    cursor?: CommissionAdjustmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommissionAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommissionAdjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommissionAdjustments.
     */
    distinct?: CommissionAdjustmentsScalarFieldEnum | CommissionAdjustmentsScalarFieldEnum[]
  }

  /**
   * CommissionAdjustments findMany
   */
  export type CommissionAdjustmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionAdjustments
     */
    select?: CommissionAdjustmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionAdjustmentsInclude<ExtArgs> | null
    /**
     * Filter, which CommissionAdjustments to fetch.
     */
    where?: CommissionAdjustmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommissionAdjustments to fetch.
     */
    orderBy?: CommissionAdjustmentsOrderByWithRelationInput | CommissionAdjustmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommissionAdjustments.
     */
    cursor?: CommissionAdjustmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommissionAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommissionAdjustments.
     */
    skip?: number
    distinct?: CommissionAdjustmentsScalarFieldEnum | CommissionAdjustmentsScalarFieldEnum[]
  }

  /**
   * CommissionAdjustments create
   */
  export type CommissionAdjustmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionAdjustments
     */
    select?: CommissionAdjustmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionAdjustmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a CommissionAdjustments.
     */
    data: XOR<CommissionAdjustmentsCreateInput, CommissionAdjustmentsUncheckedCreateInput>
  }

  /**
   * CommissionAdjustments createMany
   */
  export type CommissionAdjustmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommissionAdjustments.
     */
    data: CommissionAdjustmentsCreateManyInput | CommissionAdjustmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommissionAdjustments createManyAndReturn
   */
  export type CommissionAdjustmentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionAdjustments
     */
    select?: CommissionAdjustmentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CommissionAdjustments.
     */
    data: CommissionAdjustmentsCreateManyInput | CommissionAdjustmentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionAdjustmentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommissionAdjustments update
   */
  export type CommissionAdjustmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionAdjustments
     */
    select?: CommissionAdjustmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionAdjustmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a CommissionAdjustments.
     */
    data: XOR<CommissionAdjustmentsUpdateInput, CommissionAdjustmentsUncheckedUpdateInput>
    /**
     * Choose, which CommissionAdjustments to update.
     */
    where: CommissionAdjustmentsWhereUniqueInput
  }

  /**
   * CommissionAdjustments updateMany
   */
  export type CommissionAdjustmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommissionAdjustments.
     */
    data: XOR<CommissionAdjustmentsUpdateManyMutationInput, CommissionAdjustmentsUncheckedUpdateManyInput>
    /**
     * Filter which CommissionAdjustments to update
     */
    where?: CommissionAdjustmentsWhereInput
  }

  /**
   * CommissionAdjustments upsert
   */
  export type CommissionAdjustmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionAdjustments
     */
    select?: CommissionAdjustmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionAdjustmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the CommissionAdjustments to update in case it exists.
     */
    where: CommissionAdjustmentsWhereUniqueInput
    /**
     * In case the CommissionAdjustments found by the `where` argument doesn't exist, create a new CommissionAdjustments with this data.
     */
    create: XOR<CommissionAdjustmentsCreateInput, CommissionAdjustmentsUncheckedCreateInput>
    /**
     * In case the CommissionAdjustments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommissionAdjustmentsUpdateInput, CommissionAdjustmentsUncheckedUpdateInput>
  }

  /**
   * CommissionAdjustments delete
   */
  export type CommissionAdjustmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionAdjustments
     */
    select?: CommissionAdjustmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionAdjustmentsInclude<ExtArgs> | null
    /**
     * Filter which CommissionAdjustments to delete.
     */
    where: CommissionAdjustmentsWhereUniqueInput
  }

  /**
   * CommissionAdjustments deleteMany
   */
  export type CommissionAdjustmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommissionAdjustments to delete
     */
    where?: CommissionAdjustmentsWhereInput
  }

  /**
   * CommissionAdjustments.import_batch
   */
  export type CommissionAdjustments$import_batchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportBatch
     */
    select?: ImportBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportBatchInclude<ExtArgs> | null
    where?: ImportBatchWhereInput
  }

  /**
   * CommissionAdjustments without action
   */
  export type CommissionAdjustmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommissionAdjustments
     */
    select?: CommissionAdjustmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionAdjustmentsInclude<ExtArgs> | null
  }


  /**
   * Model AffiliateSamples
   */

  export type AggregateAffiliateSamples = {
    _count: AffiliateSamplesCountAggregateOutputType | null
    _avg: AffiliateSamplesAvgAggregateOutputType | null
    _sum: AffiliateSamplesSumAggregateOutputType | null
    _min: AffiliateSamplesMinAggregateOutputType | null
    _max: AffiliateSamplesMaxAggregateOutputType | null
  }

  export type AffiliateSamplesAvgAggregateOutputType = {
    quantity_given: number | null
    product_cost: number | null
    total_cost: number | null
    shipping_cost: number | null
    packaging_cost: number | null
    expected_reach: number | null
    roi_estimate: number | null
  }

  export type AffiliateSamplesSumAggregateOutputType = {
    quantity_given: number | null
    product_cost: number | null
    total_cost: number | null
    shipping_cost: number | null
    packaging_cost: number | null
    expected_reach: number | null
    roi_estimate: number | null
  }

  export type AffiliateSamplesMinAggregateOutputType = {
    id: string | null
    affiliate_name: string | null
    affiliate_platform: string | null
    affiliate_contact: string | null
    product_name: string | null
    product_sku: string | null
    quantity_given: number | null
    product_cost: number | null
    total_cost: number | null
    shipping_cost: number | null
    packaging_cost: number | null
    campaign_name: string | null
    expected_reach: number | null
    content_type: string | null
    given_date: Date | null
    expected_content_date: Date | null
    actual_content_date: Date | null
    content_delivered: boolean | null
    performance_notes: string | null
    roi_estimate: number | null
    status: string | null
    import_batch_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AffiliateSamplesMaxAggregateOutputType = {
    id: string | null
    affiliate_name: string | null
    affiliate_platform: string | null
    affiliate_contact: string | null
    product_name: string | null
    product_sku: string | null
    quantity_given: number | null
    product_cost: number | null
    total_cost: number | null
    shipping_cost: number | null
    packaging_cost: number | null
    campaign_name: string | null
    expected_reach: number | null
    content_type: string | null
    given_date: Date | null
    expected_content_date: Date | null
    actual_content_date: Date | null
    content_delivered: boolean | null
    performance_notes: string | null
    roi_estimate: number | null
    status: string | null
    import_batch_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AffiliateSamplesCountAggregateOutputType = {
    id: number
    affiliate_name: number
    affiliate_platform: number
    affiliate_contact: number
    product_name: number
    product_sku: number
    quantity_given: number
    product_cost: number
    total_cost: number
    shipping_cost: number
    packaging_cost: number
    campaign_name: number
    expected_reach: number
    content_type: number
    given_date: number
    expected_content_date: number
    actual_content_date: number
    content_delivered: number
    performance_notes: number
    roi_estimate: number
    status: number
    import_batch_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AffiliateSamplesAvgAggregateInputType = {
    quantity_given?: true
    product_cost?: true
    total_cost?: true
    shipping_cost?: true
    packaging_cost?: true
    expected_reach?: true
    roi_estimate?: true
  }

  export type AffiliateSamplesSumAggregateInputType = {
    quantity_given?: true
    product_cost?: true
    total_cost?: true
    shipping_cost?: true
    packaging_cost?: true
    expected_reach?: true
    roi_estimate?: true
  }

  export type AffiliateSamplesMinAggregateInputType = {
    id?: true
    affiliate_name?: true
    affiliate_platform?: true
    affiliate_contact?: true
    product_name?: true
    product_sku?: true
    quantity_given?: true
    product_cost?: true
    total_cost?: true
    shipping_cost?: true
    packaging_cost?: true
    campaign_name?: true
    expected_reach?: true
    content_type?: true
    given_date?: true
    expected_content_date?: true
    actual_content_date?: true
    content_delivered?: true
    performance_notes?: true
    roi_estimate?: true
    status?: true
    import_batch_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AffiliateSamplesMaxAggregateInputType = {
    id?: true
    affiliate_name?: true
    affiliate_platform?: true
    affiliate_contact?: true
    product_name?: true
    product_sku?: true
    quantity_given?: true
    product_cost?: true
    total_cost?: true
    shipping_cost?: true
    packaging_cost?: true
    campaign_name?: true
    expected_reach?: true
    content_type?: true
    given_date?: true
    expected_content_date?: true
    actual_content_date?: true
    content_delivered?: true
    performance_notes?: true
    roi_estimate?: true
    status?: true
    import_batch_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AffiliateSamplesCountAggregateInputType = {
    id?: true
    affiliate_name?: true
    affiliate_platform?: true
    affiliate_contact?: true
    product_name?: true
    product_sku?: true
    quantity_given?: true
    product_cost?: true
    total_cost?: true
    shipping_cost?: true
    packaging_cost?: true
    campaign_name?: true
    expected_reach?: true
    content_type?: true
    given_date?: true
    expected_content_date?: true
    actual_content_date?: true
    content_delivered?: true
    performance_notes?: true
    roi_estimate?: true
    status?: true
    import_batch_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AffiliateSamplesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AffiliateSamples to aggregate.
     */
    where?: AffiliateSamplesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateSamples to fetch.
     */
    orderBy?: AffiliateSamplesOrderByWithRelationInput | AffiliateSamplesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AffiliateSamplesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateSamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateSamples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AffiliateSamples
    **/
    _count?: true | AffiliateSamplesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AffiliateSamplesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AffiliateSamplesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AffiliateSamplesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AffiliateSamplesMaxAggregateInputType
  }

  export type GetAffiliateSamplesAggregateType<T extends AffiliateSamplesAggregateArgs> = {
        [P in keyof T & keyof AggregateAffiliateSamples]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAffiliateSamples[P]>
      : GetScalarType<T[P], AggregateAffiliateSamples[P]>
  }




  export type AffiliateSamplesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateSamplesWhereInput
    orderBy?: AffiliateSamplesOrderByWithAggregationInput | AffiliateSamplesOrderByWithAggregationInput[]
    by: AffiliateSamplesScalarFieldEnum[] | AffiliateSamplesScalarFieldEnum
    having?: AffiliateSamplesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AffiliateSamplesCountAggregateInputType | true
    _avg?: AffiliateSamplesAvgAggregateInputType
    _sum?: AffiliateSamplesSumAggregateInputType
    _min?: AffiliateSamplesMinAggregateInputType
    _max?: AffiliateSamplesMaxAggregateInputType
  }

  export type AffiliateSamplesGroupByOutputType = {
    id: string
    affiliate_name: string
    affiliate_platform: string | null
    affiliate_contact: string | null
    product_name: string
    product_sku: string | null
    quantity_given: number
    product_cost: number
    total_cost: number
    shipping_cost: number
    packaging_cost: number
    campaign_name: string | null
    expected_reach: number | null
    content_type: string | null
    given_date: Date
    expected_content_date: Date | null
    actual_content_date: Date | null
    content_delivered: boolean
    performance_notes: string | null
    roi_estimate: number | null
    status: string
    import_batch_id: string | null
    created_at: Date
    updated_at: Date
    _count: AffiliateSamplesCountAggregateOutputType | null
    _avg: AffiliateSamplesAvgAggregateOutputType | null
    _sum: AffiliateSamplesSumAggregateOutputType | null
    _min: AffiliateSamplesMinAggregateOutputType | null
    _max: AffiliateSamplesMaxAggregateOutputType | null
  }

  type GetAffiliateSamplesGroupByPayload<T extends AffiliateSamplesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AffiliateSamplesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AffiliateSamplesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AffiliateSamplesGroupByOutputType[P]>
            : GetScalarType<T[P], AffiliateSamplesGroupByOutputType[P]>
        }
      >
    >


  export type AffiliateSamplesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    affiliate_name?: boolean
    affiliate_platform?: boolean
    affiliate_contact?: boolean
    product_name?: boolean
    product_sku?: boolean
    quantity_given?: boolean
    product_cost?: boolean
    total_cost?: boolean
    shipping_cost?: boolean
    packaging_cost?: boolean
    campaign_name?: boolean
    expected_reach?: boolean
    content_type?: boolean
    given_date?: boolean
    expected_content_date?: boolean
    actual_content_date?: boolean
    content_delivered?: boolean
    performance_notes?: boolean
    roi_estimate?: boolean
    status?: boolean
    import_batch_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    import_batch?: boolean | AffiliateSamples$import_batchArgs<ExtArgs>
  }, ExtArgs["result"]["affiliateSamples"]>

  export type AffiliateSamplesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    affiliate_name?: boolean
    affiliate_platform?: boolean
    affiliate_contact?: boolean
    product_name?: boolean
    product_sku?: boolean
    quantity_given?: boolean
    product_cost?: boolean
    total_cost?: boolean
    shipping_cost?: boolean
    packaging_cost?: boolean
    campaign_name?: boolean
    expected_reach?: boolean
    content_type?: boolean
    given_date?: boolean
    expected_content_date?: boolean
    actual_content_date?: boolean
    content_delivered?: boolean
    performance_notes?: boolean
    roi_estimate?: boolean
    status?: boolean
    import_batch_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    import_batch?: boolean | AffiliateSamples$import_batchArgs<ExtArgs>
  }, ExtArgs["result"]["affiliateSamples"]>

  export type AffiliateSamplesSelectScalar = {
    id?: boolean
    affiliate_name?: boolean
    affiliate_platform?: boolean
    affiliate_contact?: boolean
    product_name?: boolean
    product_sku?: boolean
    quantity_given?: boolean
    product_cost?: boolean
    total_cost?: boolean
    shipping_cost?: boolean
    packaging_cost?: boolean
    campaign_name?: boolean
    expected_reach?: boolean
    content_type?: boolean
    given_date?: boolean
    expected_content_date?: boolean
    actual_content_date?: boolean
    content_delivered?: boolean
    performance_notes?: boolean
    roi_estimate?: boolean
    status?: boolean
    import_batch_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type AffiliateSamplesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    import_batch?: boolean | AffiliateSamples$import_batchArgs<ExtArgs>
  }
  export type AffiliateSamplesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    import_batch?: boolean | AffiliateSamples$import_batchArgs<ExtArgs>
  }

  export type $AffiliateSamplesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AffiliateSamples"
    objects: {
      import_batch: Prisma.$ImportBatchPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      affiliate_name: string
      affiliate_platform: string | null
      affiliate_contact: string | null
      product_name: string
      product_sku: string | null
      quantity_given: number
      product_cost: number
      total_cost: number
      shipping_cost: number
      packaging_cost: number
      campaign_name: string | null
      expected_reach: number | null
      content_type: string | null
      given_date: Date
      expected_content_date: Date | null
      actual_content_date: Date | null
      content_delivered: boolean
      performance_notes: string | null
      roi_estimate: number | null
      status: string
      import_batch_id: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["affiliateSamples"]>
    composites: {}
  }

  type AffiliateSamplesGetPayload<S extends boolean | null | undefined | AffiliateSamplesDefaultArgs> = $Result.GetResult<Prisma.$AffiliateSamplesPayload, S>

  type AffiliateSamplesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AffiliateSamplesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AffiliateSamplesCountAggregateInputType | true
    }

  export interface AffiliateSamplesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AffiliateSamples'], meta: { name: 'AffiliateSamples' } }
    /**
     * Find zero or one AffiliateSamples that matches the filter.
     * @param {AffiliateSamplesFindUniqueArgs} args - Arguments to find a AffiliateSamples
     * @example
     * // Get one AffiliateSamples
     * const affiliateSamples = await prisma.affiliateSamples.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AffiliateSamplesFindUniqueArgs>(args: SelectSubset<T, AffiliateSamplesFindUniqueArgs<ExtArgs>>): Prisma__AffiliateSamplesClient<$Result.GetResult<Prisma.$AffiliateSamplesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AffiliateSamples that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AffiliateSamplesFindUniqueOrThrowArgs} args - Arguments to find a AffiliateSamples
     * @example
     * // Get one AffiliateSamples
     * const affiliateSamples = await prisma.affiliateSamples.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AffiliateSamplesFindUniqueOrThrowArgs>(args: SelectSubset<T, AffiliateSamplesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AffiliateSamplesClient<$Result.GetResult<Prisma.$AffiliateSamplesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AffiliateSamples that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateSamplesFindFirstArgs} args - Arguments to find a AffiliateSamples
     * @example
     * // Get one AffiliateSamples
     * const affiliateSamples = await prisma.affiliateSamples.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AffiliateSamplesFindFirstArgs>(args?: SelectSubset<T, AffiliateSamplesFindFirstArgs<ExtArgs>>): Prisma__AffiliateSamplesClient<$Result.GetResult<Prisma.$AffiliateSamplesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AffiliateSamples that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateSamplesFindFirstOrThrowArgs} args - Arguments to find a AffiliateSamples
     * @example
     * // Get one AffiliateSamples
     * const affiliateSamples = await prisma.affiliateSamples.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AffiliateSamplesFindFirstOrThrowArgs>(args?: SelectSubset<T, AffiliateSamplesFindFirstOrThrowArgs<ExtArgs>>): Prisma__AffiliateSamplesClient<$Result.GetResult<Prisma.$AffiliateSamplesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AffiliateSamples that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateSamplesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AffiliateSamples
     * const affiliateSamples = await prisma.affiliateSamples.findMany()
     * 
     * // Get first 10 AffiliateSamples
     * const affiliateSamples = await prisma.affiliateSamples.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const affiliateSamplesWithIdOnly = await prisma.affiliateSamples.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AffiliateSamplesFindManyArgs>(args?: SelectSubset<T, AffiliateSamplesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateSamplesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AffiliateSamples.
     * @param {AffiliateSamplesCreateArgs} args - Arguments to create a AffiliateSamples.
     * @example
     * // Create one AffiliateSamples
     * const AffiliateSamples = await prisma.affiliateSamples.create({
     *   data: {
     *     // ... data to create a AffiliateSamples
     *   }
     * })
     * 
     */
    create<T extends AffiliateSamplesCreateArgs>(args: SelectSubset<T, AffiliateSamplesCreateArgs<ExtArgs>>): Prisma__AffiliateSamplesClient<$Result.GetResult<Prisma.$AffiliateSamplesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AffiliateSamples.
     * @param {AffiliateSamplesCreateManyArgs} args - Arguments to create many AffiliateSamples.
     * @example
     * // Create many AffiliateSamples
     * const affiliateSamples = await prisma.affiliateSamples.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AffiliateSamplesCreateManyArgs>(args?: SelectSubset<T, AffiliateSamplesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AffiliateSamples and returns the data saved in the database.
     * @param {AffiliateSamplesCreateManyAndReturnArgs} args - Arguments to create many AffiliateSamples.
     * @example
     * // Create many AffiliateSamples
     * const affiliateSamples = await prisma.affiliateSamples.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AffiliateSamples and only return the `id`
     * const affiliateSamplesWithIdOnly = await prisma.affiliateSamples.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AffiliateSamplesCreateManyAndReturnArgs>(args?: SelectSubset<T, AffiliateSamplesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateSamplesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AffiliateSamples.
     * @param {AffiliateSamplesDeleteArgs} args - Arguments to delete one AffiliateSamples.
     * @example
     * // Delete one AffiliateSamples
     * const AffiliateSamples = await prisma.affiliateSamples.delete({
     *   where: {
     *     // ... filter to delete one AffiliateSamples
     *   }
     * })
     * 
     */
    delete<T extends AffiliateSamplesDeleteArgs>(args: SelectSubset<T, AffiliateSamplesDeleteArgs<ExtArgs>>): Prisma__AffiliateSamplesClient<$Result.GetResult<Prisma.$AffiliateSamplesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AffiliateSamples.
     * @param {AffiliateSamplesUpdateArgs} args - Arguments to update one AffiliateSamples.
     * @example
     * // Update one AffiliateSamples
     * const affiliateSamples = await prisma.affiliateSamples.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AffiliateSamplesUpdateArgs>(args: SelectSubset<T, AffiliateSamplesUpdateArgs<ExtArgs>>): Prisma__AffiliateSamplesClient<$Result.GetResult<Prisma.$AffiliateSamplesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AffiliateSamples.
     * @param {AffiliateSamplesDeleteManyArgs} args - Arguments to filter AffiliateSamples to delete.
     * @example
     * // Delete a few AffiliateSamples
     * const { count } = await prisma.affiliateSamples.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AffiliateSamplesDeleteManyArgs>(args?: SelectSubset<T, AffiliateSamplesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AffiliateSamples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateSamplesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AffiliateSamples
     * const affiliateSamples = await prisma.affiliateSamples.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AffiliateSamplesUpdateManyArgs>(args: SelectSubset<T, AffiliateSamplesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AffiliateSamples.
     * @param {AffiliateSamplesUpsertArgs} args - Arguments to update or create a AffiliateSamples.
     * @example
     * // Update or create a AffiliateSamples
     * const affiliateSamples = await prisma.affiliateSamples.upsert({
     *   create: {
     *     // ... data to create a AffiliateSamples
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AffiliateSamples we want to update
     *   }
     * })
     */
    upsert<T extends AffiliateSamplesUpsertArgs>(args: SelectSubset<T, AffiliateSamplesUpsertArgs<ExtArgs>>): Prisma__AffiliateSamplesClient<$Result.GetResult<Prisma.$AffiliateSamplesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AffiliateSamples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateSamplesCountArgs} args - Arguments to filter AffiliateSamples to count.
     * @example
     * // Count the number of AffiliateSamples
     * const count = await prisma.affiliateSamples.count({
     *   where: {
     *     // ... the filter for the AffiliateSamples we want to count
     *   }
     * })
    **/
    count<T extends AffiliateSamplesCountArgs>(
      args?: Subset<T, AffiliateSamplesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AffiliateSamplesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AffiliateSamples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateSamplesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AffiliateSamplesAggregateArgs>(args: Subset<T, AffiliateSamplesAggregateArgs>): Prisma.PrismaPromise<GetAffiliateSamplesAggregateType<T>>

    /**
     * Group by AffiliateSamples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateSamplesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AffiliateSamplesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AffiliateSamplesGroupByArgs['orderBy'] }
        : { orderBy?: AffiliateSamplesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AffiliateSamplesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAffiliateSamplesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AffiliateSamples model
   */
  readonly fields: AffiliateSamplesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AffiliateSamples.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AffiliateSamplesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    import_batch<T extends AffiliateSamples$import_batchArgs<ExtArgs> = {}>(args?: Subset<T, AffiliateSamples$import_batchArgs<ExtArgs>>): Prisma__ImportBatchClient<$Result.GetResult<Prisma.$ImportBatchPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AffiliateSamples model
   */ 
  interface AffiliateSamplesFieldRefs {
    readonly id: FieldRef<"AffiliateSamples", 'String'>
    readonly affiliate_name: FieldRef<"AffiliateSamples", 'String'>
    readonly affiliate_platform: FieldRef<"AffiliateSamples", 'String'>
    readonly affiliate_contact: FieldRef<"AffiliateSamples", 'String'>
    readonly product_name: FieldRef<"AffiliateSamples", 'String'>
    readonly product_sku: FieldRef<"AffiliateSamples", 'String'>
    readonly quantity_given: FieldRef<"AffiliateSamples", 'Int'>
    readonly product_cost: FieldRef<"AffiliateSamples", 'Float'>
    readonly total_cost: FieldRef<"AffiliateSamples", 'Float'>
    readonly shipping_cost: FieldRef<"AffiliateSamples", 'Float'>
    readonly packaging_cost: FieldRef<"AffiliateSamples", 'Float'>
    readonly campaign_name: FieldRef<"AffiliateSamples", 'String'>
    readonly expected_reach: FieldRef<"AffiliateSamples", 'Int'>
    readonly content_type: FieldRef<"AffiliateSamples", 'String'>
    readonly given_date: FieldRef<"AffiliateSamples", 'DateTime'>
    readonly expected_content_date: FieldRef<"AffiliateSamples", 'DateTime'>
    readonly actual_content_date: FieldRef<"AffiliateSamples", 'DateTime'>
    readonly content_delivered: FieldRef<"AffiliateSamples", 'Boolean'>
    readonly performance_notes: FieldRef<"AffiliateSamples", 'String'>
    readonly roi_estimate: FieldRef<"AffiliateSamples", 'Float'>
    readonly status: FieldRef<"AffiliateSamples", 'String'>
    readonly import_batch_id: FieldRef<"AffiliateSamples", 'String'>
    readonly created_at: FieldRef<"AffiliateSamples", 'DateTime'>
    readonly updated_at: FieldRef<"AffiliateSamples", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AffiliateSamples findUnique
   */
  export type AffiliateSamplesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateSamples
     */
    select?: AffiliateSamplesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateSamplesInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateSamples to fetch.
     */
    where: AffiliateSamplesWhereUniqueInput
  }

  /**
   * AffiliateSamples findUniqueOrThrow
   */
  export type AffiliateSamplesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateSamples
     */
    select?: AffiliateSamplesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateSamplesInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateSamples to fetch.
     */
    where: AffiliateSamplesWhereUniqueInput
  }

  /**
   * AffiliateSamples findFirst
   */
  export type AffiliateSamplesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateSamples
     */
    select?: AffiliateSamplesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateSamplesInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateSamples to fetch.
     */
    where?: AffiliateSamplesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateSamples to fetch.
     */
    orderBy?: AffiliateSamplesOrderByWithRelationInput | AffiliateSamplesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AffiliateSamples.
     */
    cursor?: AffiliateSamplesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateSamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateSamples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AffiliateSamples.
     */
    distinct?: AffiliateSamplesScalarFieldEnum | AffiliateSamplesScalarFieldEnum[]
  }

  /**
   * AffiliateSamples findFirstOrThrow
   */
  export type AffiliateSamplesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateSamples
     */
    select?: AffiliateSamplesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateSamplesInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateSamples to fetch.
     */
    where?: AffiliateSamplesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateSamples to fetch.
     */
    orderBy?: AffiliateSamplesOrderByWithRelationInput | AffiliateSamplesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AffiliateSamples.
     */
    cursor?: AffiliateSamplesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateSamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateSamples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AffiliateSamples.
     */
    distinct?: AffiliateSamplesScalarFieldEnum | AffiliateSamplesScalarFieldEnum[]
  }

  /**
   * AffiliateSamples findMany
   */
  export type AffiliateSamplesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateSamples
     */
    select?: AffiliateSamplesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateSamplesInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateSamples to fetch.
     */
    where?: AffiliateSamplesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateSamples to fetch.
     */
    orderBy?: AffiliateSamplesOrderByWithRelationInput | AffiliateSamplesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AffiliateSamples.
     */
    cursor?: AffiliateSamplesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateSamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateSamples.
     */
    skip?: number
    distinct?: AffiliateSamplesScalarFieldEnum | AffiliateSamplesScalarFieldEnum[]
  }

  /**
   * AffiliateSamples create
   */
  export type AffiliateSamplesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateSamples
     */
    select?: AffiliateSamplesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateSamplesInclude<ExtArgs> | null
    /**
     * The data needed to create a AffiliateSamples.
     */
    data: XOR<AffiliateSamplesCreateInput, AffiliateSamplesUncheckedCreateInput>
  }

  /**
   * AffiliateSamples createMany
   */
  export type AffiliateSamplesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AffiliateSamples.
     */
    data: AffiliateSamplesCreateManyInput | AffiliateSamplesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AffiliateSamples createManyAndReturn
   */
  export type AffiliateSamplesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateSamples
     */
    select?: AffiliateSamplesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AffiliateSamples.
     */
    data: AffiliateSamplesCreateManyInput | AffiliateSamplesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateSamplesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AffiliateSamples update
   */
  export type AffiliateSamplesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateSamples
     */
    select?: AffiliateSamplesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateSamplesInclude<ExtArgs> | null
    /**
     * The data needed to update a AffiliateSamples.
     */
    data: XOR<AffiliateSamplesUpdateInput, AffiliateSamplesUncheckedUpdateInput>
    /**
     * Choose, which AffiliateSamples to update.
     */
    where: AffiliateSamplesWhereUniqueInput
  }

  /**
   * AffiliateSamples updateMany
   */
  export type AffiliateSamplesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AffiliateSamples.
     */
    data: XOR<AffiliateSamplesUpdateManyMutationInput, AffiliateSamplesUncheckedUpdateManyInput>
    /**
     * Filter which AffiliateSamples to update
     */
    where?: AffiliateSamplesWhereInput
  }

  /**
   * AffiliateSamples upsert
   */
  export type AffiliateSamplesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateSamples
     */
    select?: AffiliateSamplesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateSamplesInclude<ExtArgs> | null
    /**
     * The filter to search for the AffiliateSamples to update in case it exists.
     */
    where: AffiliateSamplesWhereUniqueInput
    /**
     * In case the AffiliateSamples found by the `where` argument doesn't exist, create a new AffiliateSamples with this data.
     */
    create: XOR<AffiliateSamplesCreateInput, AffiliateSamplesUncheckedCreateInput>
    /**
     * In case the AffiliateSamples was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AffiliateSamplesUpdateInput, AffiliateSamplesUncheckedUpdateInput>
  }

  /**
   * AffiliateSamples delete
   */
  export type AffiliateSamplesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateSamples
     */
    select?: AffiliateSamplesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateSamplesInclude<ExtArgs> | null
    /**
     * Filter which AffiliateSamples to delete.
     */
    where: AffiliateSamplesWhereUniqueInput
  }

  /**
   * AffiliateSamples deleteMany
   */
  export type AffiliateSamplesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AffiliateSamples to delete
     */
    where?: AffiliateSamplesWhereInput
  }

  /**
   * AffiliateSamples.import_batch
   */
  export type AffiliateSamples$import_batchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportBatch
     */
    select?: ImportBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportBatchInclude<ExtArgs> | null
    where?: ImportBatchWhereInput
  }

  /**
   * AffiliateSamples without action
   */
  export type AffiliateSamplesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateSamples
     */
    select?: AffiliateSamplesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateSamplesInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    color: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    color: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    color: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    color?: true
    created_at?: true
    updated_at?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    color?: true
    created_at?: true
    updated_at?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    color?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    color: string | null
    created_at: Date
    updated_at: Date
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      color: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */ 
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly color: FieldRef<"Category", 'String'>
    readonly created_at: FieldRef<"Category", 'DateTime'>
    readonly updated_at: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
  }


  /**
   * Model Brand
   */

  export type AggregateBrand = {
    _count: BrandCountAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  export type BrandMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    website: string | null
    logo_color: string | null
    is_premium: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BrandMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    website: string | null
    logo_color: string | null
    is_premium: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BrandCountAggregateOutputType = {
    id: number
    name: number
    description: number
    website: number
    logo_color: number
    is_premium: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type BrandMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    website?: true
    logo_color?: true
    is_premium?: true
    created_at?: true
    updated_at?: true
  }

  export type BrandMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    website?: true
    logo_color?: true
    is_premium?: true
    created_at?: true
    updated_at?: true
  }

  export type BrandCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    website?: true
    logo_color?: true
    is_premium?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type BrandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brand to aggregate.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Brands
    **/
    _count?: true | BrandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrandMaxAggregateInputType
  }

  export type GetBrandAggregateType<T extends BrandAggregateArgs> = {
        [P in keyof T & keyof AggregateBrand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrand[P]>
      : GetScalarType<T[P], AggregateBrand[P]>
  }




  export type BrandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BrandWhereInput
    orderBy?: BrandOrderByWithAggregationInput | BrandOrderByWithAggregationInput[]
    by: BrandScalarFieldEnum[] | BrandScalarFieldEnum
    having?: BrandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrandCountAggregateInputType | true
    _min?: BrandMinAggregateInputType
    _max?: BrandMaxAggregateInputType
  }

  export type BrandGroupByOutputType = {
    id: string
    name: string
    description: string | null
    website: string | null
    logo_color: string | null
    is_premium: boolean
    created_at: Date
    updated_at: Date
    _count: BrandCountAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  type GetBrandGroupByPayload<T extends BrandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrandGroupByOutputType[P]>
            : GetScalarType<T[P], BrandGroupByOutputType[P]>
        }
      >
    >


  export type BrandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    website?: boolean
    logo_color?: boolean
    is_premium?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    website?: boolean
    logo_color?: boolean
    is_premium?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    website?: boolean
    logo_color?: boolean
    is_premium?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $BrandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Brand"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      website: string | null
      logo_color: string | null
      is_premium: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["brand"]>
    composites: {}
  }

  type BrandGetPayload<S extends boolean | null | undefined | BrandDefaultArgs> = $Result.GetResult<Prisma.$BrandPayload, S>

  type BrandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BrandFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BrandCountAggregateInputType | true
    }

  export interface BrandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Brand'], meta: { name: 'Brand' } }
    /**
     * Find zero or one Brand that matches the filter.
     * @param {BrandFindUniqueArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BrandFindUniqueArgs>(args: SelectSubset<T, BrandFindUniqueArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Brand that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BrandFindUniqueOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BrandFindUniqueOrThrowArgs>(args: SelectSubset<T, BrandFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Brand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindFirstArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BrandFindFirstArgs>(args?: SelectSubset<T, BrandFindFirstArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Brand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindFirstOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BrandFindFirstOrThrowArgs>(args?: SelectSubset<T, BrandFindFirstOrThrowArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Brands
     * const brands = await prisma.brand.findMany()
     * 
     * // Get first 10 Brands
     * const brands = await prisma.brand.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const brandWithIdOnly = await prisma.brand.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BrandFindManyArgs>(args?: SelectSubset<T, BrandFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Brand.
     * @param {BrandCreateArgs} args - Arguments to create a Brand.
     * @example
     * // Create one Brand
     * const Brand = await prisma.brand.create({
     *   data: {
     *     // ... data to create a Brand
     *   }
     * })
     * 
     */
    create<T extends BrandCreateArgs>(args: SelectSubset<T, BrandCreateArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Brands.
     * @param {BrandCreateManyArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brand = await prisma.brand.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BrandCreateManyArgs>(args?: SelectSubset<T, BrandCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Brands and returns the data saved in the database.
     * @param {BrandCreateManyAndReturnArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brand = await prisma.brand.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Brands and only return the `id`
     * const brandWithIdOnly = await prisma.brand.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BrandCreateManyAndReturnArgs>(args?: SelectSubset<T, BrandCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Brand.
     * @param {BrandDeleteArgs} args - Arguments to delete one Brand.
     * @example
     * // Delete one Brand
     * const Brand = await prisma.brand.delete({
     *   where: {
     *     // ... filter to delete one Brand
     *   }
     * })
     * 
     */
    delete<T extends BrandDeleteArgs>(args: SelectSubset<T, BrandDeleteArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Brand.
     * @param {BrandUpdateArgs} args - Arguments to update one Brand.
     * @example
     * // Update one Brand
     * const brand = await prisma.brand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BrandUpdateArgs>(args: SelectSubset<T, BrandUpdateArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Brands.
     * @param {BrandDeleteManyArgs} args - Arguments to filter Brands to delete.
     * @example
     * // Delete a few Brands
     * const { count } = await prisma.brand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BrandDeleteManyArgs>(args?: SelectSubset<T, BrandDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Brands
     * const brand = await prisma.brand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BrandUpdateManyArgs>(args: SelectSubset<T, BrandUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Brand.
     * @param {BrandUpsertArgs} args - Arguments to update or create a Brand.
     * @example
     * // Update or create a Brand
     * const brand = await prisma.brand.upsert({
     *   create: {
     *     // ... data to create a Brand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Brand we want to update
     *   }
     * })
     */
    upsert<T extends BrandUpsertArgs>(args: SelectSubset<T, BrandUpsertArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandCountArgs} args - Arguments to filter Brands to count.
     * @example
     * // Count the number of Brands
     * const count = await prisma.brand.count({
     *   where: {
     *     // ... the filter for the Brands we want to count
     *   }
     * })
    **/
    count<T extends BrandCountArgs>(
      args?: Subset<T, BrandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrandAggregateArgs>(args: Subset<T, BrandAggregateArgs>): Prisma.PrismaPromise<GetBrandAggregateType<T>>

    /**
     * Group by Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BrandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BrandGroupByArgs['orderBy'] }
        : { orderBy?: BrandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BrandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Brand model
   */
  readonly fields: BrandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Brand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BrandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Brand model
   */ 
  interface BrandFieldRefs {
    readonly id: FieldRef<"Brand", 'String'>
    readonly name: FieldRef<"Brand", 'String'>
    readonly description: FieldRef<"Brand", 'String'>
    readonly website: FieldRef<"Brand", 'String'>
    readonly logo_color: FieldRef<"Brand", 'String'>
    readonly is_premium: FieldRef<"Brand", 'Boolean'>
    readonly created_at: FieldRef<"Brand", 'DateTime'>
    readonly updated_at: FieldRef<"Brand", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Brand findUnique
   */
  export type BrandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand findUniqueOrThrow
   */
  export type BrandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand findFirst
   */
  export type BrandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand findFirstOrThrow
   */
  export type BrandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand findMany
   */
  export type BrandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Filter, which Brands to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand create
   */
  export type BrandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * The data needed to create a Brand.
     */
    data: XOR<BrandCreateInput, BrandUncheckedCreateInput>
  }

  /**
   * Brand createMany
   */
  export type BrandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Brands.
     */
    data: BrandCreateManyInput | BrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Brand createManyAndReturn
   */
  export type BrandCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Brands.
     */
    data: BrandCreateManyInput | BrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Brand update
   */
  export type BrandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * The data needed to update a Brand.
     */
    data: XOR<BrandUpdateInput, BrandUncheckedUpdateInput>
    /**
     * Choose, which Brand to update.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand updateMany
   */
  export type BrandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Brands.
     */
    data: XOR<BrandUpdateManyMutationInput, BrandUncheckedUpdateManyInput>
    /**
     * Filter which Brands to update
     */
    where?: BrandWhereInput
  }

  /**
   * Brand upsert
   */
  export type BrandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * The filter to search for the Brand to update in case it exists.
     */
    where: BrandWhereUniqueInput
    /**
     * In case the Brand found by the `where` argument doesn't exist, create a new Brand with this data.
     */
    create: XOR<BrandCreateInput, BrandUncheckedCreateInput>
    /**
     * In case the Brand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BrandUpdateInput, BrandUncheckedUpdateInput>
  }

  /**
   * Brand delete
   */
  export type BrandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Filter which Brand to delete.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand deleteMany
   */
  export type BrandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brands to delete
     */
    where?: BrandWhereInput
  }

  /**
   * Brand without action
   */
  export type BrandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
  }


  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierAvgAggregateOutputType = {
    rating: number | null
  }

  export type SupplierSumAggregateOutputType = {
    rating: number | null
  }

  export type SupplierMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    contact_person: string | null
    phone: string | null
    email: string | null
    address: string | null
    category: string | null
    rating: number | null
    status: $Enums.SupplierStatus | null
    payment_terms: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    contact_person: string | null
    phone: string | null
    email: string | null
    address: string | null
    category: string | null
    rating: number | null
    status: $Enums.SupplierStatus | null
    payment_terms: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    code: number
    name: number
    contact_person: number
    phone: number
    email: number
    address: number
    category: number
    rating: number
    status: number
    payment_terms: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SupplierAvgAggregateInputType = {
    rating?: true
  }

  export type SupplierSumAggregateInputType = {
    rating?: true
  }

  export type SupplierMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    contact_person?: true
    phone?: true
    email?: true
    address?: true
    category?: true
    rating?: true
    status?: true
    payment_terms?: true
    created_at?: true
    updated_at?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    contact_person?: true
    phone?: true
    email?: true
    address?: true
    category?: true
    rating?: true
    status?: true
    payment_terms?: true
    created_at?: true
    updated_at?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    contact_person?: true
    phone?: true
    email?: true
    address?: true
    category?: true
    rating?: true
    status?: true
    payment_terms?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _avg?: SupplierAvgAggregateInputType
    _sum?: SupplierSumAggregateInputType
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: string
    code: string
    name: string
    contact_person: string
    phone: string
    email: string
    address: string
    category: string
    rating: number
    status: $Enums.SupplierStatus
    payment_terms: string
    created_at: Date
    updated_at: Date
    _count: SupplierCountAggregateOutputType | null
    _avg: SupplierAvgAggregateOutputType | null
    _sum: SupplierSumAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    contact_person?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    category?: boolean
    rating?: boolean
    status?: boolean
    payment_terms?: boolean
    created_at?: boolean
    updated_at?: boolean
    purchase_orders?: boolean | Supplier$purchase_ordersArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    contact_person?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    category?: boolean
    rating?: boolean
    status?: boolean
    payment_terms?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    contact_person?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    category?: boolean
    rating?: boolean
    status?: boolean
    payment_terms?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type SupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase_orders?: boolean | Supplier$purchase_ordersArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SupplierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {
      purchase_orders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      contact_person: string
      phone: string
      email: string
      address: string
      category: string
      rating: number
      status: $Enums.SupplierStatus
      payment_terms: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }

  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierFindUniqueArgs>(args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierFindFirstArgs>(args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierFindManyArgs>(args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
     */
    create<T extends SupplierCreateArgs>(args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Suppliers.
     * @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierCreateManyArgs>(args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Suppliers and returns the data saved in the database.
     * @param {SupplierCreateManyAndReturnArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
     */
    delete<T extends SupplierDeleteArgs>(args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierUpdateArgs>(args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierDeleteManyArgs>(args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierUpdateManyArgs>(args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
     */
    upsert<T extends SupplierUpsertArgs>(args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchase_orders<T extends Supplier$purchase_ordersArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$purchase_ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Supplier model
   */ 
  interface SupplierFieldRefs {
    readonly id: FieldRef<"Supplier", 'String'>
    readonly code: FieldRef<"Supplier", 'String'>
    readonly name: FieldRef<"Supplier", 'String'>
    readonly contact_person: FieldRef<"Supplier", 'String'>
    readonly phone: FieldRef<"Supplier", 'String'>
    readonly email: FieldRef<"Supplier", 'String'>
    readonly address: FieldRef<"Supplier", 'String'>
    readonly category: FieldRef<"Supplier", 'String'>
    readonly rating: FieldRef<"Supplier", 'Float'>
    readonly status: FieldRef<"Supplier", 'SupplierStatus'>
    readonly payment_terms: FieldRef<"Supplier", 'String'>
    readonly created_at: FieldRef<"Supplier", 'DateTime'>
    readonly updated_at: FieldRef<"Supplier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }

  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier createManyAndReturn
   */
  export type SupplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
  }

  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }

  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
  }

  /**
   * Supplier.purchase_orders
   */
  export type Supplier$purchase_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrder
   */

  export type AggregatePurchaseOrder = {
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  export type PurchaseOrderAvgAggregateOutputType = {
    total_amount: number | null
    items_count: number | null
  }

  export type PurchaseOrderSumAggregateOutputType = {
    total_amount: number | null
    items_count: number | null
  }

  export type PurchaseOrderMinAggregateOutputType = {
    id: string | null
    po_number: string | null
    supplier_id: string | null
    po_date: Date | null
    expected_date: Date | null
    delivery_date: Date | null
    status: $Enums.POStatus | null
    total_amount: number | null
    items_count: number | null
    notes: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PurchaseOrderMaxAggregateOutputType = {
    id: string | null
    po_number: string | null
    supplier_id: string | null
    po_date: Date | null
    expected_date: Date | null
    delivery_date: Date | null
    status: $Enums.POStatus | null
    total_amount: number | null
    items_count: number | null
    notes: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PurchaseOrderCountAggregateOutputType = {
    id: number
    po_number: number
    supplier_id: number
    po_date: number
    expected_date: number
    delivery_date: number
    status: number
    total_amount: number
    items_count: number
    notes: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PurchaseOrderAvgAggregateInputType = {
    total_amount?: true
    items_count?: true
  }

  export type PurchaseOrderSumAggregateInputType = {
    total_amount?: true
    items_count?: true
  }

  export type PurchaseOrderMinAggregateInputType = {
    id?: true
    po_number?: true
    supplier_id?: true
    po_date?: true
    expected_date?: true
    delivery_date?: true
    status?: true
    total_amount?: true
    items_count?: true
    notes?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type PurchaseOrderMaxAggregateInputType = {
    id?: true
    po_number?: true
    supplier_id?: true
    po_date?: true
    expected_date?: true
    delivery_date?: true
    status?: true
    total_amount?: true
    items_count?: true
    notes?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type PurchaseOrderCountAggregateInputType = {
    id?: true
    po_number?: true
    supplier_id?: true
    po_date?: true
    expected_date?: true
    delivery_date?: true
    status?: true
    total_amount?: true
    items_count?: true
    notes?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PurchaseOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrder to aggregate.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrders
    **/
    _count?: true | PurchaseOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type GetPurchaseOrderAggregateType<T extends PurchaseOrderAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrder[P]>
      : GetScalarType<T[P], AggregatePurchaseOrder[P]>
  }




  export type PurchaseOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithAggregationInput | PurchaseOrderOrderByWithAggregationInput[]
    by: PurchaseOrderScalarFieldEnum[] | PurchaseOrderScalarFieldEnum
    having?: PurchaseOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderCountAggregateInputType | true
    _avg?: PurchaseOrderAvgAggregateInputType
    _sum?: PurchaseOrderSumAggregateInputType
    _min?: PurchaseOrderMinAggregateInputType
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type PurchaseOrderGroupByOutputType = {
    id: string
    po_number: string
    supplier_id: string
    po_date: Date
    expected_date: Date
    delivery_date: Date | null
    status: $Enums.POStatus
    total_amount: number
    items_count: number
    notes: string | null
    created_by: string | null
    created_at: Date
    updated_at: Date
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  type GetPurchaseOrderGroupByPayload<T extends PurchaseOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    po_number?: boolean
    supplier_id?: boolean
    po_date?: boolean
    expected_date?: boolean
    delivery_date?: boolean
    status?: boolean
    total_amount?: boolean
    items_count?: boolean
    notes?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    items?: boolean | PurchaseOrder$itemsArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    po_number?: boolean
    supplier_id?: boolean
    po_date?: boolean
    expected_date?: boolean
    delivery_date?: boolean
    status?: boolean
    total_amount?: boolean
    items_count?: boolean
    notes?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectScalar = {
    id?: boolean
    po_number?: boolean
    supplier_id?: boolean
    po_date?: boolean
    expected_date?: boolean
    delivery_date?: boolean
    status?: boolean
    total_amount?: boolean
    items_count?: boolean
    notes?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type PurchaseOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
    items?: boolean | PurchaseOrder$itemsArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }

  export type $PurchaseOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrder"
    objects: {
      supplier: Prisma.$SupplierPayload<ExtArgs>
      items: Prisma.$PurchaseOrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      po_number: string
      supplier_id: string
      po_date: Date
      expected_date: Date
      delivery_date: Date | null
      status: $Enums.POStatus
      total_amount: number
      items_count: number
      notes: string | null
      created_by: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["purchaseOrder"]>
    composites: {}
  }

  type PurchaseOrderGetPayload<S extends boolean | null | undefined | PurchaseOrderDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderPayload, S>

  type PurchaseOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PurchaseOrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PurchaseOrderCountAggregateInputType | true
    }

  export interface PurchaseOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrder'], meta: { name: 'PurchaseOrder' } }
    /**
     * Find zero or one PurchaseOrder that matches the filter.
     * @param {PurchaseOrderFindUniqueArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PurchaseOrder that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PurchaseOrderFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PurchaseOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PurchaseOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PurchaseOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany()
     * 
     * // Get first 10 PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseOrderFindManyArgs>(args?: SelectSubset<T, PurchaseOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PurchaseOrder.
     * @param {PurchaseOrderCreateArgs} args - Arguments to create a PurchaseOrder.
     * @example
     * // Create one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.create({
     *   data: {
     *     // ... data to create a PurchaseOrder
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderCreateArgs>(args: SelectSubset<T, PurchaseOrderCreateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PurchaseOrders.
     * @param {PurchaseOrderCreateManyArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseOrders and returns the data saved in the database.
     * @param {PurchaseOrderCreateManyAndReturnArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseOrders and only return the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PurchaseOrder.
     * @param {PurchaseOrderDeleteArgs} args - Arguments to delete one PurchaseOrder.
     * @example
     * // Delete one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrder
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderDeleteArgs>(args: SelectSubset<T, PurchaseOrderDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PurchaseOrder.
     * @param {PurchaseOrderUpdateArgs} args - Arguments to update one PurchaseOrder.
     * @example
     * // Update one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderUpdateArgs>(args: SelectSubset<T, PurchaseOrderUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PurchaseOrders.
     * @param {PurchaseOrderDeleteManyArgs} args - Arguments to filter PurchaseOrders to delete.
     * @example
     * // Delete a few PurchaseOrders
     * const { count } = await prisma.purchaseOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PurchaseOrder.
     * @param {PurchaseOrderUpsertArgs} args - Arguments to update or create a PurchaseOrder.
     * @example
     * // Update or create a PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrder we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderUpsertArgs>(args: SelectSubset<T, PurchaseOrderUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderCountArgs} args - Arguments to filter PurchaseOrders to count.
     * @example
     * // Count the number of PurchaseOrders
     * const count = await prisma.purchaseOrder.count({
     *   where: {
     *     // ... the filter for the PurchaseOrders we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderCountArgs>(
      args?: Subset<T, PurchaseOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderAggregateArgs>(args: Subset<T, PurchaseOrderAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderAggregateType<T>>

    /**
     * Group by PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrder model
   */
  readonly fields: PurchaseOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends PurchaseOrder$itemsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrder model
   */ 
  interface PurchaseOrderFieldRefs {
    readonly id: FieldRef<"PurchaseOrder", 'String'>
    readonly po_number: FieldRef<"PurchaseOrder", 'String'>
    readonly supplier_id: FieldRef<"PurchaseOrder", 'String'>
    readonly po_date: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly expected_date: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly delivery_date: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly status: FieldRef<"PurchaseOrder", 'POStatus'>
    readonly total_amount: FieldRef<"PurchaseOrder", 'Float'>
    readonly items_count: FieldRef<"PurchaseOrder", 'Int'>
    readonly notes: FieldRef<"PurchaseOrder", 'String'>
    readonly created_by: FieldRef<"PurchaseOrder", 'String'>
    readonly created_at: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly updated_at: FieldRef<"PurchaseOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrder findUnique
   */
  export type PurchaseOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findUniqueOrThrow
   */
  export type PurchaseOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findFirst
   */
  export type PurchaseOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findFirstOrThrow
   */
  export type PurchaseOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findMany
   */
  export type PurchaseOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrders to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder create
   */
  export type PurchaseOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrder.
     */
    data: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
  }

  /**
   * PurchaseOrder createMany
   */
  export type PurchaseOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseOrder createManyAndReturn
   */
  export type PurchaseOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrder update
   */
  export type PurchaseOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrder.
     */
    data: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrder to update.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder updateMany
   */
  export type PurchaseOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
  }

  /**
   * PurchaseOrder upsert
   */
  export type PurchaseOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrder to update in case it exists.
     */
    where: PurchaseOrderWhereUniqueInput
    /**
     * In case the PurchaseOrder found by the `where` argument doesn't exist, create a new PurchaseOrder with this data.
     */
    create: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
    /**
     * In case the PurchaseOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
  }

  /**
   * PurchaseOrder delete
   */
  export type PurchaseOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrder to delete.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder deleteMany
   */
  export type PurchaseOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrders to delete
     */
    where?: PurchaseOrderWhereInput
  }

  /**
   * PurchaseOrder.items
   */
  export type PurchaseOrder$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    where?: PurchaseOrderItemWhereInput
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    cursor?: PurchaseOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrder without action
   */
  export type PurchaseOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrderItem
   */

  export type AggregatePurchaseOrderItem = {
    _count: PurchaseOrderItemCountAggregateOutputType | null
    _avg: PurchaseOrderItemAvgAggregateOutputType | null
    _sum: PurchaseOrderItemSumAggregateOutputType | null
    _min: PurchaseOrderItemMinAggregateOutputType | null
    _max: PurchaseOrderItemMaxAggregateOutputType | null
  }

  export type PurchaseOrderItemAvgAggregateOutputType = {
    quantity: number | null
    unit_price: number | null
    total_price: number | null
    received_quantity: number | null
  }

  export type PurchaseOrderItemSumAggregateOutputType = {
    quantity: number | null
    unit_price: number | null
    total_price: number | null
    received_quantity: number | null
  }

  export type PurchaseOrderItemMinAggregateOutputType = {
    id: string | null
    purchase_order_id: string | null
    material_id: string | null
    material_name: string | null
    material_description: string | null
    quantity: number | null
    unit_price: number | null
    total_price: number | null
    received_quantity: number | null
    unit: string | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PurchaseOrderItemMaxAggregateOutputType = {
    id: string | null
    purchase_order_id: string | null
    material_id: string | null
    material_name: string | null
    material_description: string | null
    quantity: number | null
    unit_price: number | null
    total_price: number | null
    received_quantity: number | null
    unit: string | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PurchaseOrderItemCountAggregateOutputType = {
    id: number
    purchase_order_id: number
    material_id: number
    material_name: number
    material_description: number
    quantity: number
    unit_price: number
    total_price: number
    received_quantity: number
    unit: number
    notes: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PurchaseOrderItemAvgAggregateInputType = {
    quantity?: true
    unit_price?: true
    total_price?: true
    received_quantity?: true
  }

  export type PurchaseOrderItemSumAggregateInputType = {
    quantity?: true
    unit_price?: true
    total_price?: true
    received_quantity?: true
  }

  export type PurchaseOrderItemMinAggregateInputType = {
    id?: true
    purchase_order_id?: true
    material_id?: true
    material_name?: true
    material_description?: true
    quantity?: true
    unit_price?: true
    total_price?: true
    received_quantity?: true
    unit?: true
    notes?: true
    created_at?: true
    updated_at?: true
  }

  export type PurchaseOrderItemMaxAggregateInputType = {
    id?: true
    purchase_order_id?: true
    material_id?: true
    material_name?: true
    material_description?: true
    quantity?: true
    unit_price?: true
    total_price?: true
    received_quantity?: true
    unit?: true
    notes?: true
    created_at?: true
    updated_at?: true
  }

  export type PurchaseOrderItemCountAggregateInputType = {
    id?: true
    purchase_order_id?: true
    material_id?: true
    material_name?: true
    material_description?: true
    quantity?: true
    unit_price?: true
    total_price?: true
    received_quantity?: true
    unit?: true
    notes?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PurchaseOrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrderItem to aggregate.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrderItems
    **/
    _count?: true | PurchaseOrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseOrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseOrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderItemMaxAggregateInputType
  }

  export type GetPurchaseOrderItemAggregateType<T extends PurchaseOrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrderItem[P]>
      : GetScalarType<T[P], AggregatePurchaseOrderItem[P]>
  }




  export type PurchaseOrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderItemWhereInput
    orderBy?: PurchaseOrderItemOrderByWithAggregationInput | PurchaseOrderItemOrderByWithAggregationInput[]
    by: PurchaseOrderItemScalarFieldEnum[] | PurchaseOrderItemScalarFieldEnum
    having?: PurchaseOrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderItemCountAggregateInputType | true
    _avg?: PurchaseOrderItemAvgAggregateInputType
    _sum?: PurchaseOrderItemSumAggregateInputType
    _min?: PurchaseOrderItemMinAggregateInputType
    _max?: PurchaseOrderItemMaxAggregateInputType
  }

  export type PurchaseOrderItemGroupByOutputType = {
    id: string
    purchase_order_id: string
    material_id: string
    material_name: string | null
    material_description: string | null
    quantity: number
    unit_price: number
    total_price: number
    received_quantity: number | null
    unit: string
    notes: string | null
    created_at: Date
    updated_at: Date
    _count: PurchaseOrderItemCountAggregateOutputType | null
    _avg: PurchaseOrderItemAvgAggregateOutputType | null
    _sum: PurchaseOrderItemSumAggregateOutputType | null
    _min: PurchaseOrderItemMinAggregateOutputType | null
    _max: PurchaseOrderItemMaxAggregateOutputType | null
  }

  type GetPurchaseOrderItemGroupByPayload<T extends PurchaseOrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderItemGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchase_order_id?: boolean
    material_id?: boolean
    material_name?: boolean
    material_description?: boolean
    quantity?: boolean
    unit_price?: boolean
    total_price?: boolean
    received_quantity?: boolean
    unit?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    purchase_order?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderItem"]>

  export type PurchaseOrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    purchase_order_id?: boolean
    material_id?: boolean
    material_name?: boolean
    material_description?: boolean
    quantity?: boolean
    unit_price?: boolean
    total_price?: boolean
    received_quantity?: boolean
    unit?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    purchase_order?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrderItem"]>

  export type PurchaseOrderItemSelectScalar = {
    id?: boolean
    purchase_order_id?: boolean
    material_id?: boolean
    material_name?: boolean
    material_description?: boolean
    quantity?: boolean
    unit_price?: boolean
    total_price?: boolean
    received_quantity?: boolean
    unit?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type PurchaseOrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase_order?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase_order?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
  }

  export type $PurchaseOrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrderItem"
    objects: {
      purchase_order: Prisma.$PurchaseOrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      purchase_order_id: string
      material_id: string
      material_name: string | null
      material_description: string | null
      quantity: number
      unit_price: number
      total_price: number
      received_quantity: number | null
      unit: string
      notes: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["purchaseOrderItem"]>
    composites: {}
  }

  type PurchaseOrderItemGetPayload<S extends boolean | null | undefined | PurchaseOrderItemDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderItemPayload, S>

  type PurchaseOrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PurchaseOrderItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PurchaseOrderItemCountAggregateInputType | true
    }

  export interface PurchaseOrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrderItem'], meta: { name: 'PurchaseOrderItem' } }
    /**
     * Find zero or one PurchaseOrderItem that matches the filter.
     * @param {PurchaseOrderItemFindUniqueArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderItemFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderItemFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PurchaseOrderItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PurchaseOrderItemFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PurchaseOrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemFindFirstArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderItemFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderItemFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PurchaseOrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrderItem
     * @example
     * // Get one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PurchaseOrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrderItems
     * const purchaseOrderItems = await prisma.purchaseOrderItem.findMany()
     * 
     * // Get first 10 PurchaseOrderItems
     * const purchaseOrderItems = await prisma.purchaseOrderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderItemWithIdOnly = await prisma.purchaseOrderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseOrderItemFindManyArgs>(args?: SelectSubset<T, PurchaseOrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PurchaseOrderItem.
     * @param {PurchaseOrderItemCreateArgs} args - Arguments to create a PurchaseOrderItem.
     * @example
     * // Create one PurchaseOrderItem
     * const PurchaseOrderItem = await prisma.purchaseOrderItem.create({
     *   data: {
     *     // ... data to create a PurchaseOrderItem
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderItemCreateArgs>(args: SelectSubset<T, PurchaseOrderItemCreateArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PurchaseOrderItems.
     * @param {PurchaseOrderItemCreateManyArgs} args - Arguments to create many PurchaseOrderItems.
     * @example
     * // Create many PurchaseOrderItems
     * const purchaseOrderItem = await prisma.purchaseOrderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderItemCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseOrderItems and returns the data saved in the database.
     * @param {PurchaseOrderItemCreateManyAndReturnArgs} args - Arguments to create many PurchaseOrderItems.
     * @example
     * // Create many PurchaseOrderItems
     * const purchaseOrderItem = await prisma.purchaseOrderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseOrderItems and only return the `id`
     * const purchaseOrderItemWithIdOnly = await prisma.purchaseOrderItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseOrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseOrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PurchaseOrderItem.
     * @param {PurchaseOrderItemDeleteArgs} args - Arguments to delete one PurchaseOrderItem.
     * @example
     * // Delete one PurchaseOrderItem
     * const PurchaseOrderItem = await prisma.purchaseOrderItem.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrderItem
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderItemDeleteArgs>(args: SelectSubset<T, PurchaseOrderItemDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PurchaseOrderItem.
     * @param {PurchaseOrderItemUpdateArgs} args - Arguments to update one PurchaseOrderItem.
     * @example
     * // Update one PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderItemUpdateArgs>(args: SelectSubset<T, PurchaseOrderItemUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PurchaseOrderItems.
     * @param {PurchaseOrderItemDeleteManyArgs} args - Arguments to filter PurchaseOrderItems to delete.
     * @example
     * // Delete a few PurchaseOrderItems
     * const { count } = await prisma.purchaseOrderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderItemDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrderItems
     * const purchaseOrderItem = await prisma.purchaseOrderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderItemUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PurchaseOrderItem.
     * @param {PurchaseOrderItemUpsertArgs} args - Arguments to update or create a PurchaseOrderItem.
     * @example
     * // Update or create a PurchaseOrderItem
     * const purchaseOrderItem = await prisma.purchaseOrderItem.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrderItem we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderItemUpsertArgs>(args: SelectSubset<T, PurchaseOrderItemUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderItemClient<$Result.GetResult<Prisma.$PurchaseOrderItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PurchaseOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemCountArgs} args - Arguments to filter PurchaseOrderItems to count.
     * @example
     * // Count the number of PurchaseOrderItems
     * const count = await prisma.purchaseOrderItem.count({
     *   where: {
     *     // ... the filter for the PurchaseOrderItems we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderItemCountArgs>(
      args?: Subset<T, PurchaseOrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderItemAggregateArgs>(args: Subset<T, PurchaseOrderItemAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderItemAggregateType<T>>

    /**
     * Group by PurchaseOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderItemGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrderItem model
   */
  readonly fields: PurchaseOrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchase_order<T extends PurchaseOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderDefaultArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrderItem model
   */ 
  interface PurchaseOrderItemFieldRefs {
    readonly id: FieldRef<"PurchaseOrderItem", 'String'>
    readonly purchase_order_id: FieldRef<"PurchaseOrderItem", 'String'>
    readonly material_id: FieldRef<"PurchaseOrderItem", 'String'>
    readonly material_name: FieldRef<"PurchaseOrderItem", 'String'>
    readonly material_description: FieldRef<"PurchaseOrderItem", 'String'>
    readonly quantity: FieldRef<"PurchaseOrderItem", 'Float'>
    readonly unit_price: FieldRef<"PurchaseOrderItem", 'Float'>
    readonly total_price: FieldRef<"PurchaseOrderItem", 'Float'>
    readonly received_quantity: FieldRef<"PurchaseOrderItem", 'Float'>
    readonly unit: FieldRef<"PurchaseOrderItem", 'String'>
    readonly notes: FieldRef<"PurchaseOrderItem", 'String'>
    readonly created_at: FieldRef<"PurchaseOrderItem", 'DateTime'>
    readonly updated_at: FieldRef<"PurchaseOrderItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrderItem findUnique
   */
  export type PurchaseOrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem findUniqueOrThrow
   */
  export type PurchaseOrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem findFirst
   */
  export type PurchaseOrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrderItems.
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrderItems.
     */
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrderItem findFirstOrThrow
   */
  export type PurchaseOrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItem to fetch.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrderItems.
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrderItems.
     */
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrderItem findMany
   */
  export type PurchaseOrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrderItems to fetch.
     */
    where?: PurchaseOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrderItems to fetch.
     */
    orderBy?: PurchaseOrderItemOrderByWithRelationInput | PurchaseOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrderItems.
     */
    cursor?: PurchaseOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrderItems.
     */
    skip?: number
    distinct?: PurchaseOrderItemScalarFieldEnum | PurchaseOrderItemScalarFieldEnum[]
  }

  /**
   * PurchaseOrderItem create
   */
  export type PurchaseOrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrderItem.
     */
    data: XOR<PurchaseOrderItemCreateInput, PurchaseOrderItemUncheckedCreateInput>
  }

  /**
   * PurchaseOrderItem createMany
   */
  export type PurchaseOrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrderItems.
     */
    data: PurchaseOrderItemCreateManyInput | PurchaseOrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseOrderItem createManyAndReturn
   */
  export type PurchaseOrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PurchaseOrderItems.
     */
    data: PurchaseOrderItemCreateManyInput | PurchaseOrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrderItem update
   */
  export type PurchaseOrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrderItem.
     */
    data: XOR<PurchaseOrderItemUpdateInput, PurchaseOrderItemUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrderItem to update.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem updateMany
   */
  export type PurchaseOrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrderItems.
     */
    data: XOR<PurchaseOrderItemUpdateManyMutationInput, PurchaseOrderItemUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrderItems to update
     */
    where?: PurchaseOrderItemWhereInput
  }

  /**
   * PurchaseOrderItem upsert
   */
  export type PurchaseOrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrderItem to update in case it exists.
     */
    where: PurchaseOrderItemWhereUniqueInput
    /**
     * In case the PurchaseOrderItem found by the `where` argument doesn't exist, create a new PurchaseOrderItem with this data.
     */
    create: XOR<PurchaseOrderItemCreateInput, PurchaseOrderItemUncheckedCreateInput>
    /**
     * In case the PurchaseOrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderItemUpdateInput, PurchaseOrderItemUncheckedUpdateInput>
  }

  /**
   * PurchaseOrderItem delete
   */
  export type PurchaseOrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrderItem to delete.
     */
    where: PurchaseOrderItemWhereUniqueInput
  }

  /**
   * PurchaseOrderItem deleteMany
   */
  export type PurchaseOrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrderItems to delete
     */
    where?: PurchaseOrderItemWhereInput
  }

  /**
   * PurchaseOrderItem without action
   */
  export type PurchaseOrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderItem
     */
    select?: PurchaseOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderItemInclude<ExtArgs> | null
  }


  /**
   * Model CashFlowEntry
   */

  export type AggregateCashFlowEntry = {
    _count: CashFlowEntryCountAggregateOutputType | null
    _avg: CashFlowEntryAvgAggregateOutputType | null
    _sum: CashFlowEntrySumAggregateOutputType | null
    _min: CashFlowEntryMinAggregateOutputType | null
    _max: CashFlowEntryMaxAggregateOutputType | null
  }

  export type CashFlowEntryAvgAggregateOutputType = {
    amount: number | null
  }

  export type CashFlowEntrySumAggregateOutputType = {
    amount: number | null
  }

  export type CashFlowEntryMinAggregateOutputType = {
    id: string | null
    entry_date: Date | null
    description: string | null
    category: string | null
    entry_type: $Enums.CashFlowType | null
    amount: number | null
    source: string | null
    marketplace: string | null
    reference: string | null
    notes: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CashFlowEntryMaxAggregateOutputType = {
    id: string | null
    entry_date: Date | null
    description: string | null
    category: string | null
    entry_type: $Enums.CashFlowType | null
    amount: number | null
    source: string | null
    marketplace: string | null
    reference: string | null
    notes: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CashFlowEntryCountAggregateOutputType = {
    id: number
    entry_date: number
    description: number
    category: number
    entry_type: number
    amount: number
    source: number
    marketplace: number
    reference: number
    notes: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CashFlowEntryAvgAggregateInputType = {
    amount?: true
  }

  export type CashFlowEntrySumAggregateInputType = {
    amount?: true
  }

  export type CashFlowEntryMinAggregateInputType = {
    id?: true
    entry_date?: true
    description?: true
    category?: true
    entry_type?: true
    amount?: true
    source?: true
    marketplace?: true
    reference?: true
    notes?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type CashFlowEntryMaxAggregateInputType = {
    id?: true
    entry_date?: true
    description?: true
    category?: true
    entry_type?: true
    amount?: true
    source?: true
    marketplace?: true
    reference?: true
    notes?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type CashFlowEntryCountAggregateInputType = {
    id?: true
    entry_date?: true
    description?: true
    category?: true
    entry_type?: true
    amount?: true
    source?: true
    marketplace?: true
    reference?: true
    notes?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CashFlowEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashFlowEntry to aggregate.
     */
    where?: CashFlowEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashFlowEntries to fetch.
     */
    orderBy?: CashFlowEntryOrderByWithRelationInput | CashFlowEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashFlowEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashFlowEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashFlowEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashFlowEntries
    **/
    _count?: true | CashFlowEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashFlowEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashFlowEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashFlowEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashFlowEntryMaxAggregateInputType
  }

  export type GetCashFlowEntryAggregateType<T extends CashFlowEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateCashFlowEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashFlowEntry[P]>
      : GetScalarType<T[P], AggregateCashFlowEntry[P]>
  }




  export type CashFlowEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashFlowEntryWhereInput
    orderBy?: CashFlowEntryOrderByWithAggregationInput | CashFlowEntryOrderByWithAggregationInput[]
    by: CashFlowEntryScalarFieldEnum[] | CashFlowEntryScalarFieldEnum
    having?: CashFlowEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashFlowEntryCountAggregateInputType | true
    _avg?: CashFlowEntryAvgAggregateInputType
    _sum?: CashFlowEntrySumAggregateInputType
    _min?: CashFlowEntryMinAggregateInputType
    _max?: CashFlowEntryMaxAggregateInputType
  }

  export type CashFlowEntryGroupByOutputType = {
    id: string
    entry_date: Date
    description: string
    category: string
    entry_type: $Enums.CashFlowType
    amount: number
    source: string
    marketplace: string | null
    reference: string | null
    notes: string | null
    created_by: string | null
    created_at: Date
    updated_at: Date
    _count: CashFlowEntryCountAggregateOutputType | null
    _avg: CashFlowEntryAvgAggregateOutputType | null
    _sum: CashFlowEntrySumAggregateOutputType | null
    _min: CashFlowEntryMinAggregateOutputType | null
    _max: CashFlowEntryMaxAggregateOutputType | null
  }

  type GetCashFlowEntryGroupByPayload<T extends CashFlowEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashFlowEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashFlowEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashFlowEntryGroupByOutputType[P]>
            : GetScalarType<T[P], CashFlowEntryGroupByOutputType[P]>
        }
      >
    >


  export type CashFlowEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entry_date?: boolean
    description?: boolean
    category?: boolean
    entry_type?: boolean
    amount?: boolean
    source?: boolean
    marketplace?: boolean
    reference?: boolean
    notes?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["cashFlowEntry"]>

  export type CashFlowEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entry_date?: boolean
    description?: boolean
    category?: boolean
    entry_type?: boolean
    amount?: boolean
    source?: boolean
    marketplace?: boolean
    reference?: boolean
    notes?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["cashFlowEntry"]>

  export type CashFlowEntrySelectScalar = {
    id?: boolean
    entry_date?: boolean
    description?: boolean
    category?: boolean
    entry_type?: boolean
    amount?: boolean
    source?: boolean
    marketplace?: boolean
    reference?: boolean
    notes?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $CashFlowEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CashFlowEntry"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entry_date: Date
      description: string
      category: string
      entry_type: $Enums.CashFlowType
      amount: number
      source: string
      marketplace: string | null
      reference: string | null
      notes: string | null
      created_by: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["cashFlowEntry"]>
    composites: {}
  }

  type CashFlowEntryGetPayload<S extends boolean | null | undefined | CashFlowEntryDefaultArgs> = $Result.GetResult<Prisma.$CashFlowEntryPayload, S>

  type CashFlowEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CashFlowEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CashFlowEntryCountAggregateInputType | true
    }

  export interface CashFlowEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CashFlowEntry'], meta: { name: 'CashFlowEntry' } }
    /**
     * Find zero or one CashFlowEntry that matches the filter.
     * @param {CashFlowEntryFindUniqueArgs} args - Arguments to find a CashFlowEntry
     * @example
     * // Get one CashFlowEntry
     * const cashFlowEntry = await prisma.cashFlowEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CashFlowEntryFindUniqueArgs>(args: SelectSubset<T, CashFlowEntryFindUniqueArgs<ExtArgs>>): Prisma__CashFlowEntryClient<$Result.GetResult<Prisma.$CashFlowEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CashFlowEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CashFlowEntryFindUniqueOrThrowArgs} args - Arguments to find a CashFlowEntry
     * @example
     * // Get one CashFlowEntry
     * const cashFlowEntry = await prisma.cashFlowEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CashFlowEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, CashFlowEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CashFlowEntryClient<$Result.GetResult<Prisma.$CashFlowEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CashFlowEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashFlowEntryFindFirstArgs} args - Arguments to find a CashFlowEntry
     * @example
     * // Get one CashFlowEntry
     * const cashFlowEntry = await prisma.cashFlowEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CashFlowEntryFindFirstArgs>(args?: SelectSubset<T, CashFlowEntryFindFirstArgs<ExtArgs>>): Prisma__CashFlowEntryClient<$Result.GetResult<Prisma.$CashFlowEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CashFlowEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashFlowEntryFindFirstOrThrowArgs} args - Arguments to find a CashFlowEntry
     * @example
     * // Get one CashFlowEntry
     * const cashFlowEntry = await prisma.cashFlowEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CashFlowEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, CashFlowEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CashFlowEntryClient<$Result.GetResult<Prisma.$CashFlowEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CashFlowEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashFlowEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashFlowEntries
     * const cashFlowEntries = await prisma.cashFlowEntry.findMany()
     * 
     * // Get first 10 CashFlowEntries
     * const cashFlowEntries = await prisma.cashFlowEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashFlowEntryWithIdOnly = await prisma.cashFlowEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CashFlowEntryFindManyArgs>(args?: SelectSubset<T, CashFlowEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashFlowEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CashFlowEntry.
     * @param {CashFlowEntryCreateArgs} args - Arguments to create a CashFlowEntry.
     * @example
     * // Create one CashFlowEntry
     * const CashFlowEntry = await prisma.cashFlowEntry.create({
     *   data: {
     *     // ... data to create a CashFlowEntry
     *   }
     * })
     * 
     */
    create<T extends CashFlowEntryCreateArgs>(args: SelectSubset<T, CashFlowEntryCreateArgs<ExtArgs>>): Prisma__CashFlowEntryClient<$Result.GetResult<Prisma.$CashFlowEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CashFlowEntries.
     * @param {CashFlowEntryCreateManyArgs} args - Arguments to create many CashFlowEntries.
     * @example
     * // Create many CashFlowEntries
     * const cashFlowEntry = await prisma.cashFlowEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CashFlowEntryCreateManyArgs>(args?: SelectSubset<T, CashFlowEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CashFlowEntries and returns the data saved in the database.
     * @param {CashFlowEntryCreateManyAndReturnArgs} args - Arguments to create many CashFlowEntries.
     * @example
     * // Create many CashFlowEntries
     * const cashFlowEntry = await prisma.cashFlowEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CashFlowEntries and only return the `id`
     * const cashFlowEntryWithIdOnly = await prisma.cashFlowEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CashFlowEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, CashFlowEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashFlowEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CashFlowEntry.
     * @param {CashFlowEntryDeleteArgs} args - Arguments to delete one CashFlowEntry.
     * @example
     * // Delete one CashFlowEntry
     * const CashFlowEntry = await prisma.cashFlowEntry.delete({
     *   where: {
     *     // ... filter to delete one CashFlowEntry
     *   }
     * })
     * 
     */
    delete<T extends CashFlowEntryDeleteArgs>(args: SelectSubset<T, CashFlowEntryDeleteArgs<ExtArgs>>): Prisma__CashFlowEntryClient<$Result.GetResult<Prisma.$CashFlowEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CashFlowEntry.
     * @param {CashFlowEntryUpdateArgs} args - Arguments to update one CashFlowEntry.
     * @example
     * // Update one CashFlowEntry
     * const cashFlowEntry = await prisma.cashFlowEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CashFlowEntryUpdateArgs>(args: SelectSubset<T, CashFlowEntryUpdateArgs<ExtArgs>>): Prisma__CashFlowEntryClient<$Result.GetResult<Prisma.$CashFlowEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CashFlowEntries.
     * @param {CashFlowEntryDeleteManyArgs} args - Arguments to filter CashFlowEntries to delete.
     * @example
     * // Delete a few CashFlowEntries
     * const { count } = await prisma.cashFlowEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CashFlowEntryDeleteManyArgs>(args?: SelectSubset<T, CashFlowEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashFlowEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashFlowEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashFlowEntries
     * const cashFlowEntry = await prisma.cashFlowEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CashFlowEntryUpdateManyArgs>(args: SelectSubset<T, CashFlowEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CashFlowEntry.
     * @param {CashFlowEntryUpsertArgs} args - Arguments to update or create a CashFlowEntry.
     * @example
     * // Update or create a CashFlowEntry
     * const cashFlowEntry = await prisma.cashFlowEntry.upsert({
     *   create: {
     *     // ... data to create a CashFlowEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashFlowEntry we want to update
     *   }
     * })
     */
    upsert<T extends CashFlowEntryUpsertArgs>(args: SelectSubset<T, CashFlowEntryUpsertArgs<ExtArgs>>): Prisma__CashFlowEntryClient<$Result.GetResult<Prisma.$CashFlowEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CashFlowEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashFlowEntryCountArgs} args - Arguments to filter CashFlowEntries to count.
     * @example
     * // Count the number of CashFlowEntries
     * const count = await prisma.cashFlowEntry.count({
     *   where: {
     *     // ... the filter for the CashFlowEntries we want to count
     *   }
     * })
    **/
    count<T extends CashFlowEntryCountArgs>(
      args?: Subset<T, CashFlowEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashFlowEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashFlowEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashFlowEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashFlowEntryAggregateArgs>(args: Subset<T, CashFlowEntryAggregateArgs>): Prisma.PrismaPromise<GetCashFlowEntryAggregateType<T>>

    /**
     * Group by CashFlowEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashFlowEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashFlowEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashFlowEntryGroupByArgs['orderBy'] }
        : { orderBy?: CashFlowEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashFlowEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashFlowEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CashFlowEntry model
   */
  readonly fields: CashFlowEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashFlowEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashFlowEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CashFlowEntry model
   */ 
  interface CashFlowEntryFieldRefs {
    readonly id: FieldRef<"CashFlowEntry", 'String'>
    readonly entry_date: FieldRef<"CashFlowEntry", 'DateTime'>
    readonly description: FieldRef<"CashFlowEntry", 'String'>
    readonly category: FieldRef<"CashFlowEntry", 'String'>
    readonly entry_type: FieldRef<"CashFlowEntry", 'CashFlowType'>
    readonly amount: FieldRef<"CashFlowEntry", 'Float'>
    readonly source: FieldRef<"CashFlowEntry", 'String'>
    readonly marketplace: FieldRef<"CashFlowEntry", 'String'>
    readonly reference: FieldRef<"CashFlowEntry", 'String'>
    readonly notes: FieldRef<"CashFlowEntry", 'String'>
    readonly created_by: FieldRef<"CashFlowEntry", 'String'>
    readonly created_at: FieldRef<"CashFlowEntry", 'DateTime'>
    readonly updated_at: FieldRef<"CashFlowEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CashFlowEntry findUnique
   */
  export type CashFlowEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlowEntry
     */
    select?: CashFlowEntrySelect<ExtArgs> | null
    /**
     * Filter, which CashFlowEntry to fetch.
     */
    where: CashFlowEntryWhereUniqueInput
  }

  /**
   * CashFlowEntry findUniqueOrThrow
   */
  export type CashFlowEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlowEntry
     */
    select?: CashFlowEntrySelect<ExtArgs> | null
    /**
     * Filter, which CashFlowEntry to fetch.
     */
    where: CashFlowEntryWhereUniqueInput
  }

  /**
   * CashFlowEntry findFirst
   */
  export type CashFlowEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlowEntry
     */
    select?: CashFlowEntrySelect<ExtArgs> | null
    /**
     * Filter, which CashFlowEntry to fetch.
     */
    where?: CashFlowEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashFlowEntries to fetch.
     */
    orderBy?: CashFlowEntryOrderByWithRelationInput | CashFlowEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashFlowEntries.
     */
    cursor?: CashFlowEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashFlowEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashFlowEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashFlowEntries.
     */
    distinct?: CashFlowEntryScalarFieldEnum | CashFlowEntryScalarFieldEnum[]
  }

  /**
   * CashFlowEntry findFirstOrThrow
   */
  export type CashFlowEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlowEntry
     */
    select?: CashFlowEntrySelect<ExtArgs> | null
    /**
     * Filter, which CashFlowEntry to fetch.
     */
    where?: CashFlowEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashFlowEntries to fetch.
     */
    orderBy?: CashFlowEntryOrderByWithRelationInput | CashFlowEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashFlowEntries.
     */
    cursor?: CashFlowEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashFlowEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashFlowEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashFlowEntries.
     */
    distinct?: CashFlowEntryScalarFieldEnum | CashFlowEntryScalarFieldEnum[]
  }

  /**
   * CashFlowEntry findMany
   */
  export type CashFlowEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlowEntry
     */
    select?: CashFlowEntrySelect<ExtArgs> | null
    /**
     * Filter, which CashFlowEntries to fetch.
     */
    where?: CashFlowEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashFlowEntries to fetch.
     */
    orderBy?: CashFlowEntryOrderByWithRelationInput | CashFlowEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashFlowEntries.
     */
    cursor?: CashFlowEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashFlowEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashFlowEntries.
     */
    skip?: number
    distinct?: CashFlowEntryScalarFieldEnum | CashFlowEntryScalarFieldEnum[]
  }

  /**
   * CashFlowEntry create
   */
  export type CashFlowEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlowEntry
     */
    select?: CashFlowEntrySelect<ExtArgs> | null
    /**
     * The data needed to create a CashFlowEntry.
     */
    data: XOR<CashFlowEntryCreateInput, CashFlowEntryUncheckedCreateInput>
  }

  /**
   * CashFlowEntry createMany
   */
  export type CashFlowEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CashFlowEntries.
     */
    data: CashFlowEntryCreateManyInput | CashFlowEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CashFlowEntry createManyAndReturn
   */
  export type CashFlowEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlowEntry
     */
    select?: CashFlowEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CashFlowEntries.
     */
    data: CashFlowEntryCreateManyInput | CashFlowEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CashFlowEntry update
   */
  export type CashFlowEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlowEntry
     */
    select?: CashFlowEntrySelect<ExtArgs> | null
    /**
     * The data needed to update a CashFlowEntry.
     */
    data: XOR<CashFlowEntryUpdateInput, CashFlowEntryUncheckedUpdateInput>
    /**
     * Choose, which CashFlowEntry to update.
     */
    where: CashFlowEntryWhereUniqueInput
  }

  /**
   * CashFlowEntry updateMany
   */
  export type CashFlowEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CashFlowEntries.
     */
    data: XOR<CashFlowEntryUpdateManyMutationInput, CashFlowEntryUncheckedUpdateManyInput>
    /**
     * Filter which CashFlowEntries to update
     */
    where?: CashFlowEntryWhereInput
  }

  /**
   * CashFlowEntry upsert
   */
  export type CashFlowEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlowEntry
     */
    select?: CashFlowEntrySelect<ExtArgs> | null
    /**
     * The filter to search for the CashFlowEntry to update in case it exists.
     */
    where: CashFlowEntryWhereUniqueInput
    /**
     * In case the CashFlowEntry found by the `where` argument doesn't exist, create a new CashFlowEntry with this data.
     */
    create: XOR<CashFlowEntryCreateInput, CashFlowEntryUncheckedCreateInput>
    /**
     * In case the CashFlowEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashFlowEntryUpdateInput, CashFlowEntryUncheckedUpdateInput>
  }

  /**
   * CashFlowEntry delete
   */
  export type CashFlowEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlowEntry
     */
    select?: CashFlowEntrySelect<ExtArgs> | null
    /**
     * Filter which CashFlowEntry to delete.
     */
    where: CashFlowEntryWhereUniqueInput
  }

  /**
   * CashFlowEntry deleteMany
   */
  export type CashFlowEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashFlowEntries to delete
     */
    where?: CashFlowEntryWhereInput
  }

  /**
   * CashFlowEntry without action
   */
  export type CashFlowEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashFlowEntry
     */
    select?: CashFlowEntrySelect<ExtArgs> | null
  }


  /**
   * Model DashboardMetrics
   */

  export type AggregateDashboardMetrics = {
    _count: DashboardMetricsCountAggregateOutputType | null
    _avg: DashboardMetricsAvgAggregateOutputType | null
    _sum: DashboardMetricsSumAggregateOutputType | null
    _min: DashboardMetricsMinAggregateOutputType | null
    _max: DashboardMetricsMaxAggregateOutputType | null
  }

  export type DashboardMetricsAvgAggregateOutputType = {
    distinct_orders: number | null
    total_quantity_sold: number | null
    total_revenue: number | null
    total_profit: number | null
    total_hpp: number | null
    profit_margin: number | null
    average_order_value: number | null
    total_sales_records: number | null
    today_revenue: number | null
    today_orders: number | null
    month_revenue: number | null
    month_orders: number | null
    total_products: number | null
    low_stock_products: number | null
    out_of_stock_products: number | null
    total_categories: number | null
    total_brands: number | null
  }

  export type DashboardMetricsSumAggregateOutputType = {
    distinct_orders: number | null
    total_quantity_sold: number | null
    total_revenue: number | null
    total_profit: number | null
    total_hpp: number | null
    profit_margin: number | null
    average_order_value: number | null
    total_sales_records: number | null
    today_revenue: number | null
    today_orders: number | null
    month_revenue: number | null
    month_orders: number | null
    total_products: number | null
    low_stock_products: number | null
    out_of_stock_products: number | null
    total_categories: number | null
    total_brands: number | null
  }

  export type DashboardMetricsMinAggregateOutputType = {
    id: string | null
    metric_date: Date | null
    distinct_orders: number | null
    total_quantity_sold: number | null
    total_revenue: number | null
    total_profit: number | null
    total_hpp: number | null
    profit_margin: number | null
    average_order_value: number | null
    total_sales_records: number | null
    today_revenue: number | null
    today_orders: number | null
    month_revenue: number | null
    month_orders: number | null
    total_products: number | null
    low_stock_products: number | null
    out_of_stock_products: number | null
    total_categories: number | null
    total_brands: number | null
    calculated_at: Date | null
  }

  export type DashboardMetricsMaxAggregateOutputType = {
    id: string | null
    metric_date: Date | null
    distinct_orders: number | null
    total_quantity_sold: number | null
    total_revenue: number | null
    total_profit: number | null
    total_hpp: number | null
    profit_margin: number | null
    average_order_value: number | null
    total_sales_records: number | null
    today_revenue: number | null
    today_orders: number | null
    month_revenue: number | null
    month_orders: number | null
    total_products: number | null
    low_stock_products: number | null
    out_of_stock_products: number | null
    total_categories: number | null
    total_brands: number | null
    calculated_at: Date | null
  }

  export type DashboardMetricsCountAggregateOutputType = {
    id: number
    metric_date: number
    distinct_orders: number
    total_quantity_sold: number
    total_revenue: number
    total_profit: number
    total_hpp: number
    profit_margin: number
    average_order_value: number
    total_sales_records: number
    today_revenue: number
    today_orders: number
    month_revenue: number
    month_orders: number
    total_products: number
    low_stock_products: number
    out_of_stock_products: number
    total_categories: number
    total_brands: number
    calculated_at: number
    _all: number
  }


  export type DashboardMetricsAvgAggregateInputType = {
    distinct_orders?: true
    total_quantity_sold?: true
    total_revenue?: true
    total_profit?: true
    total_hpp?: true
    profit_margin?: true
    average_order_value?: true
    total_sales_records?: true
    today_revenue?: true
    today_orders?: true
    month_revenue?: true
    month_orders?: true
    total_products?: true
    low_stock_products?: true
    out_of_stock_products?: true
    total_categories?: true
    total_brands?: true
  }

  export type DashboardMetricsSumAggregateInputType = {
    distinct_orders?: true
    total_quantity_sold?: true
    total_revenue?: true
    total_profit?: true
    total_hpp?: true
    profit_margin?: true
    average_order_value?: true
    total_sales_records?: true
    today_revenue?: true
    today_orders?: true
    month_revenue?: true
    month_orders?: true
    total_products?: true
    low_stock_products?: true
    out_of_stock_products?: true
    total_categories?: true
    total_brands?: true
  }

  export type DashboardMetricsMinAggregateInputType = {
    id?: true
    metric_date?: true
    distinct_orders?: true
    total_quantity_sold?: true
    total_revenue?: true
    total_profit?: true
    total_hpp?: true
    profit_margin?: true
    average_order_value?: true
    total_sales_records?: true
    today_revenue?: true
    today_orders?: true
    month_revenue?: true
    month_orders?: true
    total_products?: true
    low_stock_products?: true
    out_of_stock_products?: true
    total_categories?: true
    total_brands?: true
    calculated_at?: true
  }

  export type DashboardMetricsMaxAggregateInputType = {
    id?: true
    metric_date?: true
    distinct_orders?: true
    total_quantity_sold?: true
    total_revenue?: true
    total_profit?: true
    total_hpp?: true
    profit_margin?: true
    average_order_value?: true
    total_sales_records?: true
    today_revenue?: true
    today_orders?: true
    month_revenue?: true
    month_orders?: true
    total_products?: true
    low_stock_products?: true
    out_of_stock_products?: true
    total_categories?: true
    total_brands?: true
    calculated_at?: true
  }

  export type DashboardMetricsCountAggregateInputType = {
    id?: true
    metric_date?: true
    distinct_orders?: true
    total_quantity_sold?: true
    total_revenue?: true
    total_profit?: true
    total_hpp?: true
    profit_margin?: true
    average_order_value?: true
    total_sales_records?: true
    today_revenue?: true
    today_orders?: true
    month_revenue?: true
    month_orders?: true
    total_products?: true
    low_stock_products?: true
    out_of_stock_products?: true
    total_categories?: true
    total_brands?: true
    calculated_at?: true
    _all?: true
  }

  export type DashboardMetricsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DashboardMetrics to aggregate.
     */
    where?: DashboardMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardMetrics to fetch.
     */
    orderBy?: DashboardMetricsOrderByWithRelationInput | DashboardMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DashboardMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DashboardMetrics
    **/
    _count?: true | DashboardMetricsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DashboardMetricsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DashboardMetricsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DashboardMetricsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DashboardMetricsMaxAggregateInputType
  }

  export type GetDashboardMetricsAggregateType<T extends DashboardMetricsAggregateArgs> = {
        [P in keyof T & keyof AggregateDashboardMetrics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDashboardMetrics[P]>
      : GetScalarType<T[P], AggregateDashboardMetrics[P]>
  }




  export type DashboardMetricsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DashboardMetricsWhereInput
    orderBy?: DashboardMetricsOrderByWithAggregationInput | DashboardMetricsOrderByWithAggregationInput[]
    by: DashboardMetricsScalarFieldEnum[] | DashboardMetricsScalarFieldEnum
    having?: DashboardMetricsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DashboardMetricsCountAggregateInputType | true
    _avg?: DashboardMetricsAvgAggregateInputType
    _sum?: DashboardMetricsSumAggregateInputType
    _min?: DashboardMetricsMinAggregateInputType
    _max?: DashboardMetricsMaxAggregateInputType
  }

  export type DashboardMetricsGroupByOutputType = {
    id: string
    metric_date: Date
    distinct_orders: number
    total_quantity_sold: number
    total_revenue: number
    total_profit: number
    total_hpp: number
    profit_margin: number
    average_order_value: number
    total_sales_records: number
    today_revenue: number
    today_orders: number
    month_revenue: number
    month_orders: number
    total_products: number
    low_stock_products: number
    out_of_stock_products: number
    total_categories: number
    total_brands: number
    calculated_at: Date
    _count: DashboardMetricsCountAggregateOutputType | null
    _avg: DashboardMetricsAvgAggregateOutputType | null
    _sum: DashboardMetricsSumAggregateOutputType | null
    _min: DashboardMetricsMinAggregateOutputType | null
    _max: DashboardMetricsMaxAggregateOutputType | null
  }

  type GetDashboardMetricsGroupByPayload<T extends DashboardMetricsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DashboardMetricsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DashboardMetricsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DashboardMetricsGroupByOutputType[P]>
            : GetScalarType<T[P], DashboardMetricsGroupByOutputType[P]>
        }
      >
    >


  export type DashboardMetricsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metric_date?: boolean
    distinct_orders?: boolean
    total_quantity_sold?: boolean
    total_revenue?: boolean
    total_profit?: boolean
    total_hpp?: boolean
    profit_margin?: boolean
    average_order_value?: boolean
    total_sales_records?: boolean
    today_revenue?: boolean
    today_orders?: boolean
    month_revenue?: boolean
    month_orders?: boolean
    total_products?: boolean
    low_stock_products?: boolean
    out_of_stock_products?: boolean
    total_categories?: boolean
    total_brands?: boolean
    calculated_at?: boolean
  }, ExtArgs["result"]["dashboardMetrics"]>

  export type DashboardMetricsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metric_date?: boolean
    distinct_orders?: boolean
    total_quantity_sold?: boolean
    total_revenue?: boolean
    total_profit?: boolean
    total_hpp?: boolean
    profit_margin?: boolean
    average_order_value?: boolean
    total_sales_records?: boolean
    today_revenue?: boolean
    today_orders?: boolean
    month_revenue?: boolean
    month_orders?: boolean
    total_products?: boolean
    low_stock_products?: boolean
    out_of_stock_products?: boolean
    total_categories?: boolean
    total_brands?: boolean
    calculated_at?: boolean
  }, ExtArgs["result"]["dashboardMetrics"]>

  export type DashboardMetricsSelectScalar = {
    id?: boolean
    metric_date?: boolean
    distinct_orders?: boolean
    total_quantity_sold?: boolean
    total_revenue?: boolean
    total_profit?: boolean
    total_hpp?: boolean
    profit_margin?: boolean
    average_order_value?: boolean
    total_sales_records?: boolean
    today_revenue?: boolean
    today_orders?: boolean
    month_revenue?: boolean
    month_orders?: boolean
    total_products?: boolean
    low_stock_products?: boolean
    out_of_stock_products?: boolean
    total_categories?: boolean
    total_brands?: boolean
    calculated_at?: boolean
  }


  export type $DashboardMetricsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DashboardMetrics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      metric_date: Date
      distinct_orders: number
      total_quantity_sold: number
      total_revenue: number
      total_profit: number
      total_hpp: number
      profit_margin: number
      average_order_value: number
      total_sales_records: number
      today_revenue: number
      today_orders: number
      month_revenue: number
      month_orders: number
      total_products: number
      low_stock_products: number
      out_of_stock_products: number
      total_categories: number
      total_brands: number
      calculated_at: Date
    }, ExtArgs["result"]["dashboardMetrics"]>
    composites: {}
  }

  type DashboardMetricsGetPayload<S extends boolean | null | undefined | DashboardMetricsDefaultArgs> = $Result.GetResult<Prisma.$DashboardMetricsPayload, S>

  type DashboardMetricsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DashboardMetricsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DashboardMetricsCountAggregateInputType | true
    }

  export interface DashboardMetricsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DashboardMetrics'], meta: { name: 'DashboardMetrics' } }
    /**
     * Find zero or one DashboardMetrics that matches the filter.
     * @param {DashboardMetricsFindUniqueArgs} args - Arguments to find a DashboardMetrics
     * @example
     * // Get one DashboardMetrics
     * const dashboardMetrics = await prisma.dashboardMetrics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DashboardMetricsFindUniqueArgs>(args: SelectSubset<T, DashboardMetricsFindUniqueArgs<ExtArgs>>): Prisma__DashboardMetricsClient<$Result.GetResult<Prisma.$DashboardMetricsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DashboardMetrics that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DashboardMetricsFindUniqueOrThrowArgs} args - Arguments to find a DashboardMetrics
     * @example
     * // Get one DashboardMetrics
     * const dashboardMetrics = await prisma.dashboardMetrics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DashboardMetricsFindUniqueOrThrowArgs>(args: SelectSubset<T, DashboardMetricsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DashboardMetricsClient<$Result.GetResult<Prisma.$DashboardMetricsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DashboardMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardMetricsFindFirstArgs} args - Arguments to find a DashboardMetrics
     * @example
     * // Get one DashboardMetrics
     * const dashboardMetrics = await prisma.dashboardMetrics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DashboardMetricsFindFirstArgs>(args?: SelectSubset<T, DashboardMetricsFindFirstArgs<ExtArgs>>): Prisma__DashboardMetricsClient<$Result.GetResult<Prisma.$DashboardMetricsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DashboardMetrics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardMetricsFindFirstOrThrowArgs} args - Arguments to find a DashboardMetrics
     * @example
     * // Get one DashboardMetrics
     * const dashboardMetrics = await prisma.dashboardMetrics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DashboardMetricsFindFirstOrThrowArgs>(args?: SelectSubset<T, DashboardMetricsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DashboardMetricsClient<$Result.GetResult<Prisma.$DashboardMetricsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DashboardMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardMetricsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DashboardMetrics
     * const dashboardMetrics = await prisma.dashboardMetrics.findMany()
     * 
     * // Get first 10 DashboardMetrics
     * const dashboardMetrics = await prisma.dashboardMetrics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dashboardMetricsWithIdOnly = await prisma.dashboardMetrics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DashboardMetricsFindManyArgs>(args?: SelectSubset<T, DashboardMetricsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardMetricsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DashboardMetrics.
     * @param {DashboardMetricsCreateArgs} args - Arguments to create a DashboardMetrics.
     * @example
     * // Create one DashboardMetrics
     * const DashboardMetrics = await prisma.dashboardMetrics.create({
     *   data: {
     *     // ... data to create a DashboardMetrics
     *   }
     * })
     * 
     */
    create<T extends DashboardMetricsCreateArgs>(args: SelectSubset<T, DashboardMetricsCreateArgs<ExtArgs>>): Prisma__DashboardMetricsClient<$Result.GetResult<Prisma.$DashboardMetricsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DashboardMetrics.
     * @param {DashboardMetricsCreateManyArgs} args - Arguments to create many DashboardMetrics.
     * @example
     * // Create many DashboardMetrics
     * const dashboardMetrics = await prisma.dashboardMetrics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DashboardMetricsCreateManyArgs>(args?: SelectSubset<T, DashboardMetricsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DashboardMetrics and returns the data saved in the database.
     * @param {DashboardMetricsCreateManyAndReturnArgs} args - Arguments to create many DashboardMetrics.
     * @example
     * // Create many DashboardMetrics
     * const dashboardMetrics = await prisma.dashboardMetrics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DashboardMetrics and only return the `id`
     * const dashboardMetricsWithIdOnly = await prisma.dashboardMetrics.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DashboardMetricsCreateManyAndReturnArgs>(args?: SelectSubset<T, DashboardMetricsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DashboardMetricsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DashboardMetrics.
     * @param {DashboardMetricsDeleteArgs} args - Arguments to delete one DashboardMetrics.
     * @example
     * // Delete one DashboardMetrics
     * const DashboardMetrics = await prisma.dashboardMetrics.delete({
     *   where: {
     *     // ... filter to delete one DashboardMetrics
     *   }
     * })
     * 
     */
    delete<T extends DashboardMetricsDeleteArgs>(args: SelectSubset<T, DashboardMetricsDeleteArgs<ExtArgs>>): Prisma__DashboardMetricsClient<$Result.GetResult<Prisma.$DashboardMetricsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DashboardMetrics.
     * @param {DashboardMetricsUpdateArgs} args - Arguments to update one DashboardMetrics.
     * @example
     * // Update one DashboardMetrics
     * const dashboardMetrics = await prisma.dashboardMetrics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DashboardMetricsUpdateArgs>(args: SelectSubset<T, DashboardMetricsUpdateArgs<ExtArgs>>): Prisma__DashboardMetricsClient<$Result.GetResult<Prisma.$DashboardMetricsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DashboardMetrics.
     * @param {DashboardMetricsDeleteManyArgs} args - Arguments to filter DashboardMetrics to delete.
     * @example
     * // Delete a few DashboardMetrics
     * const { count } = await prisma.dashboardMetrics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DashboardMetricsDeleteManyArgs>(args?: SelectSubset<T, DashboardMetricsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DashboardMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardMetricsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DashboardMetrics
     * const dashboardMetrics = await prisma.dashboardMetrics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DashboardMetricsUpdateManyArgs>(args: SelectSubset<T, DashboardMetricsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DashboardMetrics.
     * @param {DashboardMetricsUpsertArgs} args - Arguments to update or create a DashboardMetrics.
     * @example
     * // Update or create a DashboardMetrics
     * const dashboardMetrics = await prisma.dashboardMetrics.upsert({
     *   create: {
     *     // ... data to create a DashboardMetrics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DashboardMetrics we want to update
     *   }
     * })
     */
    upsert<T extends DashboardMetricsUpsertArgs>(args: SelectSubset<T, DashboardMetricsUpsertArgs<ExtArgs>>): Prisma__DashboardMetricsClient<$Result.GetResult<Prisma.$DashboardMetricsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DashboardMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardMetricsCountArgs} args - Arguments to filter DashboardMetrics to count.
     * @example
     * // Count the number of DashboardMetrics
     * const count = await prisma.dashboardMetrics.count({
     *   where: {
     *     // ... the filter for the DashboardMetrics we want to count
     *   }
     * })
    **/
    count<T extends DashboardMetricsCountArgs>(
      args?: Subset<T, DashboardMetricsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DashboardMetricsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DashboardMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardMetricsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DashboardMetricsAggregateArgs>(args: Subset<T, DashboardMetricsAggregateArgs>): Prisma.PrismaPromise<GetDashboardMetricsAggregateType<T>>

    /**
     * Group by DashboardMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DashboardMetricsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DashboardMetricsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DashboardMetricsGroupByArgs['orderBy'] }
        : { orderBy?: DashboardMetricsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DashboardMetricsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDashboardMetricsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DashboardMetrics model
   */
  readonly fields: DashboardMetricsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DashboardMetrics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DashboardMetricsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DashboardMetrics model
   */ 
  interface DashboardMetricsFieldRefs {
    readonly id: FieldRef<"DashboardMetrics", 'String'>
    readonly metric_date: FieldRef<"DashboardMetrics", 'DateTime'>
    readonly distinct_orders: FieldRef<"DashboardMetrics", 'Int'>
    readonly total_quantity_sold: FieldRef<"DashboardMetrics", 'Int'>
    readonly total_revenue: FieldRef<"DashboardMetrics", 'Float'>
    readonly total_profit: FieldRef<"DashboardMetrics", 'Float'>
    readonly total_hpp: FieldRef<"DashboardMetrics", 'Float'>
    readonly profit_margin: FieldRef<"DashboardMetrics", 'Float'>
    readonly average_order_value: FieldRef<"DashboardMetrics", 'Float'>
    readonly total_sales_records: FieldRef<"DashboardMetrics", 'Int'>
    readonly today_revenue: FieldRef<"DashboardMetrics", 'Float'>
    readonly today_orders: FieldRef<"DashboardMetrics", 'Int'>
    readonly month_revenue: FieldRef<"DashboardMetrics", 'Float'>
    readonly month_orders: FieldRef<"DashboardMetrics", 'Int'>
    readonly total_products: FieldRef<"DashboardMetrics", 'Int'>
    readonly low_stock_products: FieldRef<"DashboardMetrics", 'Int'>
    readonly out_of_stock_products: FieldRef<"DashboardMetrics", 'Int'>
    readonly total_categories: FieldRef<"DashboardMetrics", 'Int'>
    readonly total_brands: FieldRef<"DashboardMetrics", 'Int'>
    readonly calculated_at: FieldRef<"DashboardMetrics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DashboardMetrics findUnique
   */
  export type DashboardMetricsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardMetrics
     */
    select?: DashboardMetricsSelect<ExtArgs> | null
    /**
     * Filter, which DashboardMetrics to fetch.
     */
    where: DashboardMetricsWhereUniqueInput
  }

  /**
   * DashboardMetrics findUniqueOrThrow
   */
  export type DashboardMetricsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardMetrics
     */
    select?: DashboardMetricsSelect<ExtArgs> | null
    /**
     * Filter, which DashboardMetrics to fetch.
     */
    where: DashboardMetricsWhereUniqueInput
  }

  /**
   * DashboardMetrics findFirst
   */
  export type DashboardMetricsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardMetrics
     */
    select?: DashboardMetricsSelect<ExtArgs> | null
    /**
     * Filter, which DashboardMetrics to fetch.
     */
    where?: DashboardMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardMetrics to fetch.
     */
    orderBy?: DashboardMetricsOrderByWithRelationInput | DashboardMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DashboardMetrics.
     */
    cursor?: DashboardMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DashboardMetrics.
     */
    distinct?: DashboardMetricsScalarFieldEnum | DashboardMetricsScalarFieldEnum[]
  }

  /**
   * DashboardMetrics findFirstOrThrow
   */
  export type DashboardMetricsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardMetrics
     */
    select?: DashboardMetricsSelect<ExtArgs> | null
    /**
     * Filter, which DashboardMetrics to fetch.
     */
    where?: DashboardMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardMetrics to fetch.
     */
    orderBy?: DashboardMetricsOrderByWithRelationInput | DashboardMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DashboardMetrics.
     */
    cursor?: DashboardMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DashboardMetrics.
     */
    distinct?: DashboardMetricsScalarFieldEnum | DashboardMetricsScalarFieldEnum[]
  }

  /**
   * DashboardMetrics findMany
   */
  export type DashboardMetricsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardMetrics
     */
    select?: DashboardMetricsSelect<ExtArgs> | null
    /**
     * Filter, which DashboardMetrics to fetch.
     */
    where?: DashboardMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DashboardMetrics to fetch.
     */
    orderBy?: DashboardMetricsOrderByWithRelationInput | DashboardMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DashboardMetrics.
     */
    cursor?: DashboardMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DashboardMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DashboardMetrics.
     */
    skip?: number
    distinct?: DashboardMetricsScalarFieldEnum | DashboardMetricsScalarFieldEnum[]
  }

  /**
   * DashboardMetrics create
   */
  export type DashboardMetricsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardMetrics
     */
    select?: DashboardMetricsSelect<ExtArgs> | null
    /**
     * The data needed to create a DashboardMetrics.
     */
    data: XOR<DashboardMetricsCreateInput, DashboardMetricsUncheckedCreateInput>
  }

  /**
   * DashboardMetrics createMany
   */
  export type DashboardMetricsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DashboardMetrics.
     */
    data: DashboardMetricsCreateManyInput | DashboardMetricsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DashboardMetrics createManyAndReturn
   */
  export type DashboardMetricsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardMetrics
     */
    select?: DashboardMetricsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DashboardMetrics.
     */
    data: DashboardMetricsCreateManyInput | DashboardMetricsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DashboardMetrics update
   */
  export type DashboardMetricsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardMetrics
     */
    select?: DashboardMetricsSelect<ExtArgs> | null
    /**
     * The data needed to update a DashboardMetrics.
     */
    data: XOR<DashboardMetricsUpdateInput, DashboardMetricsUncheckedUpdateInput>
    /**
     * Choose, which DashboardMetrics to update.
     */
    where: DashboardMetricsWhereUniqueInput
  }

  /**
   * DashboardMetrics updateMany
   */
  export type DashboardMetricsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DashboardMetrics.
     */
    data: XOR<DashboardMetricsUpdateManyMutationInput, DashboardMetricsUncheckedUpdateManyInput>
    /**
     * Filter which DashboardMetrics to update
     */
    where?: DashboardMetricsWhereInput
  }

  /**
   * DashboardMetrics upsert
   */
  export type DashboardMetricsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardMetrics
     */
    select?: DashboardMetricsSelect<ExtArgs> | null
    /**
     * The filter to search for the DashboardMetrics to update in case it exists.
     */
    where: DashboardMetricsWhereUniqueInput
    /**
     * In case the DashboardMetrics found by the `where` argument doesn't exist, create a new DashboardMetrics with this data.
     */
    create: XOR<DashboardMetricsCreateInput, DashboardMetricsUncheckedCreateInput>
    /**
     * In case the DashboardMetrics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DashboardMetricsUpdateInput, DashboardMetricsUncheckedUpdateInput>
  }

  /**
   * DashboardMetrics delete
   */
  export type DashboardMetricsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardMetrics
     */
    select?: DashboardMetricsSelect<ExtArgs> | null
    /**
     * Filter which DashboardMetrics to delete.
     */
    where: DashboardMetricsWhereUniqueInput
  }

  /**
   * DashboardMetrics deleteMany
   */
  export type DashboardMetricsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DashboardMetrics to delete
     */
    where?: DashboardMetricsWhereInput
  }

  /**
   * DashboardMetrics without action
   */
  export type DashboardMetricsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DashboardMetrics
     */
    select?: DashboardMetricsSelect<ExtArgs> | null
  }


  /**
   * Model ImportHistory
   */

  export type AggregateImportHistory = {
    _count: ImportHistoryCountAggregateOutputType | null
    _avg: ImportHistoryAvgAggregateOutputType | null
    _sum: ImportHistorySumAggregateOutputType | null
    _min: ImportHistoryMinAggregateOutputType | null
    _max: ImportHistoryMaxAggregateOutputType | null
  }

  export type ImportHistoryAvgAggregateOutputType = {
    file_size: number | null
    total_records: number | null
    imported_records: number | null
    failed_records: number | null
    duplicate_records: number | null
    success_rate: number | null
    processing_time_ms: number | null
  }

  export type ImportHistorySumAggregateOutputType = {
    file_size: number | null
    total_records: number | null
    imported_records: number | null
    failed_records: number | null
    duplicate_records: number | null
    success_rate: number | null
    processing_time_ms: number | null
  }

  export type ImportHistoryMinAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    user_id: string | null
    import_type: string | null
    file_name: string | null
    file_size: number | null
    file_hash: string | null
    total_records: number | null
    imported_records: number | null
    failed_records: number | null
    duplicate_records: number | null
    success_rate: number | null
    processing_time_ms: number | null
    import_status: $Enums.ImportHistoryStatus | null
    error_details: string | null
    source_ip: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ImportHistoryMaxAggregateOutputType = {
    id: string | null
    timestamp: Date | null
    user_id: string | null
    import_type: string | null
    file_name: string | null
    file_size: number | null
    file_hash: string | null
    total_records: number | null
    imported_records: number | null
    failed_records: number | null
    duplicate_records: number | null
    success_rate: number | null
    processing_time_ms: number | null
    import_status: $Enums.ImportHistoryStatus | null
    error_details: string | null
    source_ip: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ImportHistoryCountAggregateOutputType = {
    id: number
    timestamp: number
    user_id: number
    import_type: number
    file_name: number
    file_size: number
    file_hash: number
    total_records: number
    imported_records: number
    failed_records: number
    duplicate_records: number
    success_rate: number
    processing_time_ms: number
    import_status: number
    error_details: number
    import_summary: number
    metadata: number
    source_ip: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ImportHistoryAvgAggregateInputType = {
    file_size?: true
    total_records?: true
    imported_records?: true
    failed_records?: true
    duplicate_records?: true
    success_rate?: true
    processing_time_ms?: true
  }

  export type ImportHistorySumAggregateInputType = {
    file_size?: true
    total_records?: true
    imported_records?: true
    failed_records?: true
    duplicate_records?: true
    success_rate?: true
    processing_time_ms?: true
  }

  export type ImportHistoryMinAggregateInputType = {
    id?: true
    timestamp?: true
    user_id?: true
    import_type?: true
    file_name?: true
    file_size?: true
    file_hash?: true
    total_records?: true
    imported_records?: true
    failed_records?: true
    duplicate_records?: true
    success_rate?: true
    processing_time_ms?: true
    import_status?: true
    error_details?: true
    source_ip?: true
    created_at?: true
    updated_at?: true
  }

  export type ImportHistoryMaxAggregateInputType = {
    id?: true
    timestamp?: true
    user_id?: true
    import_type?: true
    file_name?: true
    file_size?: true
    file_hash?: true
    total_records?: true
    imported_records?: true
    failed_records?: true
    duplicate_records?: true
    success_rate?: true
    processing_time_ms?: true
    import_status?: true
    error_details?: true
    source_ip?: true
    created_at?: true
    updated_at?: true
  }

  export type ImportHistoryCountAggregateInputType = {
    id?: true
    timestamp?: true
    user_id?: true
    import_type?: true
    file_name?: true
    file_size?: true
    file_hash?: true
    total_records?: true
    imported_records?: true
    failed_records?: true
    duplicate_records?: true
    success_rate?: true
    processing_time_ms?: true
    import_status?: true
    error_details?: true
    import_summary?: true
    metadata?: true
    source_ip?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ImportHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportHistory to aggregate.
     */
    where?: ImportHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportHistories to fetch.
     */
    orderBy?: ImportHistoryOrderByWithRelationInput | ImportHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImportHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImportHistories
    **/
    _count?: true | ImportHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImportHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImportHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImportHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImportHistoryMaxAggregateInputType
  }

  export type GetImportHistoryAggregateType<T extends ImportHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateImportHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImportHistory[P]>
      : GetScalarType<T[P], AggregateImportHistory[P]>
  }




  export type ImportHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImportHistoryWhereInput
    orderBy?: ImportHistoryOrderByWithAggregationInput | ImportHistoryOrderByWithAggregationInput[]
    by: ImportHistoryScalarFieldEnum[] | ImportHistoryScalarFieldEnum
    having?: ImportHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImportHistoryCountAggregateInputType | true
    _avg?: ImportHistoryAvgAggregateInputType
    _sum?: ImportHistorySumAggregateInputType
    _min?: ImportHistoryMinAggregateInputType
    _max?: ImportHistoryMaxAggregateInputType
  }

  export type ImportHistoryGroupByOutputType = {
    id: string
    timestamp: Date
    user_id: string | null
    import_type: string
    file_name: string | null
    file_size: number | null
    file_hash: string | null
    total_records: number
    imported_records: number
    failed_records: number
    duplicate_records: number
    success_rate: number | null
    processing_time_ms: number | null
    import_status: $Enums.ImportHistoryStatus
    error_details: string | null
    import_summary: JsonValue | null
    metadata: JsonValue | null
    source_ip: string | null
    created_at: Date
    updated_at: Date
    _count: ImportHistoryCountAggregateOutputType | null
    _avg: ImportHistoryAvgAggregateOutputType | null
    _sum: ImportHistorySumAggregateOutputType | null
    _min: ImportHistoryMinAggregateOutputType | null
    _max: ImportHistoryMaxAggregateOutputType | null
  }

  type GetImportHistoryGroupByPayload<T extends ImportHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImportHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImportHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImportHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], ImportHistoryGroupByOutputType[P]>
        }
      >
    >


  export type ImportHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    user_id?: boolean
    import_type?: boolean
    file_name?: boolean
    file_size?: boolean
    file_hash?: boolean
    total_records?: boolean
    imported_records?: boolean
    failed_records?: boolean
    duplicate_records?: boolean
    success_rate?: boolean
    processing_time_ms?: boolean
    import_status?: boolean
    error_details?: boolean
    import_summary?: boolean
    metadata?: boolean
    source_ip?: boolean
    created_at?: boolean
    updated_at?: boolean
    importMetadata?: boolean | ImportHistory$importMetadataArgs<ExtArgs>
    _count?: boolean | ImportHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["importHistory"]>

  export type ImportHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    user_id?: boolean
    import_type?: boolean
    file_name?: boolean
    file_size?: boolean
    file_hash?: boolean
    total_records?: boolean
    imported_records?: boolean
    failed_records?: boolean
    duplicate_records?: boolean
    success_rate?: boolean
    processing_time_ms?: boolean
    import_status?: boolean
    error_details?: boolean
    import_summary?: boolean
    metadata?: boolean
    source_ip?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["importHistory"]>

  export type ImportHistorySelectScalar = {
    id?: boolean
    timestamp?: boolean
    user_id?: boolean
    import_type?: boolean
    file_name?: boolean
    file_size?: boolean
    file_hash?: boolean
    total_records?: boolean
    imported_records?: boolean
    failed_records?: boolean
    duplicate_records?: boolean
    success_rate?: boolean
    processing_time_ms?: boolean
    import_status?: boolean
    error_details?: boolean
    import_summary?: boolean
    metadata?: boolean
    source_ip?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ImportHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    importMetadata?: boolean | ImportHistory$importMetadataArgs<ExtArgs>
    _count?: boolean | ImportHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ImportHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ImportHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImportHistory"
    objects: {
      importMetadata: Prisma.$ImportMetadataPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      timestamp: Date
      user_id: string | null
      import_type: string
      file_name: string | null
      file_size: number | null
      file_hash: string | null
      total_records: number
      imported_records: number
      failed_records: number
      duplicate_records: number
      success_rate: number | null
      processing_time_ms: number | null
      import_status: $Enums.ImportHistoryStatus
      error_details: string | null
      import_summary: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      source_ip: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["importHistory"]>
    composites: {}
  }

  type ImportHistoryGetPayload<S extends boolean | null | undefined | ImportHistoryDefaultArgs> = $Result.GetResult<Prisma.$ImportHistoryPayload, S>

  type ImportHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ImportHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ImportHistoryCountAggregateInputType | true
    }

  export interface ImportHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImportHistory'], meta: { name: 'ImportHistory' } }
    /**
     * Find zero or one ImportHistory that matches the filter.
     * @param {ImportHistoryFindUniqueArgs} args - Arguments to find a ImportHistory
     * @example
     * // Get one ImportHistory
     * const importHistory = await prisma.importHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImportHistoryFindUniqueArgs>(args: SelectSubset<T, ImportHistoryFindUniqueArgs<ExtArgs>>): Prisma__ImportHistoryClient<$Result.GetResult<Prisma.$ImportHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ImportHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ImportHistoryFindUniqueOrThrowArgs} args - Arguments to find a ImportHistory
     * @example
     * // Get one ImportHistory
     * const importHistory = await prisma.importHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImportHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ImportHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImportHistoryClient<$Result.GetResult<Prisma.$ImportHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ImportHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportHistoryFindFirstArgs} args - Arguments to find a ImportHistory
     * @example
     * // Get one ImportHistory
     * const importHistory = await prisma.importHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImportHistoryFindFirstArgs>(args?: SelectSubset<T, ImportHistoryFindFirstArgs<ExtArgs>>): Prisma__ImportHistoryClient<$Result.GetResult<Prisma.$ImportHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ImportHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportHistoryFindFirstOrThrowArgs} args - Arguments to find a ImportHistory
     * @example
     * // Get one ImportHistory
     * const importHistory = await prisma.importHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImportHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ImportHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImportHistoryClient<$Result.GetResult<Prisma.$ImportHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ImportHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImportHistories
     * const importHistories = await prisma.importHistory.findMany()
     * 
     * // Get first 10 ImportHistories
     * const importHistories = await prisma.importHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const importHistoryWithIdOnly = await prisma.importHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImportHistoryFindManyArgs>(args?: SelectSubset<T, ImportHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ImportHistory.
     * @param {ImportHistoryCreateArgs} args - Arguments to create a ImportHistory.
     * @example
     * // Create one ImportHistory
     * const ImportHistory = await prisma.importHistory.create({
     *   data: {
     *     // ... data to create a ImportHistory
     *   }
     * })
     * 
     */
    create<T extends ImportHistoryCreateArgs>(args: SelectSubset<T, ImportHistoryCreateArgs<ExtArgs>>): Prisma__ImportHistoryClient<$Result.GetResult<Prisma.$ImportHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ImportHistories.
     * @param {ImportHistoryCreateManyArgs} args - Arguments to create many ImportHistories.
     * @example
     * // Create many ImportHistories
     * const importHistory = await prisma.importHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImportHistoryCreateManyArgs>(args?: SelectSubset<T, ImportHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ImportHistories and returns the data saved in the database.
     * @param {ImportHistoryCreateManyAndReturnArgs} args - Arguments to create many ImportHistories.
     * @example
     * // Create many ImportHistories
     * const importHistory = await prisma.importHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ImportHistories and only return the `id`
     * const importHistoryWithIdOnly = await prisma.importHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImportHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ImportHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ImportHistory.
     * @param {ImportHistoryDeleteArgs} args - Arguments to delete one ImportHistory.
     * @example
     * // Delete one ImportHistory
     * const ImportHistory = await prisma.importHistory.delete({
     *   where: {
     *     // ... filter to delete one ImportHistory
     *   }
     * })
     * 
     */
    delete<T extends ImportHistoryDeleteArgs>(args: SelectSubset<T, ImportHistoryDeleteArgs<ExtArgs>>): Prisma__ImportHistoryClient<$Result.GetResult<Prisma.$ImportHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ImportHistory.
     * @param {ImportHistoryUpdateArgs} args - Arguments to update one ImportHistory.
     * @example
     * // Update one ImportHistory
     * const importHistory = await prisma.importHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImportHistoryUpdateArgs>(args: SelectSubset<T, ImportHistoryUpdateArgs<ExtArgs>>): Prisma__ImportHistoryClient<$Result.GetResult<Prisma.$ImportHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ImportHistories.
     * @param {ImportHistoryDeleteManyArgs} args - Arguments to filter ImportHistories to delete.
     * @example
     * // Delete a few ImportHistories
     * const { count } = await prisma.importHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImportHistoryDeleteManyArgs>(args?: SelectSubset<T, ImportHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImportHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImportHistories
     * const importHistory = await prisma.importHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImportHistoryUpdateManyArgs>(args: SelectSubset<T, ImportHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ImportHistory.
     * @param {ImportHistoryUpsertArgs} args - Arguments to update or create a ImportHistory.
     * @example
     * // Update or create a ImportHistory
     * const importHistory = await prisma.importHistory.upsert({
     *   create: {
     *     // ... data to create a ImportHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImportHistory we want to update
     *   }
     * })
     */
    upsert<T extends ImportHistoryUpsertArgs>(args: SelectSubset<T, ImportHistoryUpsertArgs<ExtArgs>>): Prisma__ImportHistoryClient<$Result.GetResult<Prisma.$ImportHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ImportHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportHistoryCountArgs} args - Arguments to filter ImportHistories to count.
     * @example
     * // Count the number of ImportHistories
     * const count = await prisma.importHistory.count({
     *   where: {
     *     // ... the filter for the ImportHistories we want to count
     *   }
     * })
    **/
    count<T extends ImportHistoryCountArgs>(
      args?: Subset<T, ImportHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImportHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImportHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImportHistoryAggregateArgs>(args: Subset<T, ImportHistoryAggregateArgs>): Prisma.PrismaPromise<GetImportHistoryAggregateType<T>>

    /**
     * Group by ImportHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImportHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImportHistoryGroupByArgs['orderBy'] }
        : { orderBy?: ImportHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImportHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImportHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImportHistory model
   */
  readonly fields: ImportHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImportHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImportHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    importMetadata<T extends ImportHistory$importMetadataArgs<ExtArgs> = {}>(args?: Subset<T, ImportHistory$importMetadataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportMetadataPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImportHistory model
   */ 
  interface ImportHistoryFieldRefs {
    readonly id: FieldRef<"ImportHistory", 'String'>
    readonly timestamp: FieldRef<"ImportHistory", 'DateTime'>
    readonly user_id: FieldRef<"ImportHistory", 'String'>
    readonly import_type: FieldRef<"ImportHistory", 'String'>
    readonly file_name: FieldRef<"ImportHistory", 'String'>
    readonly file_size: FieldRef<"ImportHistory", 'Int'>
    readonly file_hash: FieldRef<"ImportHistory", 'String'>
    readonly total_records: FieldRef<"ImportHistory", 'Int'>
    readonly imported_records: FieldRef<"ImportHistory", 'Int'>
    readonly failed_records: FieldRef<"ImportHistory", 'Int'>
    readonly duplicate_records: FieldRef<"ImportHistory", 'Int'>
    readonly success_rate: FieldRef<"ImportHistory", 'Float'>
    readonly processing_time_ms: FieldRef<"ImportHistory", 'Int'>
    readonly import_status: FieldRef<"ImportHistory", 'ImportHistoryStatus'>
    readonly error_details: FieldRef<"ImportHistory", 'String'>
    readonly import_summary: FieldRef<"ImportHistory", 'Json'>
    readonly metadata: FieldRef<"ImportHistory", 'Json'>
    readonly source_ip: FieldRef<"ImportHistory", 'String'>
    readonly created_at: FieldRef<"ImportHistory", 'DateTime'>
    readonly updated_at: FieldRef<"ImportHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ImportHistory findUnique
   */
  export type ImportHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportHistory
     */
    select?: ImportHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ImportHistory to fetch.
     */
    where: ImportHistoryWhereUniqueInput
  }

  /**
   * ImportHistory findUniqueOrThrow
   */
  export type ImportHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportHistory
     */
    select?: ImportHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ImportHistory to fetch.
     */
    where: ImportHistoryWhereUniqueInput
  }

  /**
   * ImportHistory findFirst
   */
  export type ImportHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportHistory
     */
    select?: ImportHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ImportHistory to fetch.
     */
    where?: ImportHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportHistories to fetch.
     */
    orderBy?: ImportHistoryOrderByWithRelationInput | ImportHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportHistories.
     */
    cursor?: ImportHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportHistories.
     */
    distinct?: ImportHistoryScalarFieldEnum | ImportHistoryScalarFieldEnum[]
  }

  /**
   * ImportHistory findFirstOrThrow
   */
  export type ImportHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportHistory
     */
    select?: ImportHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ImportHistory to fetch.
     */
    where?: ImportHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportHistories to fetch.
     */
    orderBy?: ImportHistoryOrderByWithRelationInput | ImportHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportHistories.
     */
    cursor?: ImportHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportHistories.
     */
    distinct?: ImportHistoryScalarFieldEnum | ImportHistoryScalarFieldEnum[]
  }

  /**
   * ImportHistory findMany
   */
  export type ImportHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportHistory
     */
    select?: ImportHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ImportHistories to fetch.
     */
    where?: ImportHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportHistories to fetch.
     */
    orderBy?: ImportHistoryOrderByWithRelationInput | ImportHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImportHistories.
     */
    cursor?: ImportHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportHistories.
     */
    skip?: number
    distinct?: ImportHistoryScalarFieldEnum | ImportHistoryScalarFieldEnum[]
  }

  /**
   * ImportHistory create
   */
  export type ImportHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportHistory
     */
    select?: ImportHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ImportHistory.
     */
    data: XOR<ImportHistoryCreateInput, ImportHistoryUncheckedCreateInput>
  }

  /**
   * ImportHistory createMany
   */
  export type ImportHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImportHistories.
     */
    data: ImportHistoryCreateManyInput | ImportHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ImportHistory createManyAndReturn
   */
  export type ImportHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportHistory
     */
    select?: ImportHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ImportHistories.
     */
    data: ImportHistoryCreateManyInput | ImportHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ImportHistory update
   */
  export type ImportHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportHistory
     */
    select?: ImportHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ImportHistory.
     */
    data: XOR<ImportHistoryUpdateInput, ImportHistoryUncheckedUpdateInput>
    /**
     * Choose, which ImportHistory to update.
     */
    where: ImportHistoryWhereUniqueInput
  }

  /**
   * ImportHistory updateMany
   */
  export type ImportHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImportHistories.
     */
    data: XOR<ImportHistoryUpdateManyMutationInput, ImportHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ImportHistories to update
     */
    where?: ImportHistoryWhereInput
  }

  /**
   * ImportHistory upsert
   */
  export type ImportHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportHistory
     */
    select?: ImportHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ImportHistory to update in case it exists.
     */
    where: ImportHistoryWhereUniqueInput
    /**
     * In case the ImportHistory found by the `where` argument doesn't exist, create a new ImportHistory with this data.
     */
    create: XOR<ImportHistoryCreateInput, ImportHistoryUncheckedCreateInput>
    /**
     * In case the ImportHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImportHistoryUpdateInput, ImportHistoryUncheckedUpdateInput>
  }

  /**
   * ImportHistory delete
   */
  export type ImportHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportHistory
     */
    select?: ImportHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportHistoryInclude<ExtArgs> | null
    /**
     * Filter which ImportHistory to delete.
     */
    where: ImportHistoryWhereUniqueInput
  }

  /**
   * ImportHistory deleteMany
   */
  export type ImportHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportHistories to delete
     */
    where?: ImportHistoryWhereInput
  }

  /**
   * ImportHistory.importMetadata
   */
  export type ImportHistory$importMetadataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportMetadata
     */
    select?: ImportMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportMetadataInclude<ExtArgs> | null
    where?: ImportMetadataWhereInput
    orderBy?: ImportMetadataOrderByWithRelationInput | ImportMetadataOrderByWithRelationInput[]
    cursor?: ImportMetadataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImportMetadataScalarFieldEnum | ImportMetadataScalarFieldEnum[]
  }

  /**
   * ImportHistory without action
   */
  export type ImportHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportHistory
     */
    select?: ImportHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    subtotal: number | null
    tax: number | null
    discount: number | null
    total: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    subtotal: number | null
    tax: number | null
    discount: number | null
    total: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    invoice_number: string | null
    customer_name: string | null
    customer_email: string | null
    customer_phone: string | null
    issue_date: Date | null
    due_date: Date | null
    status: $Enums.InvoiceStatus | null
    type: $Enums.InvoiceType | null
    subtotal: number | null
    tax: number | null
    discount: number | null
    total: number | null
    notes: string | null
    payment_method: string | null
    payment_date: Date | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    invoice_number: string | null
    customer_name: string | null
    customer_email: string | null
    customer_phone: string | null
    issue_date: Date | null
    due_date: Date | null
    status: $Enums.InvoiceStatus | null
    type: $Enums.InvoiceType | null
    subtotal: number | null
    tax: number | null
    discount: number | null
    total: number | null
    notes: string | null
    payment_method: string | null
    payment_date: Date | null
    created_at: Date | null
    updated_at: Date | null
    created_by: string | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    invoice_number: number
    customer_name: number
    customer_email: number
    customer_phone: number
    issue_date: number
    due_date: number
    status: number
    type: number
    subtotal: number
    tax: number
    discount: number
    total: number
    notes: number
    payment_method: number
    payment_date: number
    created_at: number
    updated_at: number
    created_by: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    subtotal?: true
    tax?: true
    discount?: true
    total?: true
  }

  export type InvoiceSumAggregateInputType = {
    subtotal?: true
    tax?: true
    discount?: true
    total?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    invoice_number?: true
    customer_name?: true
    customer_email?: true
    customer_phone?: true
    issue_date?: true
    due_date?: true
    status?: true
    type?: true
    subtotal?: true
    tax?: true
    discount?: true
    total?: true
    notes?: true
    payment_method?: true
    payment_date?: true
    created_at?: true
    updated_at?: true
    created_by?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    invoice_number?: true
    customer_name?: true
    customer_email?: true
    customer_phone?: true
    issue_date?: true
    due_date?: true
    status?: true
    type?: true
    subtotal?: true
    tax?: true
    discount?: true
    total?: true
    notes?: true
    payment_method?: true
    payment_date?: true
    created_at?: true
    updated_at?: true
    created_by?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    invoice_number?: true
    customer_name?: true
    customer_email?: true
    customer_phone?: true
    issue_date?: true
    due_date?: true
    status?: true
    type?: true
    subtotal?: true
    tax?: true
    discount?: true
    total?: true
    notes?: true
    payment_method?: true
    payment_date?: true
    created_at?: true
    updated_at?: true
    created_by?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    invoice_number: string
    customer_name: string
    customer_email: string
    customer_phone: string | null
    issue_date: Date
    due_date: Date
    status: $Enums.InvoiceStatus
    type: $Enums.InvoiceType
    subtotal: number
    tax: number
    discount: number
    total: number
    notes: string | null
    payment_method: string | null
    payment_date: Date | null
    created_at: Date
    updated_at: Date
    created_by: string | null
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_number?: boolean
    customer_name?: boolean
    customer_email?: boolean
    customer_phone?: boolean
    issue_date?: boolean
    due_date?: boolean
    status?: boolean
    type?: boolean
    subtotal?: boolean
    tax?: boolean
    discount?: boolean
    total?: boolean
    notes?: boolean
    payment_method?: boolean
    payment_date?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_number?: boolean
    customer_name?: boolean
    customer_email?: boolean
    customer_phone?: boolean
    issue_date?: boolean
    due_date?: boolean
    status?: boolean
    type?: boolean
    subtotal?: boolean
    tax?: boolean
    discount?: boolean
    total?: boolean
    notes?: boolean
    payment_method?: boolean
    payment_date?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    invoice_number?: boolean
    customer_name?: boolean
    customer_email?: boolean
    customer_phone?: boolean
    issue_date?: boolean
    due_date?: boolean
    status?: boolean
    type?: boolean
    subtotal?: boolean
    tax?: boolean
    discount?: boolean
    total?: boolean
    notes?: boolean
    payment_method?: boolean
    payment_date?: boolean
    created_at?: boolean
    updated_at?: boolean
    created_by?: boolean
  }

  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      items: Prisma.$InvoiceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoice_number: string
      customer_name: string
      customer_email: string
      customer_phone: string | null
      issue_date: Date
      due_date: Date
      status: $Enums.InvoiceStatus
      type: $Enums.InvoiceType
      subtotal: number
      tax: number
      discount: number
      total: number
      notes: string | null
      payment_method: string | null
      payment_date: Date | null
      created_at: Date
      updated_at: Date
      created_by: string | null
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends Invoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */ 
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly invoice_number: FieldRef<"Invoice", 'String'>
    readonly customer_name: FieldRef<"Invoice", 'String'>
    readonly customer_email: FieldRef<"Invoice", 'String'>
    readonly customer_phone: FieldRef<"Invoice", 'String'>
    readonly issue_date: FieldRef<"Invoice", 'DateTime'>
    readonly due_date: FieldRef<"Invoice", 'DateTime'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
    readonly type: FieldRef<"Invoice", 'InvoiceType'>
    readonly subtotal: FieldRef<"Invoice", 'Float'>
    readonly tax: FieldRef<"Invoice", 'Float'>
    readonly discount: FieldRef<"Invoice", 'Float'>
    readonly total: FieldRef<"Invoice", 'Float'>
    readonly notes: FieldRef<"Invoice", 'String'>
    readonly payment_method: FieldRef<"Invoice", 'String'>
    readonly payment_date: FieldRef<"Invoice", 'DateTime'>
    readonly created_at: FieldRef<"Invoice", 'DateTime'>
    readonly updated_at: FieldRef<"Invoice", 'DateTime'>
    readonly created_by: FieldRef<"Invoice", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice.items
   */
  export type Invoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceItem
   */

  export type AggregateInvoiceItem = {
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  export type InvoiceItemAvgAggregateOutputType = {
    quantity: number | null
    unit_price: number | null
    total: number | null
  }

  export type InvoiceItemSumAggregateOutputType = {
    quantity: number | null
    unit_price: number | null
    total: number | null
  }

  export type InvoiceItemMinAggregateOutputType = {
    id: string | null
    invoice_id: string | null
    product_name: string | null
    quantity: number | null
    unit_price: number | null
    total: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type InvoiceItemMaxAggregateOutputType = {
    id: string | null
    invoice_id: string | null
    product_name: string | null
    quantity: number | null
    unit_price: number | null
    total: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type InvoiceItemCountAggregateOutputType = {
    id: number
    invoice_id: number
    product_name: number
    quantity: number
    unit_price: number
    total: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type InvoiceItemAvgAggregateInputType = {
    quantity?: true
    unit_price?: true
    total?: true
  }

  export type InvoiceItemSumAggregateInputType = {
    quantity?: true
    unit_price?: true
    total?: true
  }

  export type InvoiceItemMinAggregateInputType = {
    id?: true
    invoice_id?: true
    product_name?: true
    quantity?: true
    unit_price?: true
    total?: true
    created_at?: true
    updated_at?: true
  }

  export type InvoiceItemMaxAggregateInputType = {
    id?: true
    invoice_id?: true
    product_name?: true
    quantity?: true
    unit_price?: true
    total?: true
    created_at?: true
    updated_at?: true
  }

  export type InvoiceItemCountAggregateInputType = {
    id?: true
    invoice_id?: true
    product_name?: true
    quantity?: true
    unit_price?: true
    total?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type InvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItem to aggregate.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceItems
    **/
    _count?: true | InvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type GetInvoiceItemAggregateType<T extends InvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceItem[P]>
      : GetScalarType<T[P], AggregateInvoiceItem[P]>
  }




  export type InvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithAggregationInput | InvoiceItemOrderByWithAggregationInput[]
    by: InvoiceItemScalarFieldEnum[] | InvoiceItemScalarFieldEnum
    having?: InvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceItemCountAggregateInputType | true
    _avg?: InvoiceItemAvgAggregateInputType
    _sum?: InvoiceItemSumAggregateInputType
    _min?: InvoiceItemMinAggregateInputType
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type InvoiceItemGroupByOutputType = {
    id: string
    invoice_id: string
    product_name: string
    quantity: number
    unit_price: number
    total: number
    created_at: Date
    updated_at: Date
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  type GetInvoiceItemGroupByPayload<T extends InvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_id?: boolean
    product_name?: boolean
    quantity?: boolean
    unit_price?: boolean
    total?: boolean
    created_at?: boolean
    updated_at?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_id?: boolean
    product_name?: boolean
    quantity?: boolean
    unit_price?: boolean
    total?: boolean
    created_at?: boolean
    updated_at?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectScalar = {
    id?: boolean
    invoice_id?: boolean
    product_name?: boolean
    quantity?: boolean
    unit_price?: boolean
    total?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type InvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $InvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceItem"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoice_id: string
      product_name: string
      quantity: number
      unit_price: number
      total: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["invoiceItem"]>
    composites: {}
  }

  type InvoiceItemGetPayload<S extends boolean | null | undefined | InvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$InvoiceItemPayload, S>

  type InvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceItemCountAggregateInputType | true
    }

  export interface InvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceItem'], meta: { name: 'InvoiceItem' } }
    /**
     * Find zero or one InvoiceItem that matches the filter.
     * @param {InvoiceItemFindUniqueArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceItemFindUniqueArgs>(args: SelectSubset<T, InvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InvoiceItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceItemFindFirstArgs>(args?: SelectSubset<T, InvoiceItemFindFirstArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany()
     * 
     * // Get first 10 InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceItemFindManyArgs>(args?: SelectSubset<T, InvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InvoiceItem.
     * @param {InvoiceItemCreateArgs} args - Arguments to create a InvoiceItem.
     * @example
     * // Create one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.create({
     *   data: {
     *     // ... data to create a InvoiceItem
     *   }
     * })
     * 
     */
    create<T extends InvoiceItemCreateArgs>(args: SelectSubset<T, InvoiceItemCreateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InvoiceItems.
     * @param {InvoiceItemCreateManyArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceItemCreateManyArgs>(args?: SelectSubset<T, InvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceItems and returns the data saved in the database.
     * @param {InvoiceItemCreateManyAndReturnArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceItems and only return the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InvoiceItem.
     * @param {InvoiceItemDeleteArgs} args - Arguments to delete one InvoiceItem.
     * @example
     * // Delete one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.delete({
     *   where: {
     *     // ... filter to delete one InvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends InvoiceItemDeleteArgs>(args: SelectSubset<T, InvoiceItemDeleteArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InvoiceItem.
     * @param {InvoiceItemUpdateArgs} args - Arguments to update one InvoiceItem.
     * @example
     * // Update one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceItemUpdateArgs>(args: SelectSubset<T, InvoiceItemUpdateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InvoiceItems.
     * @param {InvoiceItemDeleteManyArgs} args - Arguments to filter InvoiceItems to delete.
     * @example
     * // Delete a few InvoiceItems
     * const { count } = await prisma.invoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceItemDeleteManyArgs>(args?: SelectSubset<T, InvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceItemUpdateManyArgs>(args: SelectSubset<T, InvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvoiceItem.
     * @param {InvoiceItemUpsertArgs} args - Arguments to update or create a InvoiceItem.
     * @example
     * // Update or create a InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.upsert({
     *   create: {
     *     // ... data to create a InvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceItemUpsertArgs>(args: SelectSubset<T, InvoiceItemUpsertArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemCountArgs} args - Arguments to filter InvoiceItems to count.
     * @example
     * // Count the number of InvoiceItems
     * const count = await prisma.invoiceItem.count({
     *   where: {
     *     // ... the filter for the InvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends InvoiceItemCountArgs>(
      args?: Subset<T, InvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceItemAggregateArgs>(args: Subset<T, InvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetInvoiceItemAggregateType<T>>

    /**
     * Group by InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceItem model
   */
  readonly fields: InvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceItem model
   */ 
  interface InvoiceItemFieldRefs {
    readonly id: FieldRef<"InvoiceItem", 'String'>
    readonly invoice_id: FieldRef<"InvoiceItem", 'String'>
    readonly product_name: FieldRef<"InvoiceItem", 'String'>
    readonly quantity: FieldRef<"InvoiceItem", 'Int'>
    readonly unit_price: FieldRef<"InvoiceItem", 'Float'>
    readonly total: FieldRef<"InvoiceItem", 'Float'>
    readonly created_at: FieldRef<"InvoiceItem", 'DateTime'>
    readonly updated_at: FieldRef<"InvoiceItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceItem findUnique
   */
  export type InvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findUniqueOrThrow
   */
  export type InvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findFirst
   */
  export type InvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findFirstOrThrow
   */
  export type InvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findMany
   */
  export type InvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItems to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem create
   */
  export type InvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceItem.
     */
    data: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
  }

  /**
   * InvoiceItem createMany
   */
  export type InvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceItem createManyAndReturn
   */
  export type InvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceItem update
   */
  export type InvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceItem.
     */
    data: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which InvoiceItem to update.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem updateMany
   */
  export type InvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceItem upsert
   */
  export type InvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceItem to update in case it exists.
     */
    where: InvoiceItemWhereUniqueInput
    /**
     * In case the InvoiceItem found by the `where` argument doesn't exist, create a new InvoiceItem with this data.
     */
    create: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
    /**
     * In case the InvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
  }

  /**
   * InvoiceItem delete
   */
  export type InvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which InvoiceItem to delete.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem deleteMany
   */
  export type InvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItems to delete
     */
    where?: InvoiceItemWhereInput
  }

  /**
   * InvoiceItem without action
   */
  export type InvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model AffiliateEndorsement
   */

  export type AggregateAffiliateEndorsement = {
    _count: AffiliateEndorsementCountAggregateOutputType | null
    _avg: AffiliateEndorsementAvgAggregateOutputType | null
    _sum: AffiliateEndorsementSumAggregateOutputType | null
    _min: AffiliateEndorsementMinAggregateOutputType | null
    _max: AffiliateEndorsementMaxAggregateOutputType | null
  }

  export type AffiliateEndorsementAvgAggregateOutputType = {
    endorse_fee: number | null
    target_sales: number | null
    actual_sales: number | null
    total_commission: number | null
    followers: number | null
    engagement: number | null
    roi: number | null
  }

  export type AffiliateEndorsementSumAggregateOutputType = {
    endorse_fee: number | null
    target_sales: number | null
    actual_sales: number | null
    total_commission: number | null
    followers: number | null
    engagement: number | null
    roi: number | null
  }

  export type AffiliateEndorsementMinAggregateOutputType = {
    id: string | null
    campaign_name: string | null
    affiliate_name: string | null
    affiliate_type: string | null
    start_date: Date | null
    end_date: Date | null
    endorse_fee: number | null
    target_sales: number | null
    actual_sales: number | null
    total_commission: number | null
    payment_method: string | null
    content_type: string | null
    followers: number | null
    engagement: number | null
    reference: string | null
    notes: string | null
    status: string | null
    roi: number | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AffiliateEndorsementMaxAggregateOutputType = {
    id: string | null
    campaign_name: string | null
    affiliate_name: string | null
    affiliate_type: string | null
    start_date: Date | null
    end_date: Date | null
    endorse_fee: number | null
    target_sales: number | null
    actual_sales: number | null
    total_commission: number | null
    payment_method: string | null
    content_type: string | null
    followers: number | null
    engagement: number | null
    reference: string | null
    notes: string | null
    status: string | null
    roi: number | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AffiliateEndorsementCountAggregateOutputType = {
    id: number
    campaign_name: number
    affiliate_name: number
    affiliate_type: number
    start_date: number
    end_date: number
    endorse_fee: number
    target_sales: number
    actual_sales: number
    total_commission: number
    payment_method: number
    platform: number
    content_type: number
    followers: number
    engagement: number
    reference: number
    notes: number
    status: number
    roi: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AffiliateEndorsementAvgAggregateInputType = {
    endorse_fee?: true
    target_sales?: true
    actual_sales?: true
    total_commission?: true
    followers?: true
    engagement?: true
    roi?: true
  }

  export type AffiliateEndorsementSumAggregateInputType = {
    endorse_fee?: true
    target_sales?: true
    actual_sales?: true
    total_commission?: true
    followers?: true
    engagement?: true
    roi?: true
  }

  export type AffiliateEndorsementMinAggregateInputType = {
    id?: true
    campaign_name?: true
    affiliate_name?: true
    affiliate_type?: true
    start_date?: true
    end_date?: true
    endorse_fee?: true
    target_sales?: true
    actual_sales?: true
    total_commission?: true
    payment_method?: true
    content_type?: true
    followers?: true
    engagement?: true
    reference?: true
    notes?: true
    status?: true
    roi?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type AffiliateEndorsementMaxAggregateInputType = {
    id?: true
    campaign_name?: true
    affiliate_name?: true
    affiliate_type?: true
    start_date?: true
    end_date?: true
    endorse_fee?: true
    target_sales?: true
    actual_sales?: true
    total_commission?: true
    payment_method?: true
    content_type?: true
    followers?: true
    engagement?: true
    reference?: true
    notes?: true
    status?: true
    roi?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type AffiliateEndorsementCountAggregateInputType = {
    id?: true
    campaign_name?: true
    affiliate_name?: true
    affiliate_type?: true
    start_date?: true
    end_date?: true
    endorse_fee?: true
    target_sales?: true
    actual_sales?: true
    total_commission?: true
    payment_method?: true
    platform?: true
    content_type?: true
    followers?: true
    engagement?: true
    reference?: true
    notes?: true
    status?: true
    roi?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AffiliateEndorsementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AffiliateEndorsement to aggregate.
     */
    where?: AffiliateEndorsementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateEndorsements to fetch.
     */
    orderBy?: AffiliateEndorsementOrderByWithRelationInput | AffiliateEndorsementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AffiliateEndorsementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateEndorsements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateEndorsements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AffiliateEndorsements
    **/
    _count?: true | AffiliateEndorsementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AffiliateEndorsementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AffiliateEndorsementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AffiliateEndorsementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AffiliateEndorsementMaxAggregateInputType
  }

  export type GetAffiliateEndorsementAggregateType<T extends AffiliateEndorsementAggregateArgs> = {
        [P in keyof T & keyof AggregateAffiliateEndorsement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAffiliateEndorsement[P]>
      : GetScalarType<T[P], AggregateAffiliateEndorsement[P]>
  }




  export type AffiliateEndorsementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateEndorsementWhereInput
    orderBy?: AffiliateEndorsementOrderByWithAggregationInput | AffiliateEndorsementOrderByWithAggregationInput[]
    by: AffiliateEndorsementScalarFieldEnum[] | AffiliateEndorsementScalarFieldEnum
    having?: AffiliateEndorsementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AffiliateEndorsementCountAggregateInputType | true
    _avg?: AffiliateEndorsementAvgAggregateInputType
    _sum?: AffiliateEndorsementSumAggregateInputType
    _min?: AffiliateEndorsementMinAggregateInputType
    _max?: AffiliateEndorsementMaxAggregateInputType
  }

  export type AffiliateEndorsementGroupByOutputType = {
    id: string
    campaign_name: string
    affiliate_name: string
    affiliate_type: string
    start_date: Date
    end_date: Date
    endorse_fee: number
    target_sales: number
    actual_sales: number
    total_commission: number
    payment_method: string | null
    platform: string[]
    content_type: string | null
    followers: number | null
    engagement: number | null
    reference: string | null
    notes: string | null
    status: string
    roi: number | null
    created_by: string | null
    created_at: Date
    updated_at: Date
    _count: AffiliateEndorsementCountAggregateOutputType | null
    _avg: AffiliateEndorsementAvgAggregateOutputType | null
    _sum: AffiliateEndorsementSumAggregateOutputType | null
    _min: AffiliateEndorsementMinAggregateOutputType | null
    _max: AffiliateEndorsementMaxAggregateOutputType | null
  }

  type GetAffiliateEndorsementGroupByPayload<T extends AffiliateEndorsementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AffiliateEndorsementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AffiliateEndorsementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AffiliateEndorsementGroupByOutputType[P]>
            : GetScalarType<T[P], AffiliateEndorsementGroupByOutputType[P]>
        }
      >
    >


  export type AffiliateEndorsementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaign_name?: boolean
    affiliate_name?: boolean
    affiliate_type?: boolean
    start_date?: boolean
    end_date?: boolean
    endorse_fee?: boolean
    target_sales?: boolean
    actual_sales?: boolean
    total_commission?: boolean
    payment_method?: boolean
    platform?: boolean
    content_type?: boolean
    followers?: boolean
    engagement?: boolean
    reference?: boolean
    notes?: boolean
    status?: boolean
    roi?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    product_sales?: boolean | AffiliateEndorsement$product_salesArgs<ExtArgs>
    _count?: boolean | AffiliateEndorsementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliateEndorsement"]>

  export type AffiliateEndorsementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaign_name?: boolean
    affiliate_name?: boolean
    affiliate_type?: boolean
    start_date?: boolean
    end_date?: boolean
    endorse_fee?: boolean
    target_sales?: boolean
    actual_sales?: boolean
    total_commission?: boolean
    payment_method?: boolean
    platform?: boolean
    content_type?: boolean
    followers?: boolean
    engagement?: boolean
    reference?: boolean
    notes?: boolean
    status?: boolean
    roi?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["affiliateEndorsement"]>

  export type AffiliateEndorsementSelectScalar = {
    id?: boolean
    campaign_name?: boolean
    affiliate_name?: boolean
    affiliate_type?: boolean
    start_date?: boolean
    end_date?: boolean
    endorse_fee?: boolean
    target_sales?: boolean
    actual_sales?: boolean
    total_commission?: boolean
    payment_method?: boolean
    platform?: boolean
    content_type?: boolean
    followers?: boolean
    engagement?: boolean
    reference?: boolean
    notes?: boolean
    status?: boolean
    roi?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type AffiliateEndorsementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product_sales?: boolean | AffiliateEndorsement$product_salesArgs<ExtArgs>
    _count?: boolean | AffiliateEndorsementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AffiliateEndorsementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AffiliateEndorsementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AffiliateEndorsement"
    objects: {
      product_sales: Prisma.$AffiliateProductSalePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaign_name: string
      affiliate_name: string
      affiliate_type: string
      start_date: Date
      end_date: Date
      endorse_fee: number
      target_sales: number
      actual_sales: number
      total_commission: number
      payment_method: string | null
      platform: string[]
      content_type: string | null
      followers: number | null
      engagement: number | null
      reference: string | null
      notes: string | null
      status: string
      roi: number | null
      created_by: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["affiliateEndorsement"]>
    composites: {}
  }

  type AffiliateEndorsementGetPayload<S extends boolean | null | undefined | AffiliateEndorsementDefaultArgs> = $Result.GetResult<Prisma.$AffiliateEndorsementPayload, S>

  type AffiliateEndorsementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AffiliateEndorsementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AffiliateEndorsementCountAggregateInputType | true
    }

  export interface AffiliateEndorsementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AffiliateEndorsement'], meta: { name: 'AffiliateEndorsement' } }
    /**
     * Find zero or one AffiliateEndorsement that matches the filter.
     * @param {AffiliateEndorsementFindUniqueArgs} args - Arguments to find a AffiliateEndorsement
     * @example
     * // Get one AffiliateEndorsement
     * const affiliateEndorsement = await prisma.affiliateEndorsement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AffiliateEndorsementFindUniqueArgs>(args: SelectSubset<T, AffiliateEndorsementFindUniqueArgs<ExtArgs>>): Prisma__AffiliateEndorsementClient<$Result.GetResult<Prisma.$AffiliateEndorsementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AffiliateEndorsement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AffiliateEndorsementFindUniqueOrThrowArgs} args - Arguments to find a AffiliateEndorsement
     * @example
     * // Get one AffiliateEndorsement
     * const affiliateEndorsement = await prisma.affiliateEndorsement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AffiliateEndorsementFindUniqueOrThrowArgs>(args: SelectSubset<T, AffiliateEndorsementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AffiliateEndorsementClient<$Result.GetResult<Prisma.$AffiliateEndorsementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AffiliateEndorsement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateEndorsementFindFirstArgs} args - Arguments to find a AffiliateEndorsement
     * @example
     * // Get one AffiliateEndorsement
     * const affiliateEndorsement = await prisma.affiliateEndorsement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AffiliateEndorsementFindFirstArgs>(args?: SelectSubset<T, AffiliateEndorsementFindFirstArgs<ExtArgs>>): Prisma__AffiliateEndorsementClient<$Result.GetResult<Prisma.$AffiliateEndorsementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AffiliateEndorsement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateEndorsementFindFirstOrThrowArgs} args - Arguments to find a AffiliateEndorsement
     * @example
     * // Get one AffiliateEndorsement
     * const affiliateEndorsement = await prisma.affiliateEndorsement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AffiliateEndorsementFindFirstOrThrowArgs>(args?: SelectSubset<T, AffiliateEndorsementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AffiliateEndorsementClient<$Result.GetResult<Prisma.$AffiliateEndorsementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AffiliateEndorsements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateEndorsementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AffiliateEndorsements
     * const affiliateEndorsements = await prisma.affiliateEndorsement.findMany()
     * 
     * // Get first 10 AffiliateEndorsements
     * const affiliateEndorsements = await prisma.affiliateEndorsement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const affiliateEndorsementWithIdOnly = await prisma.affiliateEndorsement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AffiliateEndorsementFindManyArgs>(args?: SelectSubset<T, AffiliateEndorsementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateEndorsementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AffiliateEndorsement.
     * @param {AffiliateEndorsementCreateArgs} args - Arguments to create a AffiliateEndorsement.
     * @example
     * // Create one AffiliateEndorsement
     * const AffiliateEndorsement = await prisma.affiliateEndorsement.create({
     *   data: {
     *     // ... data to create a AffiliateEndorsement
     *   }
     * })
     * 
     */
    create<T extends AffiliateEndorsementCreateArgs>(args: SelectSubset<T, AffiliateEndorsementCreateArgs<ExtArgs>>): Prisma__AffiliateEndorsementClient<$Result.GetResult<Prisma.$AffiliateEndorsementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AffiliateEndorsements.
     * @param {AffiliateEndorsementCreateManyArgs} args - Arguments to create many AffiliateEndorsements.
     * @example
     * // Create many AffiliateEndorsements
     * const affiliateEndorsement = await prisma.affiliateEndorsement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AffiliateEndorsementCreateManyArgs>(args?: SelectSubset<T, AffiliateEndorsementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AffiliateEndorsements and returns the data saved in the database.
     * @param {AffiliateEndorsementCreateManyAndReturnArgs} args - Arguments to create many AffiliateEndorsements.
     * @example
     * // Create many AffiliateEndorsements
     * const affiliateEndorsement = await prisma.affiliateEndorsement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AffiliateEndorsements and only return the `id`
     * const affiliateEndorsementWithIdOnly = await prisma.affiliateEndorsement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AffiliateEndorsementCreateManyAndReturnArgs>(args?: SelectSubset<T, AffiliateEndorsementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateEndorsementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AffiliateEndorsement.
     * @param {AffiliateEndorsementDeleteArgs} args - Arguments to delete one AffiliateEndorsement.
     * @example
     * // Delete one AffiliateEndorsement
     * const AffiliateEndorsement = await prisma.affiliateEndorsement.delete({
     *   where: {
     *     // ... filter to delete one AffiliateEndorsement
     *   }
     * })
     * 
     */
    delete<T extends AffiliateEndorsementDeleteArgs>(args: SelectSubset<T, AffiliateEndorsementDeleteArgs<ExtArgs>>): Prisma__AffiliateEndorsementClient<$Result.GetResult<Prisma.$AffiliateEndorsementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AffiliateEndorsement.
     * @param {AffiliateEndorsementUpdateArgs} args - Arguments to update one AffiliateEndorsement.
     * @example
     * // Update one AffiliateEndorsement
     * const affiliateEndorsement = await prisma.affiliateEndorsement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AffiliateEndorsementUpdateArgs>(args: SelectSubset<T, AffiliateEndorsementUpdateArgs<ExtArgs>>): Prisma__AffiliateEndorsementClient<$Result.GetResult<Prisma.$AffiliateEndorsementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AffiliateEndorsements.
     * @param {AffiliateEndorsementDeleteManyArgs} args - Arguments to filter AffiliateEndorsements to delete.
     * @example
     * // Delete a few AffiliateEndorsements
     * const { count } = await prisma.affiliateEndorsement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AffiliateEndorsementDeleteManyArgs>(args?: SelectSubset<T, AffiliateEndorsementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AffiliateEndorsements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateEndorsementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AffiliateEndorsements
     * const affiliateEndorsement = await prisma.affiliateEndorsement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AffiliateEndorsementUpdateManyArgs>(args: SelectSubset<T, AffiliateEndorsementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AffiliateEndorsement.
     * @param {AffiliateEndorsementUpsertArgs} args - Arguments to update or create a AffiliateEndorsement.
     * @example
     * // Update or create a AffiliateEndorsement
     * const affiliateEndorsement = await prisma.affiliateEndorsement.upsert({
     *   create: {
     *     // ... data to create a AffiliateEndorsement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AffiliateEndorsement we want to update
     *   }
     * })
     */
    upsert<T extends AffiliateEndorsementUpsertArgs>(args: SelectSubset<T, AffiliateEndorsementUpsertArgs<ExtArgs>>): Prisma__AffiliateEndorsementClient<$Result.GetResult<Prisma.$AffiliateEndorsementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AffiliateEndorsements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateEndorsementCountArgs} args - Arguments to filter AffiliateEndorsements to count.
     * @example
     * // Count the number of AffiliateEndorsements
     * const count = await prisma.affiliateEndorsement.count({
     *   where: {
     *     // ... the filter for the AffiliateEndorsements we want to count
     *   }
     * })
    **/
    count<T extends AffiliateEndorsementCountArgs>(
      args?: Subset<T, AffiliateEndorsementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AffiliateEndorsementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AffiliateEndorsement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateEndorsementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AffiliateEndorsementAggregateArgs>(args: Subset<T, AffiliateEndorsementAggregateArgs>): Prisma.PrismaPromise<GetAffiliateEndorsementAggregateType<T>>

    /**
     * Group by AffiliateEndorsement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateEndorsementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AffiliateEndorsementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AffiliateEndorsementGroupByArgs['orderBy'] }
        : { orderBy?: AffiliateEndorsementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AffiliateEndorsementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAffiliateEndorsementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AffiliateEndorsement model
   */
  readonly fields: AffiliateEndorsementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AffiliateEndorsement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AffiliateEndorsementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product_sales<T extends AffiliateEndorsement$product_salesArgs<ExtArgs> = {}>(args?: Subset<T, AffiliateEndorsement$product_salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateProductSalePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AffiliateEndorsement model
   */ 
  interface AffiliateEndorsementFieldRefs {
    readonly id: FieldRef<"AffiliateEndorsement", 'String'>
    readonly campaign_name: FieldRef<"AffiliateEndorsement", 'String'>
    readonly affiliate_name: FieldRef<"AffiliateEndorsement", 'String'>
    readonly affiliate_type: FieldRef<"AffiliateEndorsement", 'String'>
    readonly start_date: FieldRef<"AffiliateEndorsement", 'DateTime'>
    readonly end_date: FieldRef<"AffiliateEndorsement", 'DateTime'>
    readonly endorse_fee: FieldRef<"AffiliateEndorsement", 'Float'>
    readonly target_sales: FieldRef<"AffiliateEndorsement", 'Float'>
    readonly actual_sales: FieldRef<"AffiliateEndorsement", 'Float'>
    readonly total_commission: FieldRef<"AffiliateEndorsement", 'Float'>
    readonly payment_method: FieldRef<"AffiliateEndorsement", 'String'>
    readonly platform: FieldRef<"AffiliateEndorsement", 'String[]'>
    readonly content_type: FieldRef<"AffiliateEndorsement", 'String'>
    readonly followers: FieldRef<"AffiliateEndorsement", 'Int'>
    readonly engagement: FieldRef<"AffiliateEndorsement", 'Float'>
    readonly reference: FieldRef<"AffiliateEndorsement", 'String'>
    readonly notes: FieldRef<"AffiliateEndorsement", 'String'>
    readonly status: FieldRef<"AffiliateEndorsement", 'String'>
    readonly roi: FieldRef<"AffiliateEndorsement", 'Float'>
    readonly created_by: FieldRef<"AffiliateEndorsement", 'String'>
    readonly created_at: FieldRef<"AffiliateEndorsement", 'DateTime'>
    readonly updated_at: FieldRef<"AffiliateEndorsement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AffiliateEndorsement findUnique
   */
  export type AffiliateEndorsementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateEndorsement
     */
    select?: AffiliateEndorsementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateEndorsementInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateEndorsement to fetch.
     */
    where: AffiliateEndorsementWhereUniqueInput
  }

  /**
   * AffiliateEndorsement findUniqueOrThrow
   */
  export type AffiliateEndorsementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateEndorsement
     */
    select?: AffiliateEndorsementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateEndorsementInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateEndorsement to fetch.
     */
    where: AffiliateEndorsementWhereUniqueInput
  }

  /**
   * AffiliateEndorsement findFirst
   */
  export type AffiliateEndorsementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateEndorsement
     */
    select?: AffiliateEndorsementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateEndorsementInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateEndorsement to fetch.
     */
    where?: AffiliateEndorsementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateEndorsements to fetch.
     */
    orderBy?: AffiliateEndorsementOrderByWithRelationInput | AffiliateEndorsementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AffiliateEndorsements.
     */
    cursor?: AffiliateEndorsementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateEndorsements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateEndorsements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AffiliateEndorsements.
     */
    distinct?: AffiliateEndorsementScalarFieldEnum | AffiliateEndorsementScalarFieldEnum[]
  }

  /**
   * AffiliateEndorsement findFirstOrThrow
   */
  export type AffiliateEndorsementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateEndorsement
     */
    select?: AffiliateEndorsementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateEndorsementInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateEndorsement to fetch.
     */
    where?: AffiliateEndorsementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateEndorsements to fetch.
     */
    orderBy?: AffiliateEndorsementOrderByWithRelationInput | AffiliateEndorsementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AffiliateEndorsements.
     */
    cursor?: AffiliateEndorsementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateEndorsements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateEndorsements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AffiliateEndorsements.
     */
    distinct?: AffiliateEndorsementScalarFieldEnum | AffiliateEndorsementScalarFieldEnum[]
  }

  /**
   * AffiliateEndorsement findMany
   */
  export type AffiliateEndorsementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateEndorsement
     */
    select?: AffiliateEndorsementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateEndorsementInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateEndorsements to fetch.
     */
    where?: AffiliateEndorsementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateEndorsements to fetch.
     */
    orderBy?: AffiliateEndorsementOrderByWithRelationInput | AffiliateEndorsementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AffiliateEndorsements.
     */
    cursor?: AffiliateEndorsementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateEndorsements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateEndorsements.
     */
    skip?: number
    distinct?: AffiliateEndorsementScalarFieldEnum | AffiliateEndorsementScalarFieldEnum[]
  }

  /**
   * AffiliateEndorsement create
   */
  export type AffiliateEndorsementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateEndorsement
     */
    select?: AffiliateEndorsementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateEndorsementInclude<ExtArgs> | null
    /**
     * The data needed to create a AffiliateEndorsement.
     */
    data: XOR<AffiliateEndorsementCreateInput, AffiliateEndorsementUncheckedCreateInput>
  }

  /**
   * AffiliateEndorsement createMany
   */
  export type AffiliateEndorsementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AffiliateEndorsements.
     */
    data: AffiliateEndorsementCreateManyInput | AffiliateEndorsementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AffiliateEndorsement createManyAndReturn
   */
  export type AffiliateEndorsementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateEndorsement
     */
    select?: AffiliateEndorsementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AffiliateEndorsements.
     */
    data: AffiliateEndorsementCreateManyInput | AffiliateEndorsementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AffiliateEndorsement update
   */
  export type AffiliateEndorsementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateEndorsement
     */
    select?: AffiliateEndorsementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateEndorsementInclude<ExtArgs> | null
    /**
     * The data needed to update a AffiliateEndorsement.
     */
    data: XOR<AffiliateEndorsementUpdateInput, AffiliateEndorsementUncheckedUpdateInput>
    /**
     * Choose, which AffiliateEndorsement to update.
     */
    where: AffiliateEndorsementWhereUniqueInput
  }

  /**
   * AffiliateEndorsement updateMany
   */
  export type AffiliateEndorsementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AffiliateEndorsements.
     */
    data: XOR<AffiliateEndorsementUpdateManyMutationInput, AffiliateEndorsementUncheckedUpdateManyInput>
    /**
     * Filter which AffiliateEndorsements to update
     */
    where?: AffiliateEndorsementWhereInput
  }

  /**
   * AffiliateEndorsement upsert
   */
  export type AffiliateEndorsementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateEndorsement
     */
    select?: AffiliateEndorsementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateEndorsementInclude<ExtArgs> | null
    /**
     * The filter to search for the AffiliateEndorsement to update in case it exists.
     */
    where: AffiliateEndorsementWhereUniqueInput
    /**
     * In case the AffiliateEndorsement found by the `where` argument doesn't exist, create a new AffiliateEndorsement with this data.
     */
    create: XOR<AffiliateEndorsementCreateInput, AffiliateEndorsementUncheckedCreateInput>
    /**
     * In case the AffiliateEndorsement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AffiliateEndorsementUpdateInput, AffiliateEndorsementUncheckedUpdateInput>
  }

  /**
   * AffiliateEndorsement delete
   */
  export type AffiliateEndorsementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateEndorsement
     */
    select?: AffiliateEndorsementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateEndorsementInclude<ExtArgs> | null
    /**
     * Filter which AffiliateEndorsement to delete.
     */
    where: AffiliateEndorsementWhereUniqueInput
  }

  /**
   * AffiliateEndorsement deleteMany
   */
  export type AffiliateEndorsementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AffiliateEndorsements to delete
     */
    where?: AffiliateEndorsementWhereInput
  }

  /**
   * AffiliateEndorsement.product_sales
   */
  export type AffiliateEndorsement$product_salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProductSale
     */
    select?: AffiliateProductSaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProductSaleInclude<ExtArgs> | null
    where?: AffiliateProductSaleWhereInput
    orderBy?: AffiliateProductSaleOrderByWithRelationInput | AffiliateProductSaleOrderByWithRelationInput[]
    cursor?: AffiliateProductSaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AffiliateProductSaleScalarFieldEnum | AffiliateProductSaleScalarFieldEnum[]
  }

  /**
   * AffiliateEndorsement without action
   */
  export type AffiliateEndorsementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateEndorsement
     */
    select?: AffiliateEndorsementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateEndorsementInclude<ExtArgs> | null
  }


  /**
   * Model AffiliateProductSale
   */

  export type AggregateAffiliateProductSale = {
    _count: AffiliateProductSaleCountAggregateOutputType | null
    _avg: AffiliateProductSaleAvgAggregateOutputType | null
    _sum: AffiliateProductSaleSumAggregateOutputType | null
    _min: AffiliateProductSaleMinAggregateOutputType | null
    _max: AffiliateProductSaleMaxAggregateOutputType | null
  }

  export type AffiliateProductSaleAvgAggregateOutputType = {
    quantity: number | null
    unit_price: number | null
    total_sales: number | null
    commission: number | null
  }

  export type AffiliateProductSaleSumAggregateOutputType = {
    quantity: number | null
    unit_price: number | null
    total_sales: number | null
    commission: number | null
  }

  export type AffiliateProductSaleMinAggregateOutputType = {
    id: string | null
    endorsement_id: string | null
    product_name: string | null
    quantity: number | null
    unit_price: number | null
    total_sales: number | null
    commission: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AffiliateProductSaleMaxAggregateOutputType = {
    id: string | null
    endorsement_id: string | null
    product_name: string | null
    quantity: number | null
    unit_price: number | null
    total_sales: number | null
    commission: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type AffiliateProductSaleCountAggregateOutputType = {
    id: number
    endorsement_id: number
    product_name: number
    quantity: number
    unit_price: number
    total_sales: number
    commission: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AffiliateProductSaleAvgAggregateInputType = {
    quantity?: true
    unit_price?: true
    total_sales?: true
    commission?: true
  }

  export type AffiliateProductSaleSumAggregateInputType = {
    quantity?: true
    unit_price?: true
    total_sales?: true
    commission?: true
  }

  export type AffiliateProductSaleMinAggregateInputType = {
    id?: true
    endorsement_id?: true
    product_name?: true
    quantity?: true
    unit_price?: true
    total_sales?: true
    commission?: true
    created_at?: true
    updated_at?: true
  }

  export type AffiliateProductSaleMaxAggregateInputType = {
    id?: true
    endorsement_id?: true
    product_name?: true
    quantity?: true
    unit_price?: true
    total_sales?: true
    commission?: true
    created_at?: true
    updated_at?: true
  }

  export type AffiliateProductSaleCountAggregateInputType = {
    id?: true
    endorsement_id?: true
    product_name?: true
    quantity?: true
    unit_price?: true
    total_sales?: true
    commission?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AffiliateProductSaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AffiliateProductSale to aggregate.
     */
    where?: AffiliateProductSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateProductSales to fetch.
     */
    orderBy?: AffiliateProductSaleOrderByWithRelationInput | AffiliateProductSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AffiliateProductSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateProductSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateProductSales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AffiliateProductSales
    **/
    _count?: true | AffiliateProductSaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AffiliateProductSaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AffiliateProductSaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AffiliateProductSaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AffiliateProductSaleMaxAggregateInputType
  }

  export type GetAffiliateProductSaleAggregateType<T extends AffiliateProductSaleAggregateArgs> = {
        [P in keyof T & keyof AggregateAffiliateProductSale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAffiliateProductSale[P]>
      : GetScalarType<T[P], AggregateAffiliateProductSale[P]>
  }




  export type AffiliateProductSaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateProductSaleWhereInput
    orderBy?: AffiliateProductSaleOrderByWithAggregationInput | AffiliateProductSaleOrderByWithAggregationInput[]
    by: AffiliateProductSaleScalarFieldEnum[] | AffiliateProductSaleScalarFieldEnum
    having?: AffiliateProductSaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AffiliateProductSaleCountAggregateInputType | true
    _avg?: AffiliateProductSaleAvgAggregateInputType
    _sum?: AffiliateProductSaleSumAggregateInputType
    _min?: AffiliateProductSaleMinAggregateInputType
    _max?: AffiliateProductSaleMaxAggregateInputType
  }

  export type AffiliateProductSaleGroupByOutputType = {
    id: string
    endorsement_id: string
    product_name: string
    quantity: number
    unit_price: number
    total_sales: number
    commission: number
    created_at: Date
    updated_at: Date
    _count: AffiliateProductSaleCountAggregateOutputType | null
    _avg: AffiliateProductSaleAvgAggregateOutputType | null
    _sum: AffiliateProductSaleSumAggregateOutputType | null
    _min: AffiliateProductSaleMinAggregateOutputType | null
    _max: AffiliateProductSaleMaxAggregateOutputType | null
  }

  type GetAffiliateProductSaleGroupByPayload<T extends AffiliateProductSaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AffiliateProductSaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AffiliateProductSaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AffiliateProductSaleGroupByOutputType[P]>
            : GetScalarType<T[P], AffiliateProductSaleGroupByOutputType[P]>
        }
      >
    >


  export type AffiliateProductSaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    endorsement_id?: boolean
    product_name?: boolean
    quantity?: boolean
    unit_price?: boolean
    total_sales?: boolean
    commission?: boolean
    created_at?: boolean
    updated_at?: boolean
    endorsement?: boolean | AffiliateEndorsementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliateProductSale"]>

  export type AffiliateProductSaleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    endorsement_id?: boolean
    product_name?: boolean
    quantity?: boolean
    unit_price?: boolean
    total_sales?: boolean
    commission?: boolean
    created_at?: boolean
    updated_at?: boolean
    endorsement?: boolean | AffiliateEndorsementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliateProductSale"]>

  export type AffiliateProductSaleSelectScalar = {
    id?: boolean
    endorsement_id?: boolean
    product_name?: boolean
    quantity?: boolean
    unit_price?: boolean
    total_sales?: boolean
    commission?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type AffiliateProductSaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endorsement?: boolean | AffiliateEndorsementDefaultArgs<ExtArgs>
  }
  export type AffiliateProductSaleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    endorsement?: boolean | AffiliateEndorsementDefaultArgs<ExtArgs>
  }

  export type $AffiliateProductSalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AffiliateProductSale"
    objects: {
      endorsement: Prisma.$AffiliateEndorsementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      endorsement_id: string
      product_name: string
      quantity: number
      unit_price: number
      total_sales: number
      commission: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["affiliateProductSale"]>
    composites: {}
  }

  type AffiliateProductSaleGetPayload<S extends boolean | null | undefined | AffiliateProductSaleDefaultArgs> = $Result.GetResult<Prisma.$AffiliateProductSalePayload, S>

  type AffiliateProductSaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AffiliateProductSaleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AffiliateProductSaleCountAggregateInputType | true
    }

  export interface AffiliateProductSaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AffiliateProductSale'], meta: { name: 'AffiliateProductSale' } }
    /**
     * Find zero or one AffiliateProductSale that matches the filter.
     * @param {AffiliateProductSaleFindUniqueArgs} args - Arguments to find a AffiliateProductSale
     * @example
     * // Get one AffiliateProductSale
     * const affiliateProductSale = await prisma.affiliateProductSale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AffiliateProductSaleFindUniqueArgs>(args: SelectSubset<T, AffiliateProductSaleFindUniqueArgs<ExtArgs>>): Prisma__AffiliateProductSaleClient<$Result.GetResult<Prisma.$AffiliateProductSalePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AffiliateProductSale that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AffiliateProductSaleFindUniqueOrThrowArgs} args - Arguments to find a AffiliateProductSale
     * @example
     * // Get one AffiliateProductSale
     * const affiliateProductSale = await prisma.affiliateProductSale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AffiliateProductSaleFindUniqueOrThrowArgs>(args: SelectSubset<T, AffiliateProductSaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AffiliateProductSaleClient<$Result.GetResult<Prisma.$AffiliateProductSalePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AffiliateProductSale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProductSaleFindFirstArgs} args - Arguments to find a AffiliateProductSale
     * @example
     * // Get one AffiliateProductSale
     * const affiliateProductSale = await prisma.affiliateProductSale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AffiliateProductSaleFindFirstArgs>(args?: SelectSubset<T, AffiliateProductSaleFindFirstArgs<ExtArgs>>): Prisma__AffiliateProductSaleClient<$Result.GetResult<Prisma.$AffiliateProductSalePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AffiliateProductSale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProductSaleFindFirstOrThrowArgs} args - Arguments to find a AffiliateProductSale
     * @example
     * // Get one AffiliateProductSale
     * const affiliateProductSale = await prisma.affiliateProductSale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AffiliateProductSaleFindFirstOrThrowArgs>(args?: SelectSubset<T, AffiliateProductSaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__AffiliateProductSaleClient<$Result.GetResult<Prisma.$AffiliateProductSalePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AffiliateProductSales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProductSaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AffiliateProductSales
     * const affiliateProductSales = await prisma.affiliateProductSale.findMany()
     * 
     * // Get first 10 AffiliateProductSales
     * const affiliateProductSales = await prisma.affiliateProductSale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const affiliateProductSaleWithIdOnly = await prisma.affiliateProductSale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AffiliateProductSaleFindManyArgs>(args?: SelectSubset<T, AffiliateProductSaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateProductSalePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AffiliateProductSale.
     * @param {AffiliateProductSaleCreateArgs} args - Arguments to create a AffiliateProductSale.
     * @example
     * // Create one AffiliateProductSale
     * const AffiliateProductSale = await prisma.affiliateProductSale.create({
     *   data: {
     *     // ... data to create a AffiliateProductSale
     *   }
     * })
     * 
     */
    create<T extends AffiliateProductSaleCreateArgs>(args: SelectSubset<T, AffiliateProductSaleCreateArgs<ExtArgs>>): Prisma__AffiliateProductSaleClient<$Result.GetResult<Prisma.$AffiliateProductSalePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AffiliateProductSales.
     * @param {AffiliateProductSaleCreateManyArgs} args - Arguments to create many AffiliateProductSales.
     * @example
     * // Create many AffiliateProductSales
     * const affiliateProductSale = await prisma.affiliateProductSale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AffiliateProductSaleCreateManyArgs>(args?: SelectSubset<T, AffiliateProductSaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AffiliateProductSales and returns the data saved in the database.
     * @param {AffiliateProductSaleCreateManyAndReturnArgs} args - Arguments to create many AffiliateProductSales.
     * @example
     * // Create many AffiliateProductSales
     * const affiliateProductSale = await prisma.affiliateProductSale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AffiliateProductSales and only return the `id`
     * const affiliateProductSaleWithIdOnly = await prisma.affiliateProductSale.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AffiliateProductSaleCreateManyAndReturnArgs>(args?: SelectSubset<T, AffiliateProductSaleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateProductSalePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AffiliateProductSale.
     * @param {AffiliateProductSaleDeleteArgs} args - Arguments to delete one AffiliateProductSale.
     * @example
     * // Delete one AffiliateProductSale
     * const AffiliateProductSale = await prisma.affiliateProductSale.delete({
     *   where: {
     *     // ... filter to delete one AffiliateProductSale
     *   }
     * })
     * 
     */
    delete<T extends AffiliateProductSaleDeleteArgs>(args: SelectSubset<T, AffiliateProductSaleDeleteArgs<ExtArgs>>): Prisma__AffiliateProductSaleClient<$Result.GetResult<Prisma.$AffiliateProductSalePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AffiliateProductSale.
     * @param {AffiliateProductSaleUpdateArgs} args - Arguments to update one AffiliateProductSale.
     * @example
     * // Update one AffiliateProductSale
     * const affiliateProductSale = await prisma.affiliateProductSale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AffiliateProductSaleUpdateArgs>(args: SelectSubset<T, AffiliateProductSaleUpdateArgs<ExtArgs>>): Prisma__AffiliateProductSaleClient<$Result.GetResult<Prisma.$AffiliateProductSalePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AffiliateProductSales.
     * @param {AffiliateProductSaleDeleteManyArgs} args - Arguments to filter AffiliateProductSales to delete.
     * @example
     * // Delete a few AffiliateProductSales
     * const { count } = await prisma.affiliateProductSale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AffiliateProductSaleDeleteManyArgs>(args?: SelectSubset<T, AffiliateProductSaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AffiliateProductSales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProductSaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AffiliateProductSales
     * const affiliateProductSale = await prisma.affiliateProductSale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AffiliateProductSaleUpdateManyArgs>(args: SelectSubset<T, AffiliateProductSaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AffiliateProductSale.
     * @param {AffiliateProductSaleUpsertArgs} args - Arguments to update or create a AffiliateProductSale.
     * @example
     * // Update or create a AffiliateProductSale
     * const affiliateProductSale = await prisma.affiliateProductSale.upsert({
     *   create: {
     *     // ... data to create a AffiliateProductSale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AffiliateProductSale we want to update
     *   }
     * })
     */
    upsert<T extends AffiliateProductSaleUpsertArgs>(args: SelectSubset<T, AffiliateProductSaleUpsertArgs<ExtArgs>>): Prisma__AffiliateProductSaleClient<$Result.GetResult<Prisma.$AffiliateProductSalePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AffiliateProductSales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProductSaleCountArgs} args - Arguments to filter AffiliateProductSales to count.
     * @example
     * // Count the number of AffiliateProductSales
     * const count = await prisma.affiliateProductSale.count({
     *   where: {
     *     // ... the filter for the AffiliateProductSales we want to count
     *   }
     * })
    **/
    count<T extends AffiliateProductSaleCountArgs>(
      args?: Subset<T, AffiliateProductSaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AffiliateProductSaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AffiliateProductSale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProductSaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AffiliateProductSaleAggregateArgs>(args: Subset<T, AffiliateProductSaleAggregateArgs>): Prisma.PrismaPromise<GetAffiliateProductSaleAggregateType<T>>

    /**
     * Group by AffiliateProductSale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProductSaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AffiliateProductSaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AffiliateProductSaleGroupByArgs['orderBy'] }
        : { orderBy?: AffiliateProductSaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AffiliateProductSaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAffiliateProductSaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AffiliateProductSale model
   */
  readonly fields: AffiliateProductSaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AffiliateProductSale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AffiliateProductSaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    endorsement<T extends AffiliateEndorsementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AffiliateEndorsementDefaultArgs<ExtArgs>>): Prisma__AffiliateEndorsementClient<$Result.GetResult<Prisma.$AffiliateEndorsementPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AffiliateProductSale model
   */ 
  interface AffiliateProductSaleFieldRefs {
    readonly id: FieldRef<"AffiliateProductSale", 'String'>
    readonly endorsement_id: FieldRef<"AffiliateProductSale", 'String'>
    readonly product_name: FieldRef<"AffiliateProductSale", 'String'>
    readonly quantity: FieldRef<"AffiliateProductSale", 'Int'>
    readonly unit_price: FieldRef<"AffiliateProductSale", 'Float'>
    readonly total_sales: FieldRef<"AffiliateProductSale", 'Float'>
    readonly commission: FieldRef<"AffiliateProductSale", 'Float'>
    readonly created_at: FieldRef<"AffiliateProductSale", 'DateTime'>
    readonly updated_at: FieldRef<"AffiliateProductSale", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AffiliateProductSale findUnique
   */
  export type AffiliateProductSaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProductSale
     */
    select?: AffiliateProductSaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProductSaleInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateProductSale to fetch.
     */
    where: AffiliateProductSaleWhereUniqueInput
  }

  /**
   * AffiliateProductSale findUniqueOrThrow
   */
  export type AffiliateProductSaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProductSale
     */
    select?: AffiliateProductSaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProductSaleInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateProductSale to fetch.
     */
    where: AffiliateProductSaleWhereUniqueInput
  }

  /**
   * AffiliateProductSale findFirst
   */
  export type AffiliateProductSaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProductSale
     */
    select?: AffiliateProductSaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProductSaleInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateProductSale to fetch.
     */
    where?: AffiliateProductSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateProductSales to fetch.
     */
    orderBy?: AffiliateProductSaleOrderByWithRelationInput | AffiliateProductSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AffiliateProductSales.
     */
    cursor?: AffiliateProductSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateProductSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateProductSales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AffiliateProductSales.
     */
    distinct?: AffiliateProductSaleScalarFieldEnum | AffiliateProductSaleScalarFieldEnum[]
  }

  /**
   * AffiliateProductSale findFirstOrThrow
   */
  export type AffiliateProductSaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProductSale
     */
    select?: AffiliateProductSaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProductSaleInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateProductSale to fetch.
     */
    where?: AffiliateProductSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateProductSales to fetch.
     */
    orderBy?: AffiliateProductSaleOrderByWithRelationInput | AffiliateProductSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AffiliateProductSales.
     */
    cursor?: AffiliateProductSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateProductSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateProductSales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AffiliateProductSales.
     */
    distinct?: AffiliateProductSaleScalarFieldEnum | AffiliateProductSaleScalarFieldEnum[]
  }

  /**
   * AffiliateProductSale findMany
   */
  export type AffiliateProductSaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProductSale
     */
    select?: AffiliateProductSaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProductSaleInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateProductSales to fetch.
     */
    where?: AffiliateProductSaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateProductSales to fetch.
     */
    orderBy?: AffiliateProductSaleOrderByWithRelationInput | AffiliateProductSaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AffiliateProductSales.
     */
    cursor?: AffiliateProductSaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateProductSales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateProductSales.
     */
    skip?: number
    distinct?: AffiliateProductSaleScalarFieldEnum | AffiliateProductSaleScalarFieldEnum[]
  }

  /**
   * AffiliateProductSale create
   */
  export type AffiliateProductSaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProductSale
     */
    select?: AffiliateProductSaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProductSaleInclude<ExtArgs> | null
    /**
     * The data needed to create a AffiliateProductSale.
     */
    data: XOR<AffiliateProductSaleCreateInput, AffiliateProductSaleUncheckedCreateInput>
  }

  /**
   * AffiliateProductSale createMany
   */
  export type AffiliateProductSaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AffiliateProductSales.
     */
    data: AffiliateProductSaleCreateManyInput | AffiliateProductSaleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AffiliateProductSale createManyAndReturn
   */
  export type AffiliateProductSaleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProductSale
     */
    select?: AffiliateProductSaleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AffiliateProductSales.
     */
    data: AffiliateProductSaleCreateManyInput | AffiliateProductSaleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProductSaleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AffiliateProductSale update
   */
  export type AffiliateProductSaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProductSale
     */
    select?: AffiliateProductSaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProductSaleInclude<ExtArgs> | null
    /**
     * The data needed to update a AffiliateProductSale.
     */
    data: XOR<AffiliateProductSaleUpdateInput, AffiliateProductSaleUncheckedUpdateInput>
    /**
     * Choose, which AffiliateProductSale to update.
     */
    where: AffiliateProductSaleWhereUniqueInput
  }

  /**
   * AffiliateProductSale updateMany
   */
  export type AffiliateProductSaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AffiliateProductSales.
     */
    data: XOR<AffiliateProductSaleUpdateManyMutationInput, AffiliateProductSaleUncheckedUpdateManyInput>
    /**
     * Filter which AffiliateProductSales to update
     */
    where?: AffiliateProductSaleWhereInput
  }

  /**
   * AffiliateProductSale upsert
   */
  export type AffiliateProductSaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProductSale
     */
    select?: AffiliateProductSaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProductSaleInclude<ExtArgs> | null
    /**
     * The filter to search for the AffiliateProductSale to update in case it exists.
     */
    where: AffiliateProductSaleWhereUniqueInput
    /**
     * In case the AffiliateProductSale found by the `where` argument doesn't exist, create a new AffiliateProductSale with this data.
     */
    create: XOR<AffiliateProductSaleCreateInput, AffiliateProductSaleUncheckedCreateInput>
    /**
     * In case the AffiliateProductSale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AffiliateProductSaleUpdateInput, AffiliateProductSaleUncheckedUpdateInput>
  }

  /**
   * AffiliateProductSale delete
   */
  export type AffiliateProductSaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProductSale
     */
    select?: AffiliateProductSaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProductSaleInclude<ExtArgs> | null
    /**
     * Filter which AffiliateProductSale to delete.
     */
    where: AffiliateProductSaleWhereUniqueInput
  }

  /**
   * AffiliateProductSale deleteMany
   */
  export type AffiliateProductSaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AffiliateProductSales to delete
     */
    where?: AffiliateProductSaleWhereInput
  }

  /**
   * AffiliateProductSale without action
   */
  export type AffiliateProductSaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProductSale
     */
    select?: AffiliateProductSaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProductSaleInclude<ExtArgs> | null
  }


  /**
   * Model ActivityLogs
   */

  export type AggregateActivityLogs = {
    _count: ActivityLogsCountAggregateOutputType | null
    _min: ActivityLogsMinAggregateOutputType | null
    _max: ActivityLogsMaxAggregateOutputType | null
  }

  export type ActivityLogsMinAggregateOutputType = {
    id: string | null
    type: string | null
    title: string | null
    description: string | null
    status: string | null
    user_id: string | null
    related_id: string | null
    related_type: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ActivityLogsMaxAggregateOutputType = {
    id: string | null
    type: string | null
    title: string | null
    description: string | null
    status: string | null
    user_id: string | null
    related_id: string | null
    related_type: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ActivityLogsCountAggregateOutputType = {
    id: number
    type: number
    title: number
    description: number
    status: number
    metadata: number
    user_id: number
    related_id: number
    related_type: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ActivityLogsMinAggregateInputType = {
    id?: true
    type?: true
    title?: true
    description?: true
    status?: true
    user_id?: true
    related_id?: true
    related_type?: true
    created_at?: true
    updated_at?: true
  }

  export type ActivityLogsMaxAggregateInputType = {
    id?: true
    type?: true
    title?: true
    description?: true
    status?: true
    user_id?: true
    related_id?: true
    related_type?: true
    created_at?: true
    updated_at?: true
  }

  export type ActivityLogsCountAggregateInputType = {
    id?: true
    type?: true
    title?: true
    description?: true
    status?: true
    metadata?: true
    user_id?: true
    related_id?: true
    related_type?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ActivityLogsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to aggregate.
     */
    where?: ActivityLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogsOrderByWithRelationInput | ActivityLogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityLogs
    **/
    _count?: true | ActivityLogsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogsMaxAggregateInputType
  }

  export type GetActivityLogsAggregateType<T extends ActivityLogsAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLogs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLogs[P]>
      : GetScalarType<T[P], AggregateActivityLogs[P]>
  }




  export type ActivityLogsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogsWhereInput
    orderBy?: ActivityLogsOrderByWithAggregationInput | ActivityLogsOrderByWithAggregationInput[]
    by: ActivityLogsScalarFieldEnum[] | ActivityLogsScalarFieldEnum
    having?: ActivityLogsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogsCountAggregateInputType | true
    _min?: ActivityLogsMinAggregateInputType
    _max?: ActivityLogsMaxAggregateInputType
  }

  export type ActivityLogsGroupByOutputType = {
    id: string
    type: string
    title: string
    description: string
    status: string | null
    metadata: JsonValue | null
    user_id: string | null
    related_id: string | null
    related_type: string | null
    created_at: Date
    updated_at: Date
    _count: ActivityLogsCountAggregateOutputType | null
    _min: ActivityLogsMinAggregateOutputType | null
    _max: ActivityLogsMaxAggregateOutputType | null
  }

  type GetActivityLogsGroupByPayload<T extends ActivityLogsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityLogsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogsGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogsGroupByOutputType[P]>
        }
      >
    >


  export type ActivityLogsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    metadata?: boolean
    user_id?: boolean
    related_id?: boolean
    related_type?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["activityLogs"]>

  export type ActivityLogsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    metadata?: boolean
    user_id?: boolean
    related_id?: boolean
    related_type?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["activityLogs"]>

  export type ActivityLogsSelectScalar = {
    id?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    metadata?: boolean
    user_id?: boolean
    related_id?: boolean
    related_type?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $ActivityLogsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityLogs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      title: string
      description: string
      status: string | null
      metadata: Prisma.JsonValue | null
      user_id: string | null
      related_id: string | null
      related_type: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["activityLogs"]>
    composites: {}
  }

  type ActivityLogsGetPayload<S extends boolean | null | undefined | ActivityLogsDefaultArgs> = $Result.GetResult<Prisma.$ActivityLogsPayload, S>

  type ActivityLogsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActivityLogsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActivityLogsCountAggregateInputType | true
    }

  export interface ActivityLogsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityLogs'], meta: { name: 'ActivityLogs' } }
    /**
     * Find zero or one ActivityLogs that matches the filter.
     * @param {ActivityLogsFindUniqueArgs} args - Arguments to find a ActivityLogs
     * @example
     * // Get one ActivityLogs
     * const activityLogs = await prisma.activityLogs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityLogsFindUniqueArgs>(args: SelectSubset<T, ActivityLogsFindUniqueArgs<ExtArgs>>): Prisma__ActivityLogsClient<$Result.GetResult<Prisma.$ActivityLogsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ActivityLogs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActivityLogsFindUniqueOrThrowArgs} args - Arguments to find a ActivityLogs
     * @example
     * // Get one ActivityLogs
     * const activityLogs = await prisma.activityLogs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityLogsFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityLogsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityLogsClient<$Result.GetResult<Prisma.$ActivityLogsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogsFindFirstArgs} args - Arguments to find a ActivityLogs
     * @example
     * // Get one ActivityLogs
     * const activityLogs = await prisma.activityLogs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityLogsFindFirstArgs>(args?: SelectSubset<T, ActivityLogsFindFirstArgs<ExtArgs>>): Prisma__ActivityLogsClient<$Result.GetResult<Prisma.$ActivityLogsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ActivityLogs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogsFindFirstOrThrowArgs} args - Arguments to find a ActivityLogs
     * @example
     * // Get one ActivityLogs
     * const activityLogs = await prisma.activityLogs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityLogsFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityLogsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityLogsClient<$Result.GetResult<Prisma.$ActivityLogsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLogs.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLogs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityLogsWithIdOnly = await prisma.activityLogs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityLogsFindManyArgs>(args?: SelectSubset<T, ActivityLogsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ActivityLogs.
     * @param {ActivityLogsCreateArgs} args - Arguments to create a ActivityLogs.
     * @example
     * // Create one ActivityLogs
     * const ActivityLogs = await prisma.activityLogs.create({
     *   data: {
     *     // ... data to create a ActivityLogs
     *   }
     * })
     * 
     */
    create<T extends ActivityLogsCreateArgs>(args: SelectSubset<T, ActivityLogsCreateArgs<ExtArgs>>): Prisma__ActivityLogsClient<$Result.GetResult<Prisma.$ActivityLogsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ActivityLogs.
     * @param {ActivityLogsCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLogs = await prisma.activityLogs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityLogsCreateManyArgs>(args?: SelectSubset<T, ActivityLogsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityLogs and returns the data saved in the database.
     * @param {ActivityLogsCreateManyAndReturnArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLogs = await prisma.activityLogs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityLogs and only return the `id`
     * const activityLogsWithIdOnly = await prisma.activityLogs.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityLogsCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityLogsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ActivityLogs.
     * @param {ActivityLogsDeleteArgs} args - Arguments to delete one ActivityLogs.
     * @example
     * // Delete one ActivityLogs
     * const ActivityLogs = await prisma.activityLogs.delete({
     *   where: {
     *     // ... filter to delete one ActivityLogs
     *   }
     * })
     * 
     */
    delete<T extends ActivityLogsDeleteArgs>(args: SelectSubset<T, ActivityLogsDeleteArgs<ExtArgs>>): Prisma__ActivityLogsClient<$Result.GetResult<Prisma.$ActivityLogsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ActivityLogs.
     * @param {ActivityLogsUpdateArgs} args - Arguments to update one ActivityLogs.
     * @example
     * // Update one ActivityLogs
     * const activityLogs = await prisma.activityLogs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityLogsUpdateArgs>(args: SelectSubset<T, ActivityLogsUpdateArgs<ExtArgs>>): Prisma__ActivityLogsClient<$Result.GetResult<Prisma.$ActivityLogsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogsDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLogs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityLogsDeleteManyArgs>(args?: SelectSubset<T, ActivityLogsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLogs = await prisma.activityLogs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityLogsUpdateManyArgs>(args: SelectSubset<T, ActivityLogsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActivityLogs.
     * @param {ActivityLogsUpsertArgs} args - Arguments to update or create a ActivityLogs.
     * @example
     * // Update or create a ActivityLogs
     * const activityLogs = await prisma.activityLogs.upsert({
     *   create: {
     *     // ... data to create a ActivityLogs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLogs we want to update
     *   }
     * })
     */
    upsert<T extends ActivityLogsUpsertArgs>(args: SelectSubset<T, ActivityLogsUpsertArgs<ExtArgs>>): Prisma__ActivityLogsClient<$Result.GetResult<Prisma.$ActivityLogsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogsCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLogs.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends ActivityLogsCountArgs>(
      args?: Subset<T, ActivityLogsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogsAggregateArgs>(args: Subset<T, ActivityLogsAggregateArgs>): Prisma.PrismaPromise<GetActivityLogsAggregateType<T>>

    /**
     * Group by ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityLogsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogsGroupByArgs['orderBy'] }
        : { orderBy?: ActivityLogsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityLogsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityLogs model
   */
  readonly fields: ActivityLogsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLogs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityLogsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityLogs model
   */ 
  interface ActivityLogsFieldRefs {
    readonly id: FieldRef<"ActivityLogs", 'String'>
    readonly type: FieldRef<"ActivityLogs", 'String'>
    readonly title: FieldRef<"ActivityLogs", 'String'>
    readonly description: FieldRef<"ActivityLogs", 'String'>
    readonly status: FieldRef<"ActivityLogs", 'String'>
    readonly metadata: FieldRef<"ActivityLogs", 'Json'>
    readonly user_id: FieldRef<"ActivityLogs", 'String'>
    readonly related_id: FieldRef<"ActivityLogs", 'String'>
    readonly related_type: FieldRef<"ActivityLogs", 'String'>
    readonly created_at: FieldRef<"ActivityLogs", 'DateTime'>
    readonly updated_at: FieldRef<"ActivityLogs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActivityLogs findUnique
   */
  export type ActivityLogsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLogs
     */
    select?: ActivityLogsSelect<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where: ActivityLogsWhereUniqueInput
  }

  /**
   * ActivityLogs findUniqueOrThrow
   */
  export type ActivityLogsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLogs
     */
    select?: ActivityLogsSelect<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where: ActivityLogsWhereUniqueInput
  }

  /**
   * ActivityLogs findFirst
   */
  export type ActivityLogsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLogs
     */
    select?: ActivityLogsSelect<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogsOrderByWithRelationInput | ActivityLogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogsScalarFieldEnum | ActivityLogsScalarFieldEnum[]
  }

  /**
   * ActivityLogs findFirstOrThrow
   */
  export type ActivityLogsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLogs
     */
    select?: ActivityLogsSelect<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogsOrderByWithRelationInput | ActivityLogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogsScalarFieldEnum | ActivityLogsScalarFieldEnum[]
  }

  /**
   * ActivityLogs findMany
   */
  export type ActivityLogsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLogs
     */
    select?: ActivityLogsSelect<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogsOrderByWithRelationInput | ActivityLogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    distinct?: ActivityLogsScalarFieldEnum | ActivityLogsScalarFieldEnum[]
  }

  /**
   * ActivityLogs create
   */
  export type ActivityLogsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLogs
     */
    select?: ActivityLogsSelect<ExtArgs> | null
    /**
     * The data needed to create a ActivityLogs.
     */
    data: XOR<ActivityLogsCreateInput, ActivityLogsUncheckedCreateInput>
  }

  /**
   * ActivityLogs createMany
   */
  export type ActivityLogsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogsCreateManyInput | ActivityLogsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLogs createManyAndReturn
   */
  export type ActivityLogsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLogs
     */
    select?: ActivityLogsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogsCreateManyInput | ActivityLogsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLogs update
   */
  export type ActivityLogsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLogs
     */
    select?: ActivityLogsSelect<ExtArgs> | null
    /**
     * The data needed to update a ActivityLogs.
     */
    data: XOR<ActivityLogsUpdateInput, ActivityLogsUncheckedUpdateInput>
    /**
     * Choose, which ActivityLogs to update.
     */
    where: ActivityLogsWhereUniqueInput
  }

  /**
   * ActivityLogs updateMany
   */
  export type ActivityLogsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogsUpdateManyMutationInput, ActivityLogsUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogsWhereInput
  }

  /**
   * ActivityLogs upsert
   */
  export type ActivityLogsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLogs
     */
    select?: ActivityLogsSelect<ExtArgs> | null
    /**
     * The filter to search for the ActivityLogs to update in case it exists.
     */
    where: ActivityLogsWhereUniqueInput
    /**
     * In case the ActivityLogs found by the `where` argument doesn't exist, create a new ActivityLogs with this data.
     */
    create: XOR<ActivityLogsCreateInput, ActivityLogsUncheckedCreateInput>
    /**
     * In case the ActivityLogs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogsUpdateInput, ActivityLogsUncheckedUpdateInput>
  }

  /**
   * ActivityLogs delete
   */
  export type ActivityLogsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLogs
     */
    select?: ActivityLogsSelect<ExtArgs> | null
    /**
     * Filter which ActivityLogs to delete.
     */
    where: ActivityLogsWhereUniqueInput
  }

  /**
   * ActivityLogs deleteMany
   */
  export type ActivityLogsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogsWhereInput
  }

  /**
   * ActivityLogs without action
   */
  export type ActivityLogsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLogs
     */
    select?: ActivityLogsSelect<ExtArgs> | null
  }


  /**
   * Model DuplicateCheckLogs
   */

  export type AggregateDuplicateCheckLogs = {
    _count: DuplicateCheckLogsCountAggregateOutputType | null
    _avg: DuplicateCheckLogsAvgAggregateOutputType | null
    _sum: DuplicateCheckLogsSumAggregateOutputType | null
    _min: DuplicateCheckLogsMinAggregateOutputType | null
    _max: DuplicateCheckLogsMaxAggregateOutputType | null
  }

  export type DuplicateCheckLogsAvgAggregateOutputType = {
    file_size: number | null
  }

  export type DuplicateCheckLogsSumAggregateOutputType = {
    file_size: bigint | null
  }

  export type DuplicateCheckLogsMinAggregateOutputType = {
    id: string | null
    file_name: string | null
    file_size: bigint | null
    file_hash: string | null
    import_type: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DuplicateCheckLogsMaxAggregateOutputType = {
    id: string | null
    file_name: string | null
    file_size: bigint | null
    file_hash: string | null
    import_type: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type DuplicateCheckLogsCountAggregateOutputType = {
    id: number
    file_name: number
    file_size: number
    file_hash: number
    import_type: number
    check_result: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type DuplicateCheckLogsAvgAggregateInputType = {
    file_size?: true
  }

  export type DuplicateCheckLogsSumAggregateInputType = {
    file_size?: true
  }

  export type DuplicateCheckLogsMinAggregateInputType = {
    id?: true
    file_name?: true
    file_size?: true
    file_hash?: true
    import_type?: true
    created_at?: true
    updated_at?: true
  }

  export type DuplicateCheckLogsMaxAggregateInputType = {
    id?: true
    file_name?: true
    file_size?: true
    file_hash?: true
    import_type?: true
    created_at?: true
    updated_at?: true
  }

  export type DuplicateCheckLogsCountAggregateInputType = {
    id?: true
    file_name?: true
    file_size?: true
    file_hash?: true
    import_type?: true
    check_result?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type DuplicateCheckLogsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DuplicateCheckLogs to aggregate.
     */
    where?: DuplicateCheckLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DuplicateCheckLogs to fetch.
     */
    orderBy?: DuplicateCheckLogsOrderByWithRelationInput | DuplicateCheckLogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DuplicateCheckLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DuplicateCheckLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DuplicateCheckLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DuplicateCheckLogs
    **/
    _count?: true | DuplicateCheckLogsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DuplicateCheckLogsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DuplicateCheckLogsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DuplicateCheckLogsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DuplicateCheckLogsMaxAggregateInputType
  }

  export type GetDuplicateCheckLogsAggregateType<T extends DuplicateCheckLogsAggregateArgs> = {
        [P in keyof T & keyof AggregateDuplicateCheckLogs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDuplicateCheckLogs[P]>
      : GetScalarType<T[P], AggregateDuplicateCheckLogs[P]>
  }




  export type DuplicateCheckLogsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DuplicateCheckLogsWhereInput
    orderBy?: DuplicateCheckLogsOrderByWithAggregationInput | DuplicateCheckLogsOrderByWithAggregationInput[]
    by: DuplicateCheckLogsScalarFieldEnum[] | DuplicateCheckLogsScalarFieldEnum
    having?: DuplicateCheckLogsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DuplicateCheckLogsCountAggregateInputType | true
    _avg?: DuplicateCheckLogsAvgAggregateInputType
    _sum?: DuplicateCheckLogsSumAggregateInputType
    _min?: DuplicateCheckLogsMinAggregateInputType
    _max?: DuplicateCheckLogsMaxAggregateInputType
  }

  export type DuplicateCheckLogsGroupByOutputType = {
    id: string
    file_name: string
    file_size: bigint | null
    file_hash: string | null
    import_type: string
    check_result: JsonValue | null
    created_at: Date
    updated_at: Date
    _count: DuplicateCheckLogsCountAggregateOutputType | null
    _avg: DuplicateCheckLogsAvgAggregateOutputType | null
    _sum: DuplicateCheckLogsSumAggregateOutputType | null
    _min: DuplicateCheckLogsMinAggregateOutputType | null
    _max: DuplicateCheckLogsMaxAggregateOutputType | null
  }

  type GetDuplicateCheckLogsGroupByPayload<T extends DuplicateCheckLogsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DuplicateCheckLogsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DuplicateCheckLogsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DuplicateCheckLogsGroupByOutputType[P]>
            : GetScalarType<T[P], DuplicateCheckLogsGroupByOutputType[P]>
        }
      >
    >


  export type DuplicateCheckLogsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    file_name?: boolean
    file_size?: boolean
    file_hash?: boolean
    import_type?: boolean
    check_result?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["duplicateCheckLogs"]>

  export type DuplicateCheckLogsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    file_name?: boolean
    file_size?: boolean
    file_hash?: boolean
    import_type?: boolean
    check_result?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["duplicateCheckLogs"]>

  export type DuplicateCheckLogsSelectScalar = {
    id?: boolean
    file_name?: boolean
    file_size?: boolean
    file_hash?: boolean
    import_type?: boolean
    check_result?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $DuplicateCheckLogsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DuplicateCheckLogs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      file_name: string
      file_size: bigint | null
      file_hash: string | null
      import_type: string
      check_result: Prisma.JsonValue | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["duplicateCheckLogs"]>
    composites: {}
  }

  type DuplicateCheckLogsGetPayload<S extends boolean | null | undefined | DuplicateCheckLogsDefaultArgs> = $Result.GetResult<Prisma.$DuplicateCheckLogsPayload, S>

  type DuplicateCheckLogsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DuplicateCheckLogsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DuplicateCheckLogsCountAggregateInputType | true
    }

  export interface DuplicateCheckLogsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DuplicateCheckLogs'], meta: { name: 'DuplicateCheckLogs' } }
    /**
     * Find zero or one DuplicateCheckLogs that matches the filter.
     * @param {DuplicateCheckLogsFindUniqueArgs} args - Arguments to find a DuplicateCheckLogs
     * @example
     * // Get one DuplicateCheckLogs
     * const duplicateCheckLogs = await prisma.duplicateCheckLogs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DuplicateCheckLogsFindUniqueArgs>(args: SelectSubset<T, DuplicateCheckLogsFindUniqueArgs<ExtArgs>>): Prisma__DuplicateCheckLogsClient<$Result.GetResult<Prisma.$DuplicateCheckLogsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DuplicateCheckLogs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DuplicateCheckLogsFindUniqueOrThrowArgs} args - Arguments to find a DuplicateCheckLogs
     * @example
     * // Get one DuplicateCheckLogs
     * const duplicateCheckLogs = await prisma.duplicateCheckLogs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DuplicateCheckLogsFindUniqueOrThrowArgs>(args: SelectSubset<T, DuplicateCheckLogsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DuplicateCheckLogsClient<$Result.GetResult<Prisma.$DuplicateCheckLogsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DuplicateCheckLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DuplicateCheckLogsFindFirstArgs} args - Arguments to find a DuplicateCheckLogs
     * @example
     * // Get one DuplicateCheckLogs
     * const duplicateCheckLogs = await prisma.duplicateCheckLogs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DuplicateCheckLogsFindFirstArgs>(args?: SelectSubset<T, DuplicateCheckLogsFindFirstArgs<ExtArgs>>): Prisma__DuplicateCheckLogsClient<$Result.GetResult<Prisma.$DuplicateCheckLogsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DuplicateCheckLogs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DuplicateCheckLogsFindFirstOrThrowArgs} args - Arguments to find a DuplicateCheckLogs
     * @example
     * // Get one DuplicateCheckLogs
     * const duplicateCheckLogs = await prisma.duplicateCheckLogs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DuplicateCheckLogsFindFirstOrThrowArgs>(args?: SelectSubset<T, DuplicateCheckLogsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DuplicateCheckLogsClient<$Result.GetResult<Prisma.$DuplicateCheckLogsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DuplicateCheckLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DuplicateCheckLogsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DuplicateCheckLogs
     * const duplicateCheckLogs = await prisma.duplicateCheckLogs.findMany()
     * 
     * // Get first 10 DuplicateCheckLogs
     * const duplicateCheckLogs = await prisma.duplicateCheckLogs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const duplicateCheckLogsWithIdOnly = await prisma.duplicateCheckLogs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DuplicateCheckLogsFindManyArgs>(args?: SelectSubset<T, DuplicateCheckLogsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DuplicateCheckLogsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DuplicateCheckLogs.
     * @param {DuplicateCheckLogsCreateArgs} args - Arguments to create a DuplicateCheckLogs.
     * @example
     * // Create one DuplicateCheckLogs
     * const DuplicateCheckLogs = await prisma.duplicateCheckLogs.create({
     *   data: {
     *     // ... data to create a DuplicateCheckLogs
     *   }
     * })
     * 
     */
    create<T extends DuplicateCheckLogsCreateArgs>(args: SelectSubset<T, DuplicateCheckLogsCreateArgs<ExtArgs>>): Prisma__DuplicateCheckLogsClient<$Result.GetResult<Prisma.$DuplicateCheckLogsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DuplicateCheckLogs.
     * @param {DuplicateCheckLogsCreateManyArgs} args - Arguments to create many DuplicateCheckLogs.
     * @example
     * // Create many DuplicateCheckLogs
     * const duplicateCheckLogs = await prisma.duplicateCheckLogs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DuplicateCheckLogsCreateManyArgs>(args?: SelectSubset<T, DuplicateCheckLogsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DuplicateCheckLogs and returns the data saved in the database.
     * @param {DuplicateCheckLogsCreateManyAndReturnArgs} args - Arguments to create many DuplicateCheckLogs.
     * @example
     * // Create many DuplicateCheckLogs
     * const duplicateCheckLogs = await prisma.duplicateCheckLogs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DuplicateCheckLogs and only return the `id`
     * const duplicateCheckLogsWithIdOnly = await prisma.duplicateCheckLogs.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DuplicateCheckLogsCreateManyAndReturnArgs>(args?: SelectSubset<T, DuplicateCheckLogsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DuplicateCheckLogsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DuplicateCheckLogs.
     * @param {DuplicateCheckLogsDeleteArgs} args - Arguments to delete one DuplicateCheckLogs.
     * @example
     * // Delete one DuplicateCheckLogs
     * const DuplicateCheckLogs = await prisma.duplicateCheckLogs.delete({
     *   where: {
     *     // ... filter to delete one DuplicateCheckLogs
     *   }
     * })
     * 
     */
    delete<T extends DuplicateCheckLogsDeleteArgs>(args: SelectSubset<T, DuplicateCheckLogsDeleteArgs<ExtArgs>>): Prisma__DuplicateCheckLogsClient<$Result.GetResult<Prisma.$DuplicateCheckLogsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DuplicateCheckLogs.
     * @param {DuplicateCheckLogsUpdateArgs} args - Arguments to update one DuplicateCheckLogs.
     * @example
     * // Update one DuplicateCheckLogs
     * const duplicateCheckLogs = await prisma.duplicateCheckLogs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DuplicateCheckLogsUpdateArgs>(args: SelectSubset<T, DuplicateCheckLogsUpdateArgs<ExtArgs>>): Prisma__DuplicateCheckLogsClient<$Result.GetResult<Prisma.$DuplicateCheckLogsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DuplicateCheckLogs.
     * @param {DuplicateCheckLogsDeleteManyArgs} args - Arguments to filter DuplicateCheckLogs to delete.
     * @example
     * // Delete a few DuplicateCheckLogs
     * const { count } = await prisma.duplicateCheckLogs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DuplicateCheckLogsDeleteManyArgs>(args?: SelectSubset<T, DuplicateCheckLogsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DuplicateCheckLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DuplicateCheckLogsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DuplicateCheckLogs
     * const duplicateCheckLogs = await prisma.duplicateCheckLogs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DuplicateCheckLogsUpdateManyArgs>(args: SelectSubset<T, DuplicateCheckLogsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DuplicateCheckLogs.
     * @param {DuplicateCheckLogsUpsertArgs} args - Arguments to update or create a DuplicateCheckLogs.
     * @example
     * // Update or create a DuplicateCheckLogs
     * const duplicateCheckLogs = await prisma.duplicateCheckLogs.upsert({
     *   create: {
     *     // ... data to create a DuplicateCheckLogs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DuplicateCheckLogs we want to update
     *   }
     * })
     */
    upsert<T extends DuplicateCheckLogsUpsertArgs>(args: SelectSubset<T, DuplicateCheckLogsUpsertArgs<ExtArgs>>): Prisma__DuplicateCheckLogsClient<$Result.GetResult<Prisma.$DuplicateCheckLogsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DuplicateCheckLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DuplicateCheckLogsCountArgs} args - Arguments to filter DuplicateCheckLogs to count.
     * @example
     * // Count the number of DuplicateCheckLogs
     * const count = await prisma.duplicateCheckLogs.count({
     *   where: {
     *     // ... the filter for the DuplicateCheckLogs we want to count
     *   }
     * })
    **/
    count<T extends DuplicateCheckLogsCountArgs>(
      args?: Subset<T, DuplicateCheckLogsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DuplicateCheckLogsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DuplicateCheckLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DuplicateCheckLogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DuplicateCheckLogsAggregateArgs>(args: Subset<T, DuplicateCheckLogsAggregateArgs>): Prisma.PrismaPromise<GetDuplicateCheckLogsAggregateType<T>>

    /**
     * Group by DuplicateCheckLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DuplicateCheckLogsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DuplicateCheckLogsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DuplicateCheckLogsGroupByArgs['orderBy'] }
        : { orderBy?: DuplicateCheckLogsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DuplicateCheckLogsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDuplicateCheckLogsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DuplicateCheckLogs model
   */
  readonly fields: DuplicateCheckLogsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DuplicateCheckLogs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DuplicateCheckLogsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DuplicateCheckLogs model
   */ 
  interface DuplicateCheckLogsFieldRefs {
    readonly id: FieldRef<"DuplicateCheckLogs", 'String'>
    readonly file_name: FieldRef<"DuplicateCheckLogs", 'String'>
    readonly file_size: FieldRef<"DuplicateCheckLogs", 'BigInt'>
    readonly file_hash: FieldRef<"DuplicateCheckLogs", 'String'>
    readonly import_type: FieldRef<"DuplicateCheckLogs", 'String'>
    readonly check_result: FieldRef<"DuplicateCheckLogs", 'Json'>
    readonly created_at: FieldRef<"DuplicateCheckLogs", 'DateTime'>
    readonly updated_at: FieldRef<"DuplicateCheckLogs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DuplicateCheckLogs findUnique
   */
  export type DuplicateCheckLogsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DuplicateCheckLogs
     */
    select?: DuplicateCheckLogsSelect<ExtArgs> | null
    /**
     * Filter, which DuplicateCheckLogs to fetch.
     */
    where: DuplicateCheckLogsWhereUniqueInput
  }

  /**
   * DuplicateCheckLogs findUniqueOrThrow
   */
  export type DuplicateCheckLogsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DuplicateCheckLogs
     */
    select?: DuplicateCheckLogsSelect<ExtArgs> | null
    /**
     * Filter, which DuplicateCheckLogs to fetch.
     */
    where: DuplicateCheckLogsWhereUniqueInput
  }

  /**
   * DuplicateCheckLogs findFirst
   */
  export type DuplicateCheckLogsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DuplicateCheckLogs
     */
    select?: DuplicateCheckLogsSelect<ExtArgs> | null
    /**
     * Filter, which DuplicateCheckLogs to fetch.
     */
    where?: DuplicateCheckLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DuplicateCheckLogs to fetch.
     */
    orderBy?: DuplicateCheckLogsOrderByWithRelationInput | DuplicateCheckLogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DuplicateCheckLogs.
     */
    cursor?: DuplicateCheckLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DuplicateCheckLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DuplicateCheckLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DuplicateCheckLogs.
     */
    distinct?: DuplicateCheckLogsScalarFieldEnum | DuplicateCheckLogsScalarFieldEnum[]
  }

  /**
   * DuplicateCheckLogs findFirstOrThrow
   */
  export type DuplicateCheckLogsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DuplicateCheckLogs
     */
    select?: DuplicateCheckLogsSelect<ExtArgs> | null
    /**
     * Filter, which DuplicateCheckLogs to fetch.
     */
    where?: DuplicateCheckLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DuplicateCheckLogs to fetch.
     */
    orderBy?: DuplicateCheckLogsOrderByWithRelationInput | DuplicateCheckLogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DuplicateCheckLogs.
     */
    cursor?: DuplicateCheckLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DuplicateCheckLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DuplicateCheckLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DuplicateCheckLogs.
     */
    distinct?: DuplicateCheckLogsScalarFieldEnum | DuplicateCheckLogsScalarFieldEnum[]
  }

  /**
   * DuplicateCheckLogs findMany
   */
  export type DuplicateCheckLogsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DuplicateCheckLogs
     */
    select?: DuplicateCheckLogsSelect<ExtArgs> | null
    /**
     * Filter, which DuplicateCheckLogs to fetch.
     */
    where?: DuplicateCheckLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DuplicateCheckLogs to fetch.
     */
    orderBy?: DuplicateCheckLogsOrderByWithRelationInput | DuplicateCheckLogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DuplicateCheckLogs.
     */
    cursor?: DuplicateCheckLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DuplicateCheckLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DuplicateCheckLogs.
     */
    skip?: number
    distinct?: DuplicateCheckLogsScalarFieldEnum | DuplicateCheckLogsScalarFieldEnum[]
  }

  /**
   * DuplicateCheckLogs create
   */
  export type DuplicateCheckLogsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DuplicateCheckLogs
     */
    select?: DuplicateCheckLogsSelect<ExtArgs> | null
    /**
     * The data needed to create a DuplicateCheckLogs.
     */
    data: XOR<DuplicateCheckLogsCreateInput, DuplicateCheckLogsUncheckedCreateInput>
  }

  /**
   * DuplicateCheckLogs createMany
   */
  export type DuplicateCheckLogsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DuplicateCheckLogs.
     */
    data: DuplicateCheckLogsCreateManyInput | DuplicateCheckLogsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DuplicateCheckLogs createManyAndReturn
   */
  export type DuplicateCheckLogsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DuplicateCheckLogs
     */
    select?: DuplicateCheckLogsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DuplicateCheckLogs.
     */
    data: DuplicateCheckLogsCreateManyInput | DuplicateCheckLogsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DuplicateCheckLogs update
   */
  export type DuplicateCheckLogsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DuplicateCheckLogs
     */
    select?: DuplicateCheckLogsSelect<ExtArgs> | null
    /**
     * The data needed to update a DuplicateCheckLogs.
     */
    data: XOR<DuplicateCheckLogsUpdateInput, DuplicateCheckLogsUncheckedUpdateInput>
    /**
     * Choose, which DuplicateCheckLogs to update.
     */
    where: DuplicateCheckLogsWhereUniqueInput
  }

  /**
   * DuplicateCheckLogs updateMany
   */
  export type DuplicateCheckLogsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DuplicateCheckLogs.
     */
    data: XOR<DuplicateCheckLogsUpdateManyMutationInput, DuplicateCheckLogsUncheckedUpdateManyInput>
    /**
     * Filter which DuplicateCheckLogs to update
     */
    where?: DuplicateCheckLogsWhereInput
  }

  /**
   * DuplicateCheckLogs upsert
   */
  export type DuplicateCheckLogsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DuplicateCheckLogs
     */
    select?: DuplicateCheckLogsSelect<ExtArgs> | null
    /**
     * The filter to search for the DuplicateCheckLogs to update in case it exists.
     */
    where: DuplicateCheckLogsWhereUniqueInput
    /**
     * In case the DuplicateCheckLogs found by the `where` argument doesn't exist, create a new DuplicateCheckLogs with this data.
     */
    create: XOR<DuplicateCheckLogsCreateInput, DuplicateCheckLogsUncheckedCreateInput>
    /**
     * In case the DuplicateCheckLogs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DuplicateCheckLogsUpdateInput, DuplicateCheckLogsUncheckedUpdateInput>
  }

  /**
   * DuplicateCheckLogs delete
   */
  export type DuplicateCheckLogsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DuplicateCheckLogs
     */
    select?: DuplicateCheckLogsSelect<ExtArgs> | null
    /**
     * Filter which DuplicateCheckLogs to delete.
     */
    where: DuplicateCheckLogsWhereUniqueInput
  }

  /**
   * DuplicateCheckLogs deleteMany
   */
  export type DuplicateCheckLogsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DuplicateCheckLogs to delete
     */
    where?: DuplicateCheckLogsWhereInput
  }

  /**
   * DuplicateCheckLogs without action
   */
  export type DuplicateCheckLogsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DuplicateCheckLogs
     */
    select?: DuplicateCheckLogsSelect<ExtArgs> | null
  }


  /**
   * Model ImportMetadata
   */

  export type AggregateImportMetadata = {
    _count: ImportMetadataCountAggregateOutputType | null
    _min: ImportMetadataMinAggregateOutputType | null
    _max: ImportMetadataMaxAggregateOutputType | null
  }

  export type ImportMetadataMinAggregateOutputType = {
    id: string | null
    import_history_id: string | null
    metadata_type: string | null
    created_at: Date | null
  }

  export type ImportMetadataMaxAggregateOutputType = {
    id: string | null
    import_history_id: string | null
    metadata_type: string | null
    created_at: Date | null
  }

  export type ImportMetadataCountAggregateOutputType = {
    id: number
    import_history_id: number
    metadata_type: number
    metadata: number
    created_at: number
    _all: number
  }


  export type ImportMetadataMinAggregateInputType = {
    id?: true
    import_history_id?: true
    metadata_type?: true
    created_at?: true
  }

  export type ImportMetadataMaxAggregateInputType = {
    id?: true
    import_history_id?: true
    metadata_type?: true
    created_at?: true
  }

  export type ImportMetadataCountAggregateInputType = {
    id?: true
    import_history_id?: true
    metadata_type?: true
    metadata?: true
    created_at?: true
    _all?: true
  }

  export type ImportMetadataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportMetadata to aggregate.
     */
    where?: ImportMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportMetadata to fetch.
     */
    orderBy?: ImportMetadataOrderByWithRelationInput | ImportMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImportMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImportMetadata
    **/
    _count?: true | ImportMetadataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImportMetadataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImportMetadataMaxAggregateInputType
  }

  export type GetImportMetadataAggregateType<T extends ImportMetadataAggregateArgs> = {
        [P in keyof T & keyof AggregateImportMetadata]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImportMetadata[P]>
      : GetScalarType<T[P], AggregateImportMetadata[P]>
  }




  export type ImportMetadataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImportMetadataWhereInput
    orderBy?: ImportMetadataOrderByWithAggregationInput | ImportMetadataOrderByWithAggregationInput[]
    by: ImportMetadataScalarFieldEnum[] | ImportMetadataScalarFieldEnum
    having?: ImportMetadataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImportMetadataCountAggregateInputType | true
    _min?: ImportMetadataMinAggregateInputType
    _max?: ImportMetadataMaxAggregateInputType
  }

  export type ImportMetadataGroupByOutputType = {
    id: string
    import_history_id: string
    metadata_type: string
    metadata: JsonValue
    created_at: Date
    _count: ImportMetadataCountAggregateOutputType | null
    _min: ImportMetadataMinAggregateOutputType | null
    _max: ImportMetadataMaxAggregateOutputType | null
  }

  type GetImportMetadataGroupByPayload<T extends ImportMetadataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImportMetadataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImportMetadataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImportMetadataGroupByOutputType[P]>
            : GetScalarType<T[P], ImportMetadataGroupByOutputType[P]>
        }
      >
    >


  export type ImportMetadataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    import_history_id?: boolean
    metadata_type?: boolean
    metadata?: boolean
    created_at?: boolean
    import_history?: boolean | ImportHistoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["importMetadata"]>

  export type ImportMetadataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    import_history_id?: boolean
    metadata_type?: boolean
    metadata?: boolean
    created_at?: boolean
    import_history?: boolean | ImportHistoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["importMetadata"]>

  export type ImportMetadataSelectScalar = {
    id?: boolean
    import_history_id?: boolean
    metadata_type?: boolean
    metadata?: boolean
    created_at?: boolean
  }

  export type ImportMetadataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    import_history?: boolean | ImportHistoryDefaultArgs<ExtArgs>
  }
  export type ImportMetadataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    import_history?: boolean | ImportHistoryDefaultArgs<ExtArgs>
  }

  export type $ImportMetadataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImportMetadata"
    objects: {
      import_history: Prisma.$ImportHistoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      import_history_id: string
      metadata_type: string
      metadata: Prisma.JsonValue
      created_at: Date
    }, ExtArgs["result"]["importMetadata"]>
    composites: {}
  }

  type ImportMetadataGetPayload<S extends boolean | null | undefined | ImportMetadataDefaultArgs> = $Result.GetResult<Prisma.$ImportMetadataPayload, S>

  type ImportMetadataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ImportMetadataFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ImportMetadataCountAggregateInputType | true
    }

  export interface ImportMetadataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImportMetadata'], meta: { name: 'ImportMetadata' } }
    /**
     * Find zero or one ImportMetadata that matches the filter.
     * @param {ImportMetadataFindUniqueArgs} args - Arguments to find a ImportMetadata
     * @example
     * // Get one ImportMetadata
     * const importMetadata = await prisma.importMetadata.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImportMetadataFindUniqueArgs>(args: SelectSubset<T, ImportMetadataFindUniqueArgs<ExtArgs>>): Prisma__ImportMetadataClient<$Result.GetResult<Prisma.$ImportMetadataPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ImportMetadata that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ImportMetadataFindUniqueOrThrowArgs} args - Arguments to find a ImportMetadata
     * @example
     * // Get one ImportMetadata
     * const importMetadata = await prisma.importMetadata.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImportMetadataFindUniqueOrThrowArgs>(args: SelectSubset<T, ImportMetadataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImportMetadataClient<$Result.GetResult<Prisma.$ImportMetadataPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ImportMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportMetadataFindFirstArgs} args - Arguments to find a ImportMetadata
     * @example
     * // Get one ImportMetadata
     * const importMetadata = await prisma.importMetadata.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImportMetadataFindFirstArgs>(args?: SelectSubset<T, ImportMetadataFindFirstArgs<ExtArgs>>): Prisma__ImportMetadataClient<$Result.GetResult<Prisma.$ImportMetadataPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ImportMetadata that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportMetadataFindFirstOrThrowArgs} args - Arguments to find a ImportMetadata
     * @example
     * // Get one ImportMetadata
     * const importMetadata = await prisma.importMetadata.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImportMetadataFindFirstOrThrowArgs>(args?: SelectSubset<T, ImportMetadataFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImportMetadataClient<$Result.GetResult<Prisma.$ImportMetadataPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ImportMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportMetadataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImportMetadata
     * const importMetadata = await prisma.importMetadata.findMany()
     * 
     * // Get first 10 ImportMetadata
     * const importMetadata = await prisma.importMetadata.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const importMetadataWithIdOnly = await prisma.importMetadata.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImportMetadataFindManyArgs>(args?: SelectSubset<T, ImportMetadataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportMetadataPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ImportMetadata.
     * @param {ImportMetadataCreateArgs} args - Arguments to create a ImportMetadata.
     * @example
     * // Create one ImportMetadata
     * const ImportMetadata = await prisma.importMetadata.create({
     *   data: {
     *     // ... data to create a ImportMetadata
     *   }
     * })
     * 
     */
    create<T extends ImportMetadataCreateArgs>(args: SelectSubset<T, ImportMetadataCreateArgs<ExtArgs>>): Prisma__ImportMetadataClient<$Result.GetResult<Prisma.$ImportMetadataPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ImportMetadata.
     * @param {ImportMetadataCreateManyArgs} args - Arguments to create many ImportMetadata.
     * @example
     * // Create many ImportMetadata
     * const importMetadata = await prisma.importMetadata.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImportMetadataCreateManyArgs>(args?: SelectSubset<T, ImportMetadataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ImportMetadata and returns the data saved in the database.
     * @param {ImportMetadataCreateManyAndReturnArgs} args - Arguments to create many ImportMetadata.
     * @example
     * // Create many ImportMetadata
     * const importMetadata = await prisma.importMetadata.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ImportMetadata and only return the `id`
     * const importMetadataWithIdOnly = await prisma.importMetadata.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImportMetadataCreateManyAndReturnArgs>(args?: SelectSubset<T, ImportMetadataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportMetadataPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ImportMetadata.
     * @param {ImportMetadataDeleteArgs} args - Arguments to delete one ImportMetadata.
     * @example
     * // Delete one ImportMetadata
     * const ImportMetadata = await prisma.importMetadata.delete({
     *   where: {
     *     // ... filter to delete one ImportMetadata
     *   }
     * })
     * 
     */
    delete<T extends ImportMetadataDeleteArgs>(args: SelectSubset<T, ImportMetadataDeleteArgs<ExtArgs>>): Prisma__ImportMetadataClient<$Result.GetResult<Prisma.$ImportMetadataPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ImportMetadata.
     * @param {ImportMetadataUpdateArgs} args - Arguments to update one ImportMetadata.
     * @example
     * // Update one ImportMetadata
     * const importMetadata = await prisma.importMetadata.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImportMetadataUpdateArgs>(args: SelectSubset<T, ImportMetadataUpdateArgs<ExtArgs>>): Prisma__ImportMetadataClient<$Result.GetResult<Prisma.$ImportMetadataPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ImportMetadata.
     * @param {ImportMetadataDeleteManyArgs} args - Arguments to filter ImportMetadata to delete.
     * @example
     * // Delete a few ImportMetadata
     * const { count } = await prisma.importMetadata.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImportMetadataDeleteManyArgs>(args?: SelectSubset<T, ImportMetadataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImportMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportMetadataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImportMetadata
     * const importMetadata = await prisma.importMetadata.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImportMetadataUpdateManyArgs>(args: SelectSubset<T, ImportMetadataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ImportMetadata.
     * @param {ImportMetadataUpsertArgs} args - Arguments to update or create a ImportMetadata.
     * @example
     * // Update or create a ImportMetadata
     * const importMetadata = await prisma.importMetadata.upsert({
     *   create: {
     *     // ... data to create a ImportMetadata
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImportMetadata we want to update
     *   }
     * })
     */
    upsert<T extends ImportMetadataUpsertArgs>(args: SelectSubset<T, ImportMetadataUpsertArgs<ExtArgs>>): Prisma__ImportMetadataClient<$Result.GetResult<Prisma.$ImportMetadataPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ImportMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportMetadataCountArgs} args - Arguments to filter ImportMetadata to count.
     * @example
     * // Count the number of ImportMetadata
     * const count = await prisma.importMetadata.count({
     *   where: {
     *     // ... the filter for the ImportMetadata we want to count
     *   }
     * })
    **/
    count<T extends ImportMetadataCountArgs>(
      args?: Subset<T, ImportMetadataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImportMetadataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImportMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportMetadataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImportMetadataAggregateArgs>(args: Subset<T, ImportMetadataAggregateArgs>): Prisma.PrismaPromise<GetImportMetadataAggregateType<T>>

    /**
     * Group by ImportMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportMetadataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImportMetadataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImportMetadataGroupByArgs['orderBy'] }
        : { orderBy?: ImportMetadataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImportMetadataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImportMetadataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImportMetadata model
   */
  readonly fields: ImportMetadataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImportMetadata.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImportMetadataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    import_history<T extends ImportHistoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ImportHistoryDefaultArgs<ExtArgs>>): Prisma__ImportHistoryClient<$Result.GetResult<Prisma.$ImportHistoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImportMetadata model
   */ 
  interface ImportMetadataFieldRefs {
    readonly id: FieldRef<"ImportMetadata", 'String'>
    readonly import_history_id: FieldRef<"ImportMetadata", 'String'>
    readonly metadata_type: FieldRef<"ImportMetadata", 'String'>
    readonly metadata: FieldRef<"ImportMetadata", 'Json'>
    readonly created_at: FieldRef<"ImportMetadata", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ImportMetadata findUnique
   */
  export type ImportMetadataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportMetadata
     */
    select?: ImportMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportMetadataInclude<ExtArgs> | null
    /**
     * Filter, which ImportMetadata to fetch.
     */
    where: ImportMetadataWhereUniqueInput
  }

  /**
   * ImportMetadata findUniqueOrThrow
   */
  export type ImportMetadataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportMetadata
     */
    select?: ImportMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportMetadataInclude<ExtArgs> | null
    /**
     * Filter, which ImportMetadata to fetch.
     */
    where: ImportMetadataWhereUniqueInput
  }

  /**
   * ImportMetadata findFirst
   */
  export type ImportMetadataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportMetadata
     */
    select?: ImportMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportMetadataInclude<ExtArgs> | null
    /**
     * Filter, which ImportMetadata to fetch.
     */
    where?: ImportMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportMetadata to fetch.
     */
    orderBy?: ImportMetadataOrderByWithRelationInput | ImportMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportMetadata.
     */
    cursor?: ImportMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportMetadata.
     */
    distinct?: ImportMetadataScalarFieldEnum | ImportMetadataScalarFieldEnum[]
  }

  /**
   * ImportMetadata findFirstOrThrow
   */
  export type ImportMetadataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportMetadata
     */
    select?: ImportMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportMetadataInclude<ExtArgs> | null
    /**
     * Filter, which ImportMetadata to fetch.
     */
    where?: ImportMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportMetadata to fetch.
     */
    orderBy?: ImportMetadataOrderByWithRelationInput | ImportMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportMetadata.
     */
    cursor?: ImportMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportMetadata.
     */
    distinct?: ImportMetadataScalarFieldEnum | ImportMetadataScalarFieldEnum[]
  }

  /**
   * ImportMetadata findMany
   */
  export type ImportMetadataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportMetadata
     */
    select?: ImportMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportMetadataInclude<ExtArgs> | null
    /**
     * Filter, which ImportMetadata to fetch.
     */
    where?: ImportMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportMetadata to fetch.
     */
    orderBy?: ImportMetadataOrderByWithRelationInput | ImportMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImportMetadata.
     */
    cursor?: ImportMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportMetadata.
     */
    skip?: number
    distinct?: ImportMetadataScalarFieldEnum | ImportMetadataScalarFieldEnum[]
  }

  /**
   * ImportMetadata create
   */
  export type ImportMetadataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportMetadata
     */
    select?: ImportMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportMetadataInclude<ExtArgs> | null
    /**
     * The data needed to create a ImportMetadata.
     */
    data: XOR<ImportMetadataCreateInput, ImportMetadataUncheckedCreateInput>
  }

  /**
   * ImportMetadata createMany
   */
  export type ImportMetadataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImportMetadata.
     */
    data: ImportMetadataCreateManyInput | ImportMetadataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ImportMetadata createManyAndReturn
   */
  export type ImportMetadataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportMetadata
     */
    select?: ImportMetadataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ImportMetadata.
     */
    data: ImportMetadataCreateManyInput | ImportMetadataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportMetadataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ImportMetadata update
   */
  export type ImportMetadataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportMetadata
     */
    select?: ImportMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportMetadataInclude<ExtArgs> | null
    /**
     * The data needed to update a ImportMetadata.
     */
    data: XOR<ImportMetadataUpdateInput, ImportMetadataUncheckedUpdateInput>
    /**
     * Choose, which ImportMetadata to update.
     */
    where: ImportMetadataWhereUniqueInput
  }

  /**
   * ImportMetadata updateMany
   */
  export type ImportMetadataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImportMetadata.
     */
    data: XOR<ImportMetadataUpdateManyMutationInput, ImportMetadataUncheckedUpdateManyInput>
    /**
     * Filter which ImportMetadata to update
     */
    where?: ImportMetadataWhereInput
  }

  /**
   * ImportMetadata upsert
   */
  export type ImportMetadataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportMetadata
     */
    select?: ImportMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportMetadataInclude<ExtArgs> | null
    /**
     * The filter to search for the ImportMetadata to update in case it exists.
     */
    where: ImportMetadataWhereUniqueInput
    /**
     * In case the ImportMetadata found by the `where` argument doesn't exist, create a new ImportMetadata with this data.
     */
    create: XOR<ImportMetadataCreateInput, ImportMetadataUncheckedCreateInput>
    /**
     * In case the ImportMetadata was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImportMetadataUpdateInput, ImportMetadataUncheckedUpdateInput>
  }

  /**
   * ImportMetadata delete
   */
  export type ImportMetadataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportMetadata
     */
    select?: ImportMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportMetadataInclude<ExtArgs> | null
    /**
     * Filter which ImportMetadata to delete.
     */
    where: ImportMetadataWhereUniqueInput
  }

  /**
   * ImportMetadata deleteMany
   */
  export type ImportMetadataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportMetadata to delete
     */
    where?: ImportMetadataWhereInput
  }

  /**
   * ImportMetadata without action
   */
  export type ImportMetadataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportMetadata
     */
    select?: ImportMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImportMetadataInclude<ExtArgs> | null
  }


  /**
   * Model Tailor
   */

  export type AggregateTailor = {
    _count: TailorCountAggregateOutputType | null
    _avg: TailorAvgAggregateOutputType | null
    _sum: TailorSumAggregateOutputType | null
    _min: TailorMinAggregateOutputType | null
    _max: TailorMaxAggregateOutputType | null
  }

  export type TailorAvgAggregateOutputType = {
    rating: number | null
  }

  export type TailorSumAggregateOutputType = {
    rating: number | null
  }

  export type TailorMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    contact_person: string | null
    phone: string | null
    email: string | null
    address: string | null
    specialization: string | null
    rating: number | null
    status: $Enums.TailorStatus | null
    payment_terms: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TailorMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    contact_person: string | null
    phone: string | null
    email: string | null
    address: string | null
    specialization: string | null
    rating: number | null
    status: $Enums.TailorStatus | null
    payment_terms: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TailorCountAggregateOutputType = {
    id: number
    code: number
    name: number
    contact_person: number
    phone: number
    email: number
    address: number
    specialization: number
    rating: number
    status: number
    payment_terms: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TailorAvgAggregateInputType = {
    rating?: true
  }

  export type TailorSumAggregateInputType = {
    rating?: true
  }

  export type TailorMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    contact_person?: true
    phone?: true
    email?: true
    address?: true
    specialization?: true
    rating?: true
    status?: true
    payment_terms?: true
    created_at?: true
    updated_at?: true
  }

  export type TailorMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    contact_person?: true
    phone?: true
    email?: true
    address?: true
    specialization?: true
    rating?: true
    status?: true
    payment_terms?: true
    created_at?: true
    updated_at?: true
  }

  export type TailorCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    contact_person?: true
    phone?: true
    email?: true
    address?: true
    specialization?: true
    rating?: true
    status?: true
    payment_terms?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TailorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tailor to aggregate.
     */
    where?: TailorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tailors to fetch.
     */
    orderBy?: TailorOrderByWithRelationInput | TailorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TailorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tailors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tailors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tailors
    **/
    _count?: true | TailorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TailorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TailorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TailorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TailorMaxAggregateInputType
  }

  export type GetTailorAggregateType<T extends TailorAggregateArgs> = {
        [P in keyof T & keyof AggregateTailor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTailor[P]>
      : GetScalarType<T[P], AggregateTailor[P]>
  }




  export type TailorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TailorWhereInput
    orderBy?: TailorOrderByWithAggregationInput | TailorOrderByWithAggregationInput[]
    by: TailorScalarFieldEnum[] | TailorScalarFieldEnum
    having?: TailorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TailorCountAggregateInputType | true
    _avg?: TailorAvgAggregateInputType
    _sum?: TailorSumAggregateInputType
    _min?: TailorMinAggregateInputType
    _max?: TailorMaxAggregateInputType
  }

  export type TailorGroupByOutputType = {
    id: string
    code: string
    name: string
    contact_person: string
    phone: string
    email: string
    address: string
    specialization: string
    rating: number
    status: $Enums.TailorStatus
    payment_terms: string
    created_at: Date
    updated_at: Date
    _count: TailorCountAggregateOutputType | null
    _avg: TailorAvgAggregateOutputType | null
    _sum: TailorSumAggregateOutputType | null
    _min: TailorMinAggregateOutputType | null
    _max: TailorMaxAggregateOutputType | null
  }

  type GetTailorGroupByPayload<T extends TailorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TailorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TailorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TailorGroupByOutputType[P]>
            : GetScalarType<T[P], TailorGroupByOutputType[P]>
        }
      >
    >


  export type TailorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    contact_person?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    specialization?: boolean
    rating?: boolean
    status?: boolean
    payment_terms?: boolean
    created_at?: boolean
    updated_at?: boolean
    productions?: boolean | Tailor$productionsArgs<ExtArgs>
    _count?: boolean | TailorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tailor"]>

  export type TailorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    contact_person?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    specialization?: boolean
    rating?: boolean
    status?: boolean
    payment_terms?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["tailor"]>

  export type TailorSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    contact_person?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    specialization?: boolean
    rating?: boolean
    status?: boolean
    payment_terms?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type TailorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    productions?: boolean | Tailor$productionsArgs<ExtArgs>
    _count?: boolean | TailorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TailorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TailorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tailor"
    objects: {
      productions: Prisma.$TailorProductionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      contact_person: string
      phone: string
      email: string
      address: string
      specialization: string
      rating: number
      status: $Enums.TailorStatus
      payment_terms: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["tailor"]>
    composites: {}
  }

  type TailorGetPayload<S extends boolean | null | undefined | TailorDefaultArgs> = $Result.GetResult<Prisma.$TailorPayload, S>

  type TailorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TailorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TailorCountAggregateInputType | true
    }

  export interface TailorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tailor'], meta: { name: 'Tailor' } }
    /**
     * Find zero or one Tailor that matches the filter.
     * @param {TailorFindUniqueArgs} args - Arguments to find a Tailor
     * @example
     * // Get one Tailor
     * const tailor = await prisma.tailor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TailorFindUniqueArgs>(args: SelectSubset<T, TailorFindUniqueArgs<ExtArgs>>): Prisma__TailorClient<$Result.GetResult<Prisma.$TailorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tailor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TailorFindUniqueOrThrowArgs} args - Arguments to find a Tailor
     * @example
     * // Get one Tailor
     * const tailor = await prisma.tailor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TailorFindUniqueOrThrowArgs>(args: SelectSubset<T, TailorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TailorClient<$Result.GetResult<Prisma.$TailorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tailor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailorFindFirstArgs} args - Arguments to find a Tailor
     * @example
     * // Get one Tailor
     * const tailor = await prisma.tailor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TailorFindFirstArgs>(args?: SelectSubset<T, TailorFindFirstArgs<ExtArgs>>): Prisma__TailorClient<$Result.GetResult<Prisma.$TailorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tailor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailorFindFirstOrThrowArgs} args - Arguments to find a Tailor
     * @example
     * // Get one Tailor
     * const tailor = await prisma.tailor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TailorFindFirstOrThrowArgs>(args?: SelectSubset<T, TailorFindFirstOrThrowArgs<ExtArgs>>): Prisma__TailorClient<$Result.GetResult<Prisma.$TailorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tailors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tailors
     * const tailors = await prisma.tailor.findMany()
     * 
     * // Get first 10 Tailors
     * const tailors = await prisma.tailor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tailorWithIdOnly = await prisma.tailor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TailorFindManyArgs>(args?: SelectSubset<T, TailorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TailorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tailor.
     * @param {TailorCreateArgs} args - Arguments to create a Tailor.
     * @example
     * // Create one Tailor
     * const Tailor = await prisma.tailor.create({
     *   data: {
     *     // ... data to create a Tailor
     *   }
     * })
     * 
     */
    create<T extends TailorCreateArgs>(args: SelectSubset<T, TailorCreateArgs<ExtArgs>>): Prisma__TailorClient<$Result.GetResult<Prisma.$TailorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tailors.
     * @param {TailorCreateManyArgs} args - Arguments to create many Tailors.
     * @example
     * // Create many Tailors
     * const tailor = await prisma.tailor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TailorCreateManyArgs>(args?: SelectSubset<T, TailorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tailors and returns the data saved in the database.
     * @param {TailorCreateManyAndReturnArgs} args - Arguments to create many Tailors.
     * @example
     * // Create many Tailors
     * const tailor = await prisma.tailor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tailors and only return the `id`
     * const tailorWithIdOnly = await prisma.tailor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TailorCreateManyAndReturnArgs>(args?: SelectSubset<T, TailorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TailorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tailor.
     * @param {TailorDeleteArgs} args - Arguments to delete one Tailor.
     * @example
     * // Delete one Tailor
     * const Tailor = await prisma.tailor.delete({
     *   where: {
     *     // ... filter to delete one Tailor
     *   }
     * })
     * 
     */
    delete<T extends TailorDeleteArgs>(args: SelectSubset<T, TailorDeleteArgs<ExtArgs>>): Prisma__TailorClient<$Result.GetResult<Prisma.$TailorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tailor.
     * @param {TailorUpdateArgs} args - Arguments to update one Tailor.
     * @example
     * // Update one Tailor
     * const tailor = await prisma.tailor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TailorUpdateArgs>(args: SelectSubset<T, TailorUpdateArgs<ExtArgs>>): Prisma__TailorClient<$Result.GetResult<Prisma.$TailorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tailors.
     * @param {TailorDeleteManyArgs} args - Arguments to filter Tailors to delete.
     * @example
     * // Delete a few Tailors
     * const { count } = await prisma.tailor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TailorDeleteManyArgs>(args?: SelectSubset<T, TailorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tailors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tailors
     * const tailor = await prisma.tailor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TailorUpdateManyArgs>(args: SelectSubset<T, TailorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tailor.
     * @param {TailorUpsertArgs} args - Arguments to update or create a Tailor.
     * @example
     * // Update or create a Tailor
     * const tailor = await prisma.tailor.upsert({
     *   create: {
     *     // ... data to create a Tailor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tailor we want to update
     *   }
     * })
     */
    upsert<T extends TailorUpsertArgs>(args: SelectSubset<T, TailorUpsertArgs<ExtArgs>>): Prisma__TailorClient<$Result.GetResult<Prisma.$TailorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tailors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailorCountArgs} args - Arguments to filter Tailors to count.
     * @example
     * // Count the number of Tailors
     * const count = await prisma.tailor.count({
     *   where: {
     *     // ... the filter for the Tailors we want to count
     *   }
     * })
    **/
    count<T extends TailorCountArgs>(
      args?: Subset<T, TailorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TailorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tailor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TailorAggregateArgs>(args: Subset<T, TailorAggregateArgs>): Prisma.PrismaPromise<GetTailorAggregateType<T>>

    /**
     * Group by Tailor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TailorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TailorGroupByArgs['orderBy'] }
        : { orderBy?: TailorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TailorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTailorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tailor model
   */
  readonly fields: TailorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tailor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TailorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    productions<T extends Tailor$productionsArgs<ExtArgs> = {}>(args?: Subset<T, Tailor$productionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TailorProductionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tailor model
   */ 
  interface TailorFieldRefs {
    readonly id: FieldRef<"Tailor", 'String'>
    readonly code: FieldRef<"Tailor", 'String'>
    readonly name: FieldRef<"Tailor", 'String'>
    readonly contact_person: FieldRef<"Tailor", 'String'>
    readonly phone: FieldRef<"Tailor", 'String'>
    readonly email: FieldRef<"Tailor", 'String'>
    readonly address: FieldRef<"Tailor", 'String'>
    readonly specialization: FieldRef<"Tailor", 'String'>
    readonly rating: FieldRef<"Tailor", 'Float'>
    readonly status: FieldRef<"Tailor", 'TailorStatus'>
    readonly payment_terms: FieldRef<"Tailor", 'String'>
    readonly created_at: FieldRef<"Tailor", 'DateTime'>
    readonly updated_at: FieldRef<"Tailor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tailor findUnique
   */
  export type TailorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tailor
     */
    select?: TailorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorInclude<ExtArgs> | null
    /**
     * Filter, which Tailor to fetch.
     */
    where: TailorWhereUniqueInput
  }

  /**
   * Tailor findUniqueOrThrow
   */
  export type TailorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tailor
     */
    select?: TailorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorInclude<ExtArgs> | null
    /**
     * Filter, which Tailor to fetch.
     */
    where: TailorWhereUniqueInput
  }

  /**
   * Tailor findFirst
   */
  export type TailorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tailor
     */
    select?: TailorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorInclude<ExtArgs> | null
    /**
     * Filter, which Tailor to fetch.
     */
    where?: TailorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tailors to fetch.
     */
    orderBy?: TailorOrderByWithRelationInput | TailorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tailors.
     */
    cursor?: TailorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tailors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tailors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tailors.
     */
    distinct?: TailorScalarFieldEnum | TailorScalarFieldEnum[]
  }

  /**
   * Tailor findFirstOrThrow
   */
  export type TailorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tailor
     */
    select?: TailorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorInclude<ExtArgs> | null
    /**
     * Filter, which Tailor to fetch.
     */
    where?: TailorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tailors to fetch.
     */
    orderBy?: TailorOrderByWithRelationInput | TailorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tailors.
     */
    cursor?: TailorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tailors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tailors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tailors.
     */
    distinct?: TailorScalarFieldEnum | TailorScalarFieldEnum[]
  }

  /**
   * Tailor findMany
   */
  export type TailorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tailor
     */
    select?: TailorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorInclude<ExtArgs> | null
    /**
     * Filter, which Tailors to fetch.
     */
    where?: TailorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tailors to fetch.
     */
    orderBy?: TailorOrderByWithRelationInput | TailorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tailors.
     */
    cursor?: TailorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tailors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tailors.
     */
    skip?: number
    distinct?: TailorScalarFieldEnum | TailorScalarFieldEnum[]
  }

  /**
   * Tailor create
   */
  export type TailorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tailor
     */
    select?: TailorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorInclude<ExtArgs> | null
    /**
     * The data needed to create a Tailor.
     */
    data: XOR<TailorCreateInput, TailorUncheckedCreateInput>
  }

  /**
   * Tailor createMany
   */
  export type TailorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tailors.
     */
    data: TailorCreateManyInput | TailorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tailor createManyAndReturn
   */
  export type TailorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tailor
     */
    select?: TailorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tailors.
     */
    data: TailorCreateManyInput | TailorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tailor update
   */
  export type TailorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tailor
     */
    select?: TailorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorInclude<ExtArgs> | null
    /**
     * The data needed to update a Tailor.
     */
    data: XOR<TailorUpdateInput, TailorUncheckedUpdateInput>
    /**
     * Choose, which Tailor to update.
     */
    where: TailorWhereUniqueInput
  }

  /**
   * Tailor updateMany
   */
  export type TailorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tailors.
     */
    data: XOR<TailorUpdateManyMutationInput, TailorUncheckedUpdateManyInput>
    /**
     * Filter which Tailors to update
     */
    where?: TailorWhereInput
  }

  /**
   * Tailor upsert
   */
  export type TailorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tailor
     */
    select?: TailorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorInclude<ExtArgs> | null
    /**
     * The filter to search for the Tailor to update in case it exists.
     */
    where: TailorWhereUniqueInput
    /**
     * In case the Tailor found by the `where` argument doesn't exist, create a new Tailor with this data.
     */
    create: XOR<TailorCreateInput, TailorUncheckedCreateInput>
    /**
     * In case the Tailor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TailorUpdateInput, TailorUncheckedUpdateInput>
  }

  /**
   * Tailor delete
   */
  export type TailorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tailor
     */
    select?: TailorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorInclude<ExtArgs> | null
    /**
     * Filter which Tailor to delete.
     */
    where: TailorWhereUniqueInput
  }

  /**
   * Tailor deleteMany
   */
  export type TailorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tailors to delete
     */
    where?: TailorWhereInput
  }

  /**
   * Tailor.productions
   */
  export type Tailor$productionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailorProduction
     */
    select?: TailorProductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorProductionInclude<ExtArgs> | null
    where?: TailorProductionWhereInput
    orderBy?: TailorProductionOrderByWithRelationInput | TailorProductionOrderByWithRelationInput[]
    cursor?: TailorProductionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TailorProductionScalarFieldEnum | TailorProductionScalarFieldEnum[]
  }

  /**
   * Tailor without action
   */
  export type TailorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tailor
     */
    select?: TailorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorInclude<ExtArgs> | null
  }


  /**
   * Model TailorProduction
   */

  export type AggregateTailorProduction = {
    _count: TailorProductionCountAggregateOutputType | null
    _avg: TailorProductionAvgAggregateOutputType | null
    _sum: TailorProductionSumAggregateOutputType | null
    _min: TailorProductionMinAggregateOutputType | null
    _max: TailorProductionMaxAggregateOutputType | null
  }

  export type TailorProductionAvgAggregateOutputType = {
    finished_stock: number | null
    meters_needed: number | null
    cost_per_piece: number | null
    defective_stock: number | null
    additional_costs: number | null
  }

  export type TailorProductionSumAggregateOutputType = {
    finished_stock: number | null
    meters_needed: number | null
    cost_per_piece: number | null
    defective_stock: number | null
    additional_costs: number | null
  }

  export type TailorProductionMinAggregateOutputType = {
    id: string | null
    tailor_id: string | null
    product_name: string | null
    color: string | null
    size: string | null
    finished_stock: number | null
    meters_needed: number | null
    cost_per_piece: number | null
    defective_stock: number | null
    additional_costs: number | null
    additional_cost_description: string | null
    delivery_date: Date | null
    notes: string | null
    status: $Enums.TailorProductionStatus | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TailorProductionMaxAggregateOutputType = {
    id: string | null
    tailor_id: string | null
    product_name: string | null
    color: string | null
    size: string | null
    finished_stock: number | null
    meters_needed: number | null
    cost_per_piece: number | null
    defective_stock: number | null
    additional_costs: number | null
    additional_cost_description: string | null
    delivery_date: Date | null
    notes: string | null
    status: $Enums.TailorProductionStatus | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TailorProductionCountAggregateOutputType = {
    id: number
    tailor_id: number
    product_name: number
    color: number
    size: number
    finished_stock: number
    meters_needed: number
    cost_per_piece: number
    defective_stock: number
    additional_costs: number
    additional_cost_description: number
    delivery_date: number
    notes: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TailorProductionAvgAggregateInputType = {
    finished_stock?: true
    meters_needed?: true
    cost_per_piece?: true
    defective_stock?: true
    additional_costs?: true
  }

  export type TailorProductionSumAggregateInputType = {
    finished_stock?: true
    meters_needed?: true
    cost_per_piece?: true
    defective_stock?: true
    additional_costs?: true
  }

  export type TailorProductionMinAggregateInputType = {
    id?: true
    tailor_id?: true
    product_name?: true
    color?: true
    size?: true
    finished_stock?: true
    meters_needed?: true
    cost_per_piece?: true
    defective_stock?: true
    additional_costs?: true
    additional_cost_description?: true
    delivery_date?: true
    notes?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type TailorProductionMaxAggregateInputType = {
    id?: true
    tailor_id?: true
    product_name?: true
    color?: true
    size?: true
    finished_stock?: true
    meters_needed?: true
    cost_per_piece?: true
    defective_stock?: true
    additional_costs?: true
    additional_cost_description?: true
    delivery_date?: true
    notes?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type TailorProductionCountAggregateInputType = {
    id?: true
    tailor_id?: true
    product_name?: true
    color?: true
    size?: true
    finished_stock?: true
    meters_needed?: true
    cost_per_piece?: true
    defective_stock?: true
    additional_costs?: true
    additional_cost_description?: true
    delivery_date?: true
    notes?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TailorProductionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TailorProduction to aggregate.
     */
    where?: TailorProductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TailorProductions to fetch.
     */
    orderBy?: TailorProductionOrderByWithRelationInput | TailorProductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TailorProductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TailorProductions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TailorProductions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TailorProductions
    **/
    _count?: true | TailorProductionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TailorProductionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TailorProductionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TailorProductionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TailorProductionMaxAggregateInputType
  }

  export type GetTailorProductionAggregateType<T extends TailorProductionAggregateArgs> = {
        [P in keyof T & keyof AggregateTailorProduction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTailorProduction[P]>
      : GetScalarType<T[P], AggregateTailorProduction[P]>
  }




  export type TailorProductionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TailorProductionWhereInput
    orderBy?: TailorProductionOrderByWithAggregationInput | TailorProductionOrderByWithAggregationInput[]
    by: TailorProductionScalarFieldEnum[] | TailorProductionScalarFieldEnum
    having?: TailorProductionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TailorProductionCountAggregateInputType | true
    _avg?: TailorProductionAvgAggregateInputType
    _sum?: TailorProductionSumAggregateInputType
    _min?: TailorProductionMinAggregateInputType
    _max?: TailorProductionMaxAggregateInputType
  }

  export type TailorProductionGroupByOutputType = {
    id: string
    tailor_id: string
    product_name: string
    color: string
    size: string
    finished_stock: number
    meters_needed: number
    cost_per_piece: number
    defective_stock: number | null
    additional_costs: number | null
    additional_cost_description: string | null
    delivery_date: Date | null
    notes: string | null
    status: $Enums.TailorProductionStatus
    created_at: Date
    updated_at: Date
    _count: TailorProductionCountAggregateOutputType | null
    _avg: TailorProductionAvgAggregateOutputType | null
    _sum: TailorProductionSumAggregateOutputType | null
    _min: TailorProductionMinAggregateOutputType | null
    _max: TailorProductionMaxAggregateOutputType | null
  }

  type GetTailorProductionGroupByPayload<T extends TailorProductionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TailorProductionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TailorProductionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TailorProductionGroupByOutputType[P]>
            : GetScalarType<T[P], TailorProductionGroupByOutputType[P]>
        }
      >
    >


  export type TailorProductionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tailor_id?: boolean
    product_name?: boolean
    color?: boolean
    size?: boolean
    finished_stock?: boolean
    meters_needed?: boolean
    cost_per_piece?: boolean
    defective_stock?: boolean
    additional_costs?: boolean
    additional_cost_description?: boolean
    delivery_date?: boolean
    notes?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    tailor?: boolean | TailorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tailorProduction"]>

  export type TailorProductionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tailor_id?: boolean
    product_name?: boolean
    color?: boolean
    size?: boolean
    finished_stock?: boolean
    meters_needed?: boolean
    cost_per_piece?: boolean
    defective_stock?: boolean
    additional_costs?: boolean
    additional_cost_description?: boolean
    delivery_date?: boolean
    notes?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    tailor?: boolean | TailorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tailorProduction"]>

  export type TailorProductionSelectScalar = {
    id?: boolean
    tailor_id?: boolean
    product_name?: boolean
    color?: boolean
    size?: boolean
    finished_stock?: boolean
    meters_needed?: boolean
    cost_per_piece?: boolean
    defective_stock?: boolean
    additional_costs?: boolean
    additional_cost_description?: boolean
    delivery_date?: boolean
    notes?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type TailorProductionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tailor?: boolean | TailorDefaultArgs<ExtArgs>
  }
  export type TailorProductionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tailor?: boolean | TailorDefaultArgs<ExtArgs>
  }

  export type $TailorProductionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TailorProduction"
    objects: {
      tailor: Prisma.$TailorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tailor_id: string
      product_name: string
      color: string
      size: string
      finished_stock: number
      meters_needed: number
      cost_per_piece: number
      defective_stock: number | null
      additional_costs: number | null
      additional_cost_description: string | null
      delivery_date: Date | null
      notes: string | null
      status: $Enums.TailorProductionStatus
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["tailorProduction"]>
    composites: {}
  }

  type TailorProductionGetPayload<S extends boolean | null | undefined | TailorProductionDefaultArgs> = $Result.GetResult<Prisma.$TailorProductionPayload, S>

  type TailorProductionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TailorProductionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TailorProductionCountAggregateInputType | true
    }

  export interface TailorProductionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TailorProduction'], meta: { name: 'TailorProduction' } }
    /**
     * Find zero or one TailorProduction that matches the filter.
     * @param {TailorProductionFindUniqueArgs} args - Arguments to find a TailorProduction
     * @example
     * // Get one TailorProduction
     * const tailorProduction = await prisma.tailorProduction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TailorProductionFindUniqueArgs>(args: SelectSubset<T, TailorProductionFindUniqueArgs<ExtArgs>>): Prisma__TailorProductionClient<$Result.GetResult<Prisma.$TailorProductionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TailorProduction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TailorProductionFindUniqueOrThrowArgs} args - Arguments to find a TailorProduction
     * @example
     * // Get one TailorProduction
     * const tailorProduction = await prisma.tailorProduction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TailorProductionFindUniqueOrThrowArgs>(args: SelectSubset<T, TailorProductionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TailorProductionClient<$Result.GetResult<Prisma.$TailorProductionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TailorProduction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailorProductionFindFirstArgs} args - Arguments to find a TailorProduction
     * @example
     * // Get one TailorProduction
     * const tailorProduction = await prisma.tailorProduction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TailorProductionFindFirstArgs>(args?: SelectSubset<T, TailorProductionFindFirstArgs<ExtArgs>>): Prisma__TailorProductionClient<$Result.GetResult<Prisma.$TailorProductionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TailorProduction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailorProductionFindFirstOrThrowArgs} args - Arguments to find a TailorProduction
     * @example
     * // Get one TailorProduction
     * const tailorProduction = await prisma.tailorProduction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TailorProductionFindFirstOrThrowArgs>(args?: SelectSubset<T, TailorProductionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TailorProductionClient<$Result.GetResult<Prisma.$TailorProductionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TailorProductions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailorProductionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TailorProductions
     * const tailorProductions = await prisma.tailorProduction.findMany()
     * 
     * // Get first 10 TailorProductions
     * const tailorProductions = await prisma.tailorProduction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tailorProductionWithIdOnly = await prisma.tailorProduction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TailorProductionFindManyArgs>(args?: SelectSubset<T, TailorProductionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TailorProductionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TailorProduction.
     * @param {TailorProductionCreateArgs} args - Arguments to create a TailorProduction.
     * @example
     * // Create one TailorProduction
     * const TailorProduction = await prisma.tailorProduction.create({
     *   data: {
     *     // ... data to create a TailorProduction
     *   }
     * })
     * 
     */
    create<T extends TailorProductionCreateArgs>(args: SelectSubset<T, TailorProductionCreateArgs<ExtArgs>>): Prisma__TailorProductionClient<$Result.GetResult<Prisma.$TailorProductionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TailorProductions.
     * @param {TailorProductionCreateManyArgs} args - Arguments to create many TailorProductions.
     * @example
     * // Create many TailorProductions
     * const tailorProduction = await prisma.tailorProduction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TailorProductionCreateManyArgs>(args?: SelectSubset<T, TailorProductionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TailorProductions and returns the data saved in the database.
     * @param {TailorProductionCreateManyAndReturnArgs} args - Arguments to create many TailorProductions.
     * @example
     * // Create many TailorProductions
     * const tailorProduction = await prisma.tailorProduction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TailorProductions and only return the `id`
     * const tailorProductionWithIdOnly = await prisma.tailorProduction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TailorProductionCreateManyAndReturnArgs>(args?: SelectSubset<T, TailorProductionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TailorProductionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TailorProduction.
     * @param {TailorProductionDeleteArgs} args - Arguments to delete one TailorProduction.
     * @example
     * // Delete one TailorProduction
     * const TailorProduction = await prisma.tailorProduction.delete({
     *   where: {
     *     // ... filter to delete one TailorProduction
     *   }
     * })
     * 
     */
    delete<T extends TailorProductionDeleteArgs>(args: SelectSubset<T, TailorProductionDeleteArgs<ExtArgs>>): Prisma__TailorProductionClient<$Result.GetResult<Prisma.$TailorProductionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TailorProduction.
     * @param {TailorProductionUpdateArgs} args - Arguments to update one TailorProduction.
     * @example
     * // Update one TailorProduction
     * const tailorProduction = await prisma.tailorProduction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TailorProductionUpdateArgs>(args: SelectSubset<T, TailorProductionUpdateArgs<ExtArgs>>): Prisma__TailorProductionClient<$Result.GetResult<Prisma.$TailorProductionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TailorProductions.
     * @param {TailorProductionDeleteManyArgs} args - Arguments to filter TailorProductions to delete.
     * @example
     * // Delete a few TailorProductions
     * const { count } = await prisma.tailorProduction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TailorProductionDeleteManyArgs>(args?: SelectSubset<T, TailorProductionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TailorProductions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailorProductionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TailorProductions
     * const tailorProduction = await prisma.tailorProduction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TailorProductionUpdateManyArgs>(args: SelectSubset<T, TailorProductionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TailorProduction.
     * @param {TailorProductionUpsertArgs} args - Arguments to update or create a TailorProduction.
     * @example
     * // Update or create a TailorProduction
     * const tailorProduction = await prisma.tailorProduction.upsert({
     *   create: {
     *     // ... data to create a TailorProduction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TailorProduction we want to update
     *   }
     * })
     */
    upsert<T extends TailorProductionUpsertArgs>(args: SelectSubset<T, TailorProductionUpsertArgs<ExtArgs>>): Prisma__TailorProductionClient<$Result.GetResult<Prisma.$TailorProductionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TailorProductions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailorProductionCountArgs} args - Arguments to filter TailorProductions to count.
     * @example
     * // Count the number of TailorProductions
     * const count = await prisma.tailorProduction.count({
     *   where: {
     *     // ... the filter for the TailorProductions we want to count
     *   }
     * })
    **/
    count<T extends TailorProductionCountArgs>(
      args?: Subset<T, TailorProductionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TailorProductionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TailorProduction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailorProductionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TailorProductionAggregateArgs>(args: Subset<T, TailorProductionAggregateArgs>): Prisma.PrismaPromise<GetTailorProductionAggregateType<T>>

    /**
     * Group by TailorProduction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TailorProductionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TailorProductionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TailorProductionGroupByArgs['orderBy'] }
        : { orderBy?: TailorProductionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TailorProductionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTailorProductionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TailorProduction model
   */
  readonly fields: TailorProductionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TailorProduction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TailorProductionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tailor<T extends TailorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TailorDefaultArgs<ExtArgs>>): Prisma__TailorClient<$Result.GetResult<Prisma.$TailorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TailorProduction model
   */ 
  interface TailorProductionFieldRefs {
    readonly id: FieldRef<"TailorProduction", 'String'>
    readonly tailor_id: FieldRef<"TailorProduction", 'String'>
    readonly product_name: FieldRef<"TailorProduction", 'String'>
    readonly color: FieldRef<"TailorProduction", 'String'>
    readonly size: FieldRef<"TailorProduction", 'String'>
    readonly finished_stock: FieldRef<"TailorProduction", 'Int'>
    readonly meters_needed: FieldRef<"TailorProduction", 'Float'>
    readonly cost_per_piece: FieldRef<"TailorProduction", 'Float'>
    readonly defective_stock: FieldRef<"TailorProduction", 'Int'>
    readonly additional_costs: FieldRef<"TailorProduction", 'Float'>
    readonly additional_cost_description: FieldRef<"TailorProduction", 'String'>
    readonly delivery_date: FieldRef<"TailorProduction", 'DateTime'>
    readonly notes: FieldRef<"TailorProduction", 'String'>
    readonly status: FieldRef<"TailorProduction", 'TailorProductionStatus'>
    readonly created_at: FieldRef<"TailorProduction", 'DateTime'>
    readonly updated_at: FieldRef<"TailorProduction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TailorProduction findUnique
   */
  export type TailorProductionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailorProduction
     */
    select?: TailorProductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorProductionInclude<ExtArgs> | null
    /**
     * Filter, which TailorProduction to fetch.
     */
    where: TailorProductionWhereUniqueInput
  }

  /**
   * TailorProduction findUniqueOrThrow
   */
  export type TailorProductionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailorProduction
     */
    select?: TailorProductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorProductionInclude<ExtArgs> | null
    /**
     * Filter, which TailorProduction to fetch.
     */
    where: TailorProductionWhereUniqueInput
  }

  /**
   * TailorProduction findFirst
   */
  export type TailorProductionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailorProduction
     */
    select?: TailorProductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorProductionInclude<ExtArgs> | null
    /**
     * Filter, which TailorProduction to fetch.
     */
    where?: TailorProductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TailorProductions to fetch.
     */
    orderBy?: TailorProductionOrderByWithRelationInput | TailorProductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TailorProductions.
     */
    cursor?: TailorProductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TailorProductions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TailorProductions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TailorProductions.
     */
    distinct?: TailorProductionScalarFieldEnum | TailorProductionScalarFieldEnum[]
  }

  /**
   * TailorProduction findFirstOrThrow
   */
  export type TailorProductionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailorProduction
     */
    select?: TailorProductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorProductionInclude<ExtArgs> | null
    /**
     * Filter, which TailorProduction to fetch.
     */
    where?: TailorProductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TailorProductions to fetch.
     */
    orderBy?: TailorProductionOrderByWithRelationInput | TailorProductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TailorProductions.
     */
    cursor?: TailorProductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TailorProductions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TailorProductions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TailorProductions.
     */
    distinct?: TailorProductionScalarFieldEnum | TailorProductionScalarFieldEnum[]
  }

  /**
   * TailorProduction findMany
   */
  export type TailorProductionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailorProduction
     */
    select?: TailorProductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorProductionInclude<ExtArgs> | null
    /**
     * Filter, which TailorProductions to fetch.
     */
    where?: TailorProductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TailorProductions to fetch.
     */
    orderBy?: TailorProductionOrderByWithRelationInput | TailorProductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TailorProductions.
     */
    cursor?: TailorProductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TailorProductions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TailorProductions.
     */
    skip?: number
    distinct?: TailorProductionScalarFieldEnum | TailorProductionScalarFieldEnum[]
  }

  /**
   * TailorProduction create
   */
  export type TailorProductionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailorProduction
     */
    select?: TailorProductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorProductionInclude<ExtArgs> | null
    /**
     * The data needed to create a TailorProduction.
     */
    data: XOR<TailorProductionCreateInput, TailorProductionUncheckedCreateInput>
  }

  /**
   * TailorProduction createMany
   */
  export type TailorProductionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TailorProductions.
     */
    data: TailorProductionCreateManyInput | TailorProductionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TailorProduction createManyAndReturn
   */
  export type TailorProductionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailorProduction
     */
    select?: TailorProductionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TailorProductions.
     */
    data: TailorProductionCreateManyInput | TailorProductionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorProductionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TailorProduction update
   */
  export type TailorProductionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailorProduction
     */
    select?: TailorProductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorProductionInclude<ExtArgs> | null
    /**
     * The data needed to update a TailorProduction.
     */
    data: XOR<TailorProductionUpdateInput, TailorProductionUncheckedUpdateInput>
    /**
     * Choose, which TailorProduction to update.
     */
    where: TailorProductionWhereUniqueInput
  }

  /**
   * TailorProduction updateMany
   */
  export type TailorProductionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TailorProductions.
     */
    data: XOR<TailorProductionUpdateManyMutationInput, TailorProductionUncheckedUpdateManyInput>
    /**
     * Filter which TailorProductions to update
     */
    where?: TailorProductionWhereInput
  }

  /**
   * TailorProduction upsert
   */
  export type TailorProductionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailorProduction
     */
    select?: TailorProductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorProductionInclude<ExtArgs> | null
    /**
     * The filter to search for the TailorProduction to update in case it exists.
     */
    where: TailorProductionWhereUniqueInput
    /**
     * In case the TailorProduction found by the `where` argument doesn't exist, create a new TailorProduction with this data.
     */
    create: XOR<TailorProductionCreateInput, TailorProductionUncheckedCreateInput>
    /**
     * In case the TailorProduction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TailorProductionUpdateInput, TailorProductionUncheckedUpdateInput>
  }

  /**
   * TailorProduction delete
   */
  export type TailorProductionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailorProduction
     */
    select?: TailorProductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorProductionInclude<ExtArgs> | null
    /**
     * Filter which TailorProduction to delete.
     */
    where: TailorProductionWhereUniqueInput
  }

  /**
   * TailorProduction deleteMany
   */
  export type TailorProductionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TailorProductions to delete
     */
    where?: TailorProductionWhereInput
  }

  /**
   * TailorProduction without action
   */
  export type TailorProductionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TailorProduction
     */
    select?: TailorProductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TailorProductionInclude<ExtArgs> | null
  }


  /**
   * Model ProductHPP
   */

  export type AggregateProductHPP = {
    _count: ProductHPPCountAggregateOutputType | null
    _avg: ProductHPPAvgAggregateOutputType | null
    _sum: ProductHPPSumAggregateOutputType | null
    _min: ProductHPPMinAggregateOutputType | null
    _max: ProductHPPMaxAggregateOutputType | null
  }

  export type ProductHPPAvgAggregateOutputType = {
    hpp: number | null
  }

  export type ProductHPPSumAggregateOutputType = {
    hpp: number | null
  }

  export type ProductHPPMinAggregateOutputType = {
    id: string | null
    nama_produk: string | null
    size: string | null
    hpp: number | null
    kategori: string | null
    deskripsi: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProductHPPMaxAggregateOutputType = {
    id: string | null
    nama_produk: string | null
    size: string | null
    hpp: number | null
    kategori: string | null
    deskripsi: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProductHPPCountAggregateOutputType = {
    id: number
    nama_produk: number
    size: number
    hpp: number
    kategori: number
    deskripsi: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ProductHPPAvgAggregateInputType = {
    hpp?: true
  }

  export type ProductHPPSumAggregateInputType = {
    hpp?: true
  }

  export type ProductHPPMinAggregateInputType = {
    id?: true
    nama_produk?: true
    size?: true
    hpp?: true
    kategori?: true
    deskripsi?: true
    created_at?: true
    updated_at?: true
  }

  export type ProductHPPMaxAggregateInputType = {
    id?: true
    nama_produk?: true
    size?: true
    hpp?: true
    kategori?: true
    deskripsi?: true
    created_at?: true
    updated_at?: true
  }

  export type ProductHPPCountAggregateInputType = {
    id?: true
    nama_produk?: true
    size?: true
    hpp?: true
    kategori?: true
    deskripsi?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ProductHPPAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductHPP to aggregate.
     */
    where?: ProductHPPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductHPPS to fetch.
     */
    orderBy?: ProductHPPOrderByWithRelationInput | ProductHPPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductHPPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductHPPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductHPPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductHPPS
    **/
    _count?: true | ProductHPPCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductHPPAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductHPPSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductHPPMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductHPPMaxAggregateInputType
  }

  export type GetProductHPPAggregateType<T extends ProductHPPAggregateArgs> = {
        [P in keyof T & keyof AggregateProductHPP]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductHPP[P]>
      : GetScalarType<T[P], AggregateProductHPP[P]>
  }




  export type ProductHPPGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductHPPWhereInput
    orderBy?: ProductHPPOrderByWithAggregationInput | ProductHPPOrderByWithAggregationInput[]
    by: ProductHPPScalarFieldEnum[] | ProductHPPScalarFieldEnum
    having?: ProductHPPScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductHPPCountAggregateInputType | true
    _avg?: ProductHPPAvgAggregateInputType
    _sum?: ProductHPPSumAggregateInputType
    _min?: ProductHPPMinAggregateInputType
    _max?: ProductHPPMaxAggregateInputType
  }

  export type ProductHPPGroupByOutputType = {
    id: string
    nama_produk: string
    size: string | null
    hpp: number
    kategori: string | null
    deskripsi: string | null
    created_at: Date
    updated_at: Date
    _count: ProductHPPCountAggregateOutputType | null
    _avg: ProductHPPAvgAggregateOutputType | null
    _sum: ProductHPPSumAggregateOutputType | null
    _min: ProductHPPMinAggregateOutputType | null
    _max: ProductHPPMaxAggregateOutputType | null
  }

  type GetProductHPPGroupByPayload<T extends ProductHPPGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductHPPGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductHPPGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductHPPGroupByOutputType[P]>
            : GetScalarType<T[P], ProductHPPGroupByOutputType[P]>
        }
      >
    >


  export type ProductHPPSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama_produk?: boolean
    size?: boolean
    hpp?: boolean
    kategori?: boolean
    deskripsi?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["productHPP"]>

  export type ProductHPPSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama_produk?: boolean
    size?: boolean
    hpp?: boolean
    kategori?: boolean
    deskripsi?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["productHPP"]>

  export type ProductHPPSelectScalar = {
    id?: boolean
    nama_produk?: boolean
    size?: boolean
    hpp?: boolean
    kategori?: boolean
    deskripsi?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $ProductHPPPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductHPP"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nama_produk: string
      size: string | null
      hpp: number
      kategori: string | null
      deskripsi: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["productHPP"]>
    composites: {}
  }

  type ProductHPPGetPayload<S extends boolean | null | undefined | ProductHPPDefaultArgs> = $Result.GetResult<Prisma.$ProductHPPPayload, S>

  type ProductHPPCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductHPPFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductHPPCountAggregateInputType | true
    }

  export interface ProductHPPDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductHPP'], meta: { name: 'ProductHPP' } }
    /**
     * Find zero or one ProductHPP that matches the filter.
     * @param {ProductHPPFindUniqueArgs} args - Arguments to find a ProductHPP
     * @example
     * // Get one ProductHPP
     * const productHPP = await prisma.productHPP.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductHPPFindUniqueArgs>(args: SelectSubset<T, ProductHPPFindUniqueArgs<ExtArgs>>): Prisma__ProductHPPClient<$Result.GetResult<Prisma.$ProductHPPPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductHPP that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductHPPFindUniqueOrThrowArgs} args - Arguments to find a ProductHPP
     * @example
     * // Get one ProductHPP
     * const productHPP = await prisma.productHPP.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductHPPFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductHPPFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductHPPClient<$Result.GetResult<Prisma.$ProductHPPPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductHPP that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductHPPFindFirstArgs} args - Arguments to find a ProductHPP
     * @example
     * // Get one ProductHPP
     * const productHPP = await prisma.productHPP.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductHPPFindFirstArgs>(args?: SelectSubset<T, ProductHPPFindFirstArgs<ExtArgs>>): Prisma__ProductHPPClient<$Result.GetResult<Prisma.$ProductHPPPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductHPP that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductHPPFindFirstOrThrowArgs} args - Arguments to find a ProductHPP
     * @example
     * // Get one ProductHPP
     * const productHPP = await prisma.productHPP.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductHPPFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductHPPFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductHPPClient<$Result.GetResult<Prisma.$ProductHPPPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductHPPS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductHPPFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductHPPS
     * const productHPPS = await prisma.productHPP.findMany()
     * 
     * // Get first 10 ProductHPPS
     * const productHPPS = await prisma.productHPP.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productHPPWithIdOnly = await prisma.productHPP.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductHPPFindManyArgs>(args?: SelectSubset<T, ProductHPPFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductHPPPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductHPP.
     * @param {ProductHPPCreateArgs} args - Arguments to create a ProductHPP.
     * @example
     * // Create one ProductHPP
     * const ProductHPP = await prisma.productHPP.create({
     *   data: {
     *     // ... data to create a ProductHPP
     *   }
     * })
     * 
     */
    create<T extends ProductHPPCreateArgs>(args: SelectSubset<T, ProductHPPCreateArgs<ExtArgs>>): Prisma__ProductHPPClient<$Result.GetResult<Prisma.$ProductHPPPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductHPPS.
     * @param {ProductHPPCreateManyArgs} args - Arguments to create many ProductHPPS.
     * @example
     * // Create many ProductHPPS
     * const productHPP = await prisma.productHPP.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductHPPCreateManyArgs>(args?: SelectSubset<T, ProductHPPCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductHPPS and returns the data saved in the database.
     * @param {ProductHPPCreateManyAndReturnArgs} args - Arguments to create many ProductHPPS.
     * @example
     * // Create many ProductHPPS
     * const productHPP = await prisma.productHPP.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductHPPS and only return the `id`
     * const productHPPWithIdOnly = await prisma.productHPP.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductHPPCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductHPPCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductHPPPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProductHPP.
     * @param {ProductHPPDeleteArgs} args - Arguments to delete one ProductHPP.
     * @example
     * // Delete one ProductHPP
     * const ProductHPP = await prisma.productHPP.delete({
     *   where: {
     *     // ... filter to delete one ProductHPP
     *   }
     * })
     * 
     */
    delete<T extends ProductHPPDeleteArgs>(args: SelectSubset<T, ProductHPPDeleteArgs<ExtArgs>>): Prisma__ProductHPPClient<$Result.GetResult<Prisma.$ProductHPPPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductHPP.
     * @param {ProductHPPUpdateArgs} args - Arguments to update one ProductHPP.
     * @example
     * // Update one ProductHPP
     * const productHPP = await prisma.productHPP.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductHPPUpdateArgs>(args: SelectSubset<T, ProductHPPUpdateArgs<ExtArgs>>): Prisma__ProductHPPClient<$Result.GetResult<Prisma.$ProductHPPPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductHPPS.
     * @param {ProductHPPDeleteManyArgs} args - Arguments to filter ProductHPPS to delete.
     * @example
     * // Delete a few ProductHPPS
     * const { count } = await prisma.productHPP.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductHPPDeleteManyArgs>(args?: SelectSubset<T, ProductHPPDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductHPPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductHPPUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductHPPS
     * const productHPP = await prisma.productHPP.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductHPPUpdateManyArgs>(args: SelectSubset<T, ProductHPPUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductHPP.
     * @param {ProductHPPUpsertArgs} args - Arguments to update or create a ProductHPP.
     * @example
     * // Update or create a ProductHPP
     * const productHPP = await prisma.productHPP.upsert({
     *   create: {
     *     // ... data to create a ProductHPP
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductHPP we want to update
     *   }
     * })
     */
    upsert<T extends ProductHPPUpsertArgs>(args: SelectSubset<T, ProductHPPUpsertArgs<ExtArgs>>): Prisma__ProductHPPClient<$Result.GetResult<Prisma.$ProductHPPPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductHPPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductHPPCountArgs} args - Arguments to filter ProductHPPS to count.
     * @example
     * // Count the number of ProductHPPS
     * const count = await prisma.productHPP.count({
     *   where: {
     *     // ... the filter for the ProductHPPS we want to count
     *   }
     * })
    **/
    count<T extends ProductHPPCountArgs>(
      args?: Subset<T, ProductHPPCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductHPPCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductHPP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductHPPAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductHPPAggregateArgs>(args: Subset<T, ProductHPPAggregateArgs>): Prisma.PrismaPromise<GetProductHPPAggregateType<T>>

    /**
     * Group by ProductHPP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductHPPGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductHPPGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductHPPGroupByArgs['orderBy'] }
        : { orderBy?: ProductHPPGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductHPPGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductHPPGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductHPP model
   */
  readonly fields: ProductHPPFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductHPP.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductHPPClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductHPP model
   */ 
  interface ProductHPPFieldRefs {
    readonly id: FieldRef<"ProductHPP", 'String'>
    readonly nama_produk: FieldRef<"ProductHPP", 'String'>
    readonly size: FieldRef<"ProductHPP", 'String'>
    readonly hpp: FieldRef<"ProductHPP", 'Float'>
    readonly kategori: FieldRef<"ProductHPP", 'String'>
    readonly deskripsi: FieldRef<"ProductHPP", 'String'>
    readonly created_at: FieldRef<"ProductHPP", 'DateTime'>
    readonly updated_at: FieldRef<"ProductHPP", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductHPP findUnique
   */
  export type ProductHPPFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductHPP
     */
    select?: ProductHPPSelect<ExtArgs> | null
    /**
     * Filter, which ProductHPP to fetch.
     */
    where: ProductHPPWhereUniqueInput
  }

  /**
   * ProductHPP findUniqueOrThrow
   */
  export type ProductHPPFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductHPP
     */
    select?: ProductHPPSelect<ExtArgs> | null
    /**
     * Filter, which ProductHPP to fetch.
     */
    where: ProductHPPWhereUniqueInput
  }

  /**
   * ProductHPP findFirst
   */
  export type ProductHPPFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductHPP
     */
    select?: ProductHPPSelect<ExtArgs> | null
    /**
     * Filter, which ProductHPP to fetch.
     */
    where?: ProductHPPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductHPPS to fetch.
     */
    orderBy?: ProductHPPOrderByWithRelationInput | ProductHPPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductHPPS.
     */
    cursor?: ProductHPPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductHPPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductHPPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductHPPS.
     */
    distinct?: ProductHPPScalarFieldEnum | ProductHPPScalarFieldEnum[]
  }

  /**
   * ProductHPP findFirstOrThrow
   */
  export type ProductHPPFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductHPP
     */
    select?: ProductHPPSelect<ExtArgs> | null
    /**
     * Filter, which ProductHPP to fetch.
     */
    where?: ProductHPPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductHPPS to fetch.
     */
    orderBy?: ProductHPPOrderByWithRelationInput | ProductHPPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductHPPS.
     */
    cursor?: ProductHPPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductHPPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductHPPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductHPPS.
     */
    distinct?: ProductHPPScalarFieldEnum | ProductHPPScalarFieldEnum[]
  }

  /**
   * ProductHPP findMany
   */
  export type ProductHPPFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductHPP
     */
    select?: ProductHPPSelect<ExtArgs> | null
    /**
     * Filter, which ProductHPPS to fetch.
     */
    where?: ProductHPPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductHPPS to fetch.
     */
    orderBy?: ProductHPPOrderByWithRelationInput | ProductHPPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductHPPS.
     */
    cursor?: ProductHPPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductHPPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductHPPS.
     */
    skip?: number
    distinct?: ProductHPPScalarFieldEnum | ProductHPPScalarFieldEnum[]
  }

  /**
   * ProductHPP create
   */
  export type ProductHPPCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductHPP
     */
    select?: ProductHPPSelect<ExtArgs> | null
    /**
     * The data needed to create a ProductHPP.
     */
    data: XOR<ProductHPPCreateInput, ProductHPPUncheckedCreateInput>
  }

  /**
   * ProductHPP createMany
   */
  export type ProductHPPCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductHPPS.
     */
    data: ProductHPPCreateManyInput | ProductHPPCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductHPP createManyAndReturn
   */
  export type ProductHPPCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductHPP
     */
    select?: ProductHPPSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProductHPPS.
     */
    data: ProductHPPCreateManyInput | ProductHPPCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductHPP update
   */
  export type ProductHPPUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductHPP
     */
    select?: ProductHPPSelect<ExtArgs> | null
    /**
     * The data needed to update a ProductHPP.
     */
    data: XOR<ProductHPPUpdateInput, ProductHPPUncheckedUpdateInput>
    /**
     * Choose, which ProductHPP to update.
     */
    where: ProductHPPWhereUniqueInput
  }

  /**
   * ProductHPP updateMany
   */
  export type ProductHPPUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductHPPS.
     */
    data: XOR<ProductHPPUpdateManyMutationInput, ProductHPPUncheckedUpdateManyInput>
    /**
     * Filter which ProductHPPS to update
     */
    where?: ProductHPPWhereInput
  }

  /**
   * ProductHPP upsert
   */
  export type ProductHPPUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductHPP
     */
    select?: ProductHPPSelect<ExtArgs> | null
    /**
     * The filter to search for the ProductHPP to update in case it exists.
     */
    where: ProductHPPWhereUniqueInput
    /**
     * In case the ProductHPP found by the `where` argument doesn't exist, create a new ProductHPP with this data.
     */
    create: XOR<ProductHPPCreateInput, ProductHPPUncheckedCreateInput>
    /**
     * In case the ProductHPP was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductHPPUpdateInput, ProductHPPUncheckedUpdateInput>
  }

  /**
   * ProductHPP delete
   */
  export type ProductHPPDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductHPP
     */
    select?: ProductHPPSelect<ExtArgs> | null
    /**
     * Filter which ProductHPP to delete.
     */
    where: ProductHPPWhereUniqueInput
  }

  /**
   * ProductHPP deleteMany
   */
  export type ProductHPPDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductHPPS to delete
     */
    where?: ProductHPPWhereInput
  }

  /**
   * ProductHPP without action
   */
  export type ProductHPPDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductHPP
     */
    select?: ProductHPPSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SalesDataScalarFieldEnum: {
    id: 'id',
    order_id: 'order_id',
    seller_sku: 'seller_sku',
    product_name: 'product_name',
    color: 'color',
    size: 'size',
    quantity: 'quantity',
    order_amount: 'order_amount',
    created_time: 'created_time',
    delivered_time: 'delivered_time',
    settlement_amount: 'settlement_amount',
    total_revenue: 'total_revenue',
    hpp: 'hpp',
    total: 'total',
    marketplace: 'marketplace',
    customer: 'customer',
    province: 'province',
    regency_city: 'regency_city',
    import_batch_id: 'import_batch_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SalesDataScalarFieldEnum = (typeof SalesDataScalarFieldEnum)[keyof typeof SalesDataScalarFieldEnum]


  export const ProductDataScalarFieldEnum: {
    id: 'id',
    product_code: 'product_code',
    product_name: 'product_name',
    category: 'category',
    brand: 'brand',
    size: 'size',
    color: 'color',
    price: 'price',
    cost: 'cost',
    stock_quantity: 'stock_quantity',
    min_stock: 'min_stock',
    description: 'description',
    import_batch_id: 'import_batch_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ProductDataScalarFieldEnum = (typeof ProductDataScalarFieldEnum)[keyof typeof ProductDataScalarFieldEnum]


  export const StockDataScalarFieldEnum: {
    id: 'id',
    product_code: 'product_code',
    movement_type: 'movement_type',
    quantity: 'quantity',
    reference_number: 'reference_number',
    notes: 'notes',
    movement_date: 'movement_date',
    import_batch_id: 'import_batch_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type StockDataScalarFieldEnum = (typeof StockDataScalarFieldEnum)[keyof typeof StockDataScalarFieldEnum]


  export const ImportBatchScalarFieldEnum: {
    id: 'id',
    batch_name: 'batch_name',
    import_type: 'import_type',
    file_name: 'file_name',
    file_type: 'file_type',
    total_records: 'total_records',
    valid_records: 'valid_records',
    invalid_records: 'invalid_records',
    imported_records: 'imported_records',
    status: 'status',
    error_details: 'error_details',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ImportBatchScalarFieldEnum = (typeof ImportBatchScalarFieldEnum)[keyof typeof ImportBatchScalarFieldEnum]


  export const AdvertisingDataScalarFieldEnum: {
    id: 'id',
    campaign_name: 'campaign_name',
    ad_creative_type: 'ad_creative_type',
    ad_creative: 'ad_creative',
    account_name: 'account_name',
    cost: 'cost',
    conversions: 'conversions',
    cpa: 'cpa',
    revenue: 'revenue',
    roi: 'roi',
    impressions: 'impressions',
    clicks: 'clicks',
    ctr: 'ctr',
    conversion_rate: 'conversion_rate',
    date_start: 'date_start',
    date_end: 'date_end',
    marketplace: 'marketplace',
    nama_produk: 'nama_produk',
    import_batch_id: 'import_batch_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AdvertisingDataScalarFieldEnum = (typeof AdvertisingDataScalarFieldEnum)[keyof typeof AdvertisingDataScalarFieldEnum]


  export const AdvertisingSettlementScalarFieldEnum: {
    order_id: 'order_id',
    type: 'type',
    order_created_time: 'order_created_time',
    order_settled_time: 'order_settled_time',
    settlement_amount: 'settlement_amount',
    settlement_period: 'settlement_period',
    account_name: 'account_name',
    marketplace: 'marketplace',
    currency: 'currency',
    import_batch_id: 'import_batch_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AdvertisingSettlementScalarFieldEnum = (typeof AdvertisingSettlementScalarFieldEnum)[keyof typeof AdvertisingSettlementScalarFieldEnum]


  export const ReturnsAndCancellationsScalarFieldEnum: {
    id: 'id',
    original_order_id: 'original_order_id',
    original_sales_id: 'original_sales_id',
    type: 'type',
    reason: 'reason',
    return_date: 'return_date',
    returned_amount: 'returned_amount',
    refund_amount: 'refund_amount',
    restocking_fee: 'restocking_fee',
    shipping_cost_loss: 'shipping_cost_loss',
    product_name: 'product_name',
    quantity_returned: 'quantity_returned',
    original_price: 'original_price',
    marketplace: 'marketplace',
    product_condition: 'product_condition',
    resellable: 'resellable',
    import_batch_id: 'import_batch_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ReturnsAndCancellationsScalarFieldEnum = (typeof ReturnsAndCancellationsScalarFieldEnum)[keyof typeof ReturnsAndCancellationsScalarFieldEnum]


  export const MarketplaceReimbursementScalarFieldEnum: {
    id: 'id',
    claim_id: 'claim_id',
    reimbursement_type: 'reimbursement_type',
    claim_amount: 'claim_amount',
    approved_amount: 'approved_amount',
    received_amount: 'received_amount',
    processing_fee: 'processing_fee',
    incident_date: 'incident_date',
    claim_date: 'claim_date',
    approval_date: 'approval_date',
    received_date: 'received_date',
    affected_order_id: 'affected_order_id',
    product_name: 'product_name',
    marketplace: 'marketplace',
    status: 'status',
    notes: 'notes',
    evidence_provided: 'evidence_provided',
    import_batch_id: 'import_batch_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type MarketplaceReimbursementScalarFieldEnum = (typeof MarketplaceReimbursementScalarFieldEnum)[keyof typeof MarketplaceReimbursementScalarFieldEnum]


  export const CommissionAdjustmentsScalarFieldEnum: {
    id: 'id',
    original_order_id: 'original_order_id',
    original_sales_id: 'original_sales_id',
    adjustment_type: 'adjustment_type',
    reason: 'reason',
    original_commission: 'original_commission',
    adjustment_amount: 'adjustment_amount',
    final_commission: 'final_commission',
    marketplace: 'marketplace',
    commission_rate: 'commission_rate',
    dynamic_rate_applied: 'dynamic_rate_applied',
    transaction_date: 'transaction_date',
    adjustment_date: 'adjustment_date',
    product_name: 'product_name',
    quantity: 'quantity',
    product_price: 'product_price',
    import_batch_id: 'import_batch_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CommissionAdjustmentsScalarFieldEnum = (typeof CommissionAdjustmentsScalarFieldEnum)[keyof typeof CommissionAdjustmentsScalarFieldEnum]


  export const AffiliateSamplesScalarFieldEnum: {
    id: 'id',
    affiliate_name: 'affiliate_name',
    affiliate_platform: 'affiliate_platform',
    affiliate_contact: 'affiliate_contact',
    product_name: 'product_name',
    product_sku: 'product_sku',
    quantity_given: 'quantity_given',
    product_cost: 'product_cost',
    total_cost: 'total_cost',
    shipping_cost: 'shipping_cost',
    packaging_cost: 'packaging_cost',
    campaign_name: 'campaign_name',
    expected_reach: 'expected_reach',
    content_type: 'content_type',
    given_date: 'given_date',
    expected_content_date: 'expected_content_date',
    actual_content_date: 'actual_content_date',
    content_delivered: 'content_delivered',
    performance_notes: 'performance_notes',
    roi_estimate: 'roi_estimate',
    status: 'status',
    import_batch_id: 'import_batch_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AffiliateSamplesScalarFieldEnum = (typeof AffiliateSamplesScalarFieldEnum)[keyof typeof AffiliateSamplesScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    color: 'color',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const BrandScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    website: 'website',
    logo_color: 'logo_color',
    is_premium: 'is_premium',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type BrandScalarFieldEnum = (typeof BrandScalarFieldEnum)[keyof typeof BrandScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    contact_person: 'contact_person',
    phone: 'phone',
    email: 'email',
    address: 'address',
    category: 'category',
    rating: 'rating',
    status: 'status',
    payment_terms: 'payment_terms',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const PurchaseOrderScalarFieldEnum: {
    id: 'id',
    po_number: 'po_number',
    supplier_id: 'supplier_id',
    po_date: 'po_date',
    expected_date: 'expected_date',
    delivery_date: 'delivery_date',
    status: 'status',
    total_amount: 'total_amount',
    items_count: 'items_count',
    notes: 'notes',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PurchaseOrderScalarFieldEnum = (typeof PurchaseOrderScalarFieldEnum)[keyof typeof PurchaseOrderScalarFieldEnum]


  export const PurchaseOrderItemScalarFieldEnum: {
    id: 'id',
    purchase_order_id: 'purchase_order_id',
    material_id: 'material_id',
    material_name: 'material_name',
    material_description: 'material_description',
    quantity: 'quantity',
    unit_price: 'unit_price',
    total_price: 'total_price',
    received_quantity: 'received_quantity',
    unit: 'unit',
    notes: 'notes',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PurchaseOrderItemScalarFieldEnum = (typeof PurchaseOrderItemScalarFieldEnum)[keyof typeof PurchaseOrderItemScalarFieldEnum]


  export const CashFlowEntryScalarFieldEnum: {
    id: 'id',
    entry_date: 'entry_date',
    description: 'description',
    category: 'category',
    entry_type: 'entry_type',
    amount: 'amount',
    source: 'source',
    marketplace: 'marketplace',
    reference: 'reference',
    notes: 'notes',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CashFlowEntryScalarFieldEnum = (typeof CashFlowEntryScalarFieldEnum)[keyof typeof CashFlowEntryScalarFieldEnum]


  export const DashboardMetricsScalarFieldEnum: {
    id: 'id',
    metric_date: 'metric_date',
    distinct_orders: 'distinct_orders',
    total_quantity_sold: 'total_quantity_sold',
    total_revenue: 'total_revenue',
    total_profit: 'total_profit',
    total_hpp: 'total_hpp',
    profit_margin: 'profit_margin',
    average_order_value: 'average_order_value',
    total_sales_records: 'total_sales_records',
    today_revenue: 'today_revenue',
    today_orders: 'today_orders',
    month_revenue: 'month_revenue',
    month_orders: 'month_orders',
    total_products: 'total_products',
    low_stock_products: 'low_stock_products',
    out_of_stock_products: 'out_of_stock_products',
    total_categories: 'total_categories',
    total_brands: 'total_brands',
    calculated_at: 'calculated_at'
  };

  export type DashboardMetricsScalarFieldEnum = (typeof DashboardMetricsScalarFieldEnum)[keyof typeof DashboardMetricsScalarFieldEnum]


  export const ImportHistoryScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    user_id: 'user_id',
    import_type: 'import_type',
    file_name: 'file_name',
    file_size: 'file_size',
    file_hash: 'file_hash',
    total_records: 'total_records',
    imported_records: 'imported_records',
    failed_records: 'failed_records',
    duplicate_records: 'duplicate_records',
    success_rate: 'success_rate',
    processing_time_ms: 'processing_time_ms',
    import_status: 'import_status',
    error_details: 'error_details',
    import_summary: 'import_summary',
    metadata: 'metadata',
    source_ip: 'source_ip',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ImportHistoryScalarFieldEnum = (typeof ImportHistoryScalarFieldEnum)[keyof typeof ImportHistoryScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    invoice_number: 'invoice_number',
    customer_name: 'customer_name',
    customer_email: 'customer_email',
    customer_phone: 'customer_phone',
    issue_date: 'issue_date',
    due_date: 'due_date',
    status: 'status',
    type: 'type',
    subtotal: 'subtotal',
    tax: 'tax',
    discount: 'discount',
    total: 'total',
    notes: 'notes',
    payment_method: 'payment_method',
    payment_date: 'payment_date',
    created_at: 'created_at',
    updated_at: 'updated_at',
    created_by: 'created_by'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceItemScalarFieldEnum: {
    id: 'id',
    invoice_id: 'invoice_id',
    product_name: 'product_name',
    quantity: 'quantity',
    unit_price: 'unit_price',
    total: 'total',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type InvoiceItemScalarFieldEnum = (typeof InvoiceItemScalarFieldEnum)[keyof typeof InvoiceItemScalarFieldEnum]


  export const AffiliateEndorsementScalarFieldEnum: {
    id: 'id',
    campaign_name: 'campaign_name',
    affiliate_name: 'affiliate_name',
    affiliate_type: 'affiliate_type',
    start_date: 'start_date',
    end_date: 'end_date',
    endorse_fee: 'endorse_fee',
    target_sales: 'target_sales',
    actual_sales: 'actual_sales',
    total_commission: 'total_commission',
    payment_method: 'payment_method',
    platform: 'platform',
    content_type: 'content_type',
    followers: 'followers',
    engagement: 'engagement',
    reference: 'reference',
    notes: 'notes',
    status: 'status',
    roi: 'roi',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AffiliateEndorsementScalarFieldEnum = (typeof AffiliateEndorsementScalarFieldEnum)[keyof typeof AffiliateEndorsementScalarFieldEnum]


  export const AffiliateProductSaleScalarFieldEnum: {
    id: 'id',
    endorsement_id: 'endorsement_id',
    product_name: 'product_name',
    quantity: 'quantity',
    unit_price: 'unit_price',
    total_sales: 'total_sales',
    commission: 'commission',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AffiliateProductSaleScalarFieldEnum = (typeof AffiliateProductSaleScalarFieldEnum)[keyof typeof AffiliateProductSaleScalarFieldEnum]


  export const ActivityLogsScalarFieldEnum: {
    id: 'id',
    type: 'type',
    title: 'title',
    description: 'description',
    status: 'status',
    metadata: 'metadata',
    user_id: 'user_id',
    related_id: 'related_id',
    related_type: 'related_type',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ActivityLogsScalarFieldEnum = (typeof ActivityLogsScalarFieldEnum)[keyof typeof ActivityLogsScalarFieldEnum]


  export const DuplicateCheckLogsScalarFieldEnum: {
    id: 'id',
    file_name: 'file_name',
    file_size: 'file_size',
    file_hash: 'file_hash',
    import_type: 'import_type',
    check_result: 'check_result',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type DuplicateCheckLogsScalarFieldEnum = (typeof DuplicateCheckLogsScalarFieldEnum)[keyof typeof DuplicateCheckLogsScalarFieldEnum]


  export const ImportMetadataScalarFieldEnum: {
    id: 'id',
    import_history_id: 'import_history_id',
    metadata_type: 'metadata_type',
    metadata: 'metadata',
    created_at: 'created_at'
  };

  export type ImportMetadataScalarFieldEnum = (typeof ImportMetadataScalarFieldEnum)[keyof typeof ImportMetadataScalarFieldEnum]


  export const TailorScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    contact_person: 'contact_person',
    phone: 'phone',
    email: 'email',
    address: 'address',
    specialization: 'specialization',
    rating: 'rating',
    status: 'status',
    payment_terms: 'payment_terms',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TailorScalarFieldEnum = (typeof TailorScalarFieldEnum)[keyof typeof TailorScalarFieldEnum]


  export const TailorProductionScalarFieldEnum: {
    id: 'id',
    tailor_id: 'tailor_id',
    product_name: 'product_name',
    color: 'color',
    size: 'size',
    finished_stock: 'finished_stock',
    meters_needed: 'meters_needed',
    cost_per_piece: 'cost_per_piece',
    defective_stock: 'defective_stock',
    additional_costs: 'additional_costs',
    additional_cost_description: 'additional_cost_description',
    delivery_date: 'delivery_date',
    notes: 'notes',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TailorProductionScalarFieldEnum = (typeof TailorProductionScalarFieldEnum)[keyof typeof TailorProductionScalarFieldEnum]


  export const ProductHPPScalarFieldEnum: {
    id: 'id',
    nama_produk: 'nama_produk',
    size: 'size',
    hpp: 'hpp',
    kategori: 'kategori',
    deskripsi: 'deskripsi',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ProductHPPScalarFieldEnum = (typeof ProductHPPScalarFieldEnum)[keyof typeof ProductHPPScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'StockMovementType'
   */
  export type EnumStockMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StockMovementType'>
    


  /**
   * Reference to a field of type 'StockMovementType[]'
   */
  export type ListEnumStockMovementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StockMovementType[]'>
    


  /**
   * Reference to a field of type 'ImportType'
   */
  export type EnumImportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportType'>
    


  /**
   * Reference to a field of type 'ImportType[]'
   */
  export type ListEnumImportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportType[]'>
    


  /**
   * Reference to a field of type 'ImportStatus'
   */
  export type EnumImportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportStatus'>
    


  /**
   * Reference to a field of type 'ImportStatus[]'
   */
  export type ListEnumImportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'SupplierStatus'
   */
  export type EnumSupplierStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SupplierStatus'>
    


  /**
   * Reference to a field of type 'SupplierStatus[]'
   */
  export type ListEnumSupplierStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SupplierStatus[]'>
    


  /**
   * Reference to a field of type 'POStatus'
   */
  export type EnumPOStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'POStatus'>
    


  /**
   * Reference to a field of type 'POStatus[]'
   */
  export type ListEnumPOStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'POStatus[]'>
    


  /**
   * Reference to a field of type 'CashFlowType'
   */
  export type EnumCashFlowTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CashFlowType'>
    


  /**
   * Reference to a field of type 'CashFlowType[]'
   */
  export type ListEnumCashFlowTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CashFlowType[]'>
    


  /**
   * Reference to a field of type 'ImportHistoryStatus'
   */
  export type EnumImportHistoryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportHistoryStatus'>
    


  /**
   * Reference to a field of type 'ImportHistoryStatus[]'
   */
  export type ListEnumImportHistoryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportHistoryStatus[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'InvoiceType'
   */
  export type EnumInvoiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceType'>
    


  /**
   * Reference to a field of type 'InvoiceType[]'
   */
  export type ListEnumInvoiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceType[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'TailorStatus'
   */
  export type EnumTailorStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TailorStatus'>
    


  /**
   * Reference to a field of type 'TailorStatus[]'
   */
  export type ListEnumTailorStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TailorStatus[]'>
    


  /**
   * Reference to a field of type 'TailorProductionStatus'
   */
  export type EnumTailorProductionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TailorProductionStatus'>
    


  /**
   * Reference to a field of type 'TailorProductionStatus[]'
   */
  export type ListEnumTailorProductionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TailorProductionStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type SalesDataWhereInput = {
    AND?: SalesDataWhereInput | SalesDataWhereInput[]
    OR?: SalesDataWhereInput[]
    NOT?: SalesDataWhereInput | SalesDataWhereInput[]
    id?: StringFilter<"SalesData"> | string
    order_id?: StringFilter<"SalesData"> | string
    seller_sku?: StringFilter<"SalesData"> | string
    product_name?: StringFilter<"SalesData"> | string
    color?: StringFilter<"SalesData"> | string
    size?: StringFilter<"SalesData"> | string
    quantity?: IntFilter<"SalesData"> | number
    order_amount?: FloatFilter<"SalesData"> | number
    created_time?: DateTimeFilter<"SalesData"> | Date | string
    delivered_time?: DateTimeNullableFilter<"SalesData"> | Date | string | null
    settlement_amount?: FloatNullableFilter<"SalesData"> | number | null
    total_revenue?: FloatNullableFilter<"SalesData"> | number | null
    hpp?: FloatNullableFilter<"SalesData"> | number | null
    total?: FloatNullableFilter<"SalesData"> | number | null
    marketplace?: StringNullableFilter<"SalesData"> | string | null
    customer?: StringNullableFilter<"SalesData"> | string | null
    province?: StringNullableFilter<"SalesData"> | string | null
    regency_city?: StringNullableFilter<"SalesData"> | string | null
    import_batch_id?: StringNullableFilter<"SalesData"> | string | null
    created_at?: DateTimeFilter<"SalesData"> | Date | string
    updated_at?: DateTimeFilter<"SalesData"> | Date | string
    import_batch?: XOR<ImportBatchNullableRelationFilter, ImportBatchWhereInput> | null
  }

  export type SalesDataOrderByWithRelationInput = {
    id?: SortOrder
    order_id?: SortOrder
    seller_sku?: SortOrder
    product_name?: SortOrder
    color?: SortOrder
    size?: SortOrder
    quantity?: SortOrder
    order_amount?: SortOrder
    created_time?: SortOrder
    delivered_time?: SortOrderInput | SortOrder
    settlement_amount?: SortOrderInput | SortOrder
    total_revenue?: SortOrderInput | SortOrder
    hpp?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    marketplace?: SortOrderInput | SortOrder
    customer?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    regency_city?: SortOrderInput | SortOrder
    import_batch_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    import_batch?: ImportBatchOrderByWithRelationInput
  }

  export type SalesDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    order_id_seller_sku_color_size?: SalesDataOrder_idSeller_skuColorSizeCompoundUniqueInput
    AND?: SalesDataWhereInput | SalesDataWhereInput[]
    OR?: SalesDataWhereInput[]
    NOT?: SalesDataWhereInput | SalesDataWhereInput[]
    order_id?: StringFilter<"SalesData"> | string
    seller_sku?: StringFilter<"SalesData"> | string
    product_name?: StringFilter<"SalesData"> | string
    color?: StringFilter<"SalesData"> | string
    size?: StringFilter<"SalesData"> | string
    quantity?: IntFilter<"SalesData"> | number
    order_amount?: FloatFilter<"SalesData"> | number
    created_time?: DateTimeFilter<"SalesData"> | Date | string
    delivered_time?: DateTimeNullableFilter<"SalesData"> | Date | string | null
    settlement_amount?: FloatNullableFilter<"SalesData"> | number | null
    total_revenue?: FloatNullableFilter<"SalesData"> | number | null
    hpp?: FloatNullableFilter<"SalesData"> | number | null
    total?: FloatNullableFilter<"SalesData"> | number | null
    marketplace?: StringNullableFilter<"SalesData"> | string | null
    customer?: StringNullableFilter<"SalesData"> | string | null
    province?: StringNullableFilter<"SalesData"> | string | null
    regency_city?: StringNullableFilter<"SalesData"> | string | null
    import_batch_id?: StringNullableFilter<"SalesData"> | string | null
    created_at?: DateTimeFilter<"SalesData"> | Date | string
    updated_at?: DateTimeFilter<"SalesData"> | Date | string
    import_batch?: XOR<ImportBatchNullableRelationFilter, ImportBatchWhereInput> | null
  }, "id" | "order_id_seller_sku_color_size">

  export type SalesDataOrderByWithAggregationInput = {
    id?: SortOrder
    order_id?: SortOrder
    seller_sku?: SortOrder
    product_name?: SortOrder
    color?: SortOrder
    size?: SortOrder
    quantity?: SortOrder
    order_amount?: SortOrder
    created_time?: SortOrder
    delivered_time?: SortOrderInput | SortOrder
    settlement_amount?: SortOrderInput | SortOrder
    total_revenue?: SortOrderInput | SortOrder
    hpp?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    marketplace?: SortOrderInput | SortOrder
    customer?: SortOrderInput | SortOrder
    province?: SortOrderInput | SortOrder
    regency_city?: SortOrderInput | SortOrder
    import_batch_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: SalesDataCountOrderByAggregateInput
    _avg?: SalesDataAvgOrderByAggregateInput
    _max?: SalesDataMaxOrderByAggregateInput
    _min?: SalesDataMinOrderByAggregateInput
    _sum?: SalesDataSumOrderByAggregateInput
  }

  export type SalesDataScalarWhereWithAggregatesInput = {
    AND?: SalesDataScalarWhereWithAggregatesInput | SalesDataScalarWhereWithAggregatesInput[]
    OR?: SalesDataScalarWhereWithAggregatesInput[]
    NOT?: SalesDataScalarWhereWithAggregatesInput | SalesDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SalesData"> | string
    order_id?: StringWithAggregatesFilter<"SalesData"> | string
    seller_sku?: StringWithAggregatesFilter<"SalesData"> | string
    product_name?: StringWithAggregatesFilter<"SalesData"> | string
    color?: StringWithAggregatesFilter<"SalesData"> | string
    size?: StringWithAggregatesFilter<"SalesData"> | string
    quantity?: IntWithAggregatesFilter<"SalesData"> | number
    order_amount?: FloatWithAggregatesFilter<"SalesData"> | number
    created_time?: DateTimeWithAggregatesFilter<"SalesData"> | Date | string
    delivered_time?: DateTimeNullableWithAggregatesFilter<"SalesData"> | Date | string | null
    settlement_amount?: FloatNullableWithAggregatesFilter<"SalesData"> | number | null
    total_revenue?: FloatNullableWithAggregatesFilter<"SalesData"> | number | null
    hpp?: FloatNullableWithAggregatesFilter<"SalesData"> | number | null
    total?: FloatNullableWithAggregatesFilter<"SalesData"> | number | null
    marketplace?: StringNullableWithAggregatesFilter<"SalesData"> | string | null
    customer?: StringNullableWithAggregatesFilter<"SalesData"> | string | null
    province?: StringNullableWithAggregatesFilter<"SalesData"> | string | null
    regency_city?: StringNullableWithAggregatesFilter<"SalesData"> | string | null
    import_batch_id?: StringNullableWithAggregatesFilter<"SalesData"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"SalesData"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"SalesData"> | Date | string
  }

  export type ProductDataWhereInput = {
    AND?: ProductDataWhereInput | ProductDataWhereInput[]
    OR?: ProductDataWhereInput[]
    NOT?: ProductDataWhereInput | ProductDataWhereInput[]
    id?: StringFilter<"ProductData"> | string
    product_code?: StringFilter<"ProductData"> | string
    product_name?: StringFilter<"ProductData"> | string
    category?: StringFilter<"ProductData"> | string
    brand?: StringFilter<"ProductData"> | string
    size?: StringFilter<"ProductData"> | string
    color?: StringFilter<"ProductData"> | string
    price?: FloatFilter<"ProductData"> | number
    cost?: FloatFilter<"ProductData"> | number
    stock_quantity?: IntFilter<"ProductData"> | number
    min_stock?: IntFilter<"ProductData"> | number
    description?: StringNullableFilter<"ProductData"> | string | null
    import_batch_id?: StringNullableFilter<"ProductData"> | string | null
    created_at?: DateTimeFilter<"ProductData"> | Date | string
    updated_at?: DateTimeFilter<"ProductData"> | Date | string
    stock_movements?: StockDataListRelationFilter
    import_batch?: XOR<ImportBatchNullableRelationFilter, ImportBatchWhereInput> | null
  }

  export type ProductDataOrderByWithRelationInput = {
    id?: SortOrder
    product_code?: SortOrder
    product_name?: SortOrder
    category?: SortOrder
    brand?: SortOrder
    size?: SortOrder
    color?: SortOrder
    price?: SortOrder
    cost?: SortOrder
    stock_quantity?: SortOrder
    min_stock?: SortOrder
    description?: SortOrderInput | SortOrder
    import_batch_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    stock_movements?: StockDataOrderByRelationAggregateInput
    import_batch?: ImportBatchOrderByWithRelationInput
  }

  export type ProductDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    product_code?: string
    AND?: ProductDataWhereInput | ProductDataWhereInput[]
    OR?: ProductDataWhereInput[]
    NOT?: ProductDataWhereInput | ProductDataWhereInput[]
    product_name?: StringFilter<"ProductData"> | string
    category?: StringFilter<"ProductData"> | string
    brand?: StringFilter<"ProductData"> | string
    size?: StringFilter<"ProductData"> | string
    color?: StringFilter<"ProductData"> | string
    price?: FloatFilter<"ProductData"> | number
    cost?: FloatFilter<"ProductData"> | number
    stock_quantity?: IntFilter<"ProductData"> | number
    min_stock?: IntFilter<"ProductData"> | number
    description?: StringNullableFilter<"ProductData"> | string | null
    import_batch_id?: StringNullableFilter<"ProductData"> | string | null
    created_at?: DateTimeFilter<"ProductData"> | Date | string
    updated_at?: DateTimeFilter<"ProductData"> | Date | string
    stock_movements?: StockDataListRelationFilter
    import_batch?: XOR<ImportBatchNullableRelationFilter, ImportBatchWhereInput> | null
  }, "id" | "product_code">

  export type ProductDataOrderByWithAggregationInput = {
    id?: SortOrder
    product_code?: SortOrder
    product_name?: SortOrder
    category?: SortOrder
    brand?: SortOrder
    size?: SortOrder
    color?: SortOrder
    price?: SortOrder
    cost?: SortOrder
    stock_quantity?: SortOrder
    min_stock?: SortOrder
    description?: SortOrderInput | SortOrder
    import_batch_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ProductDataCountOrderByAggregateInput
    _avg?: ProductDataAvgOrderByAggregateInput
    _max?: ProductDataMaxOrderByAggregateInput
    _min?: ProductDataMinOrderByAggregateInput
    _sum?: ProductDataSumOrderByAggregateInput
  }

  export type ProductDataScalarWhereWithAggregatesInput = {
    AND?: ProductDataScalarWhereWithAggregatesInput | ProductDataScalarWhereWithAggregatesInput[]
    OR?: ProductDataScalarWhereWithAggregatesInput[]
    NOT?: ProductDataScalarWhereWithAggregatesInput | ProductDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductData"> | string
    product_code?: StringWithAggregatesFilter<"ProductData"> | string
    product_name?: StringWithAggregatesFilter<"ProductData"> | string
    category?: StringWithAggregatesFilter<"ProductData"> | string
    brand?: StringWithAggregatesFilter<"ProductData"> | string
    size?: StringWithAggregatesFilter<"ProductData"> | string
    color?: StringWithAggregatesFilter<"ProductData"> | string
    price?: FloatWithAggregatesFilter<"ProductData"> | number
    cost?: FloatWithAggregatesFilter<"ProductData"> | number
    stock_quantity?: IntWithAggregatesFilter<"ProductData"> | number
    min_stock?: IntWithAggregatesFilter<"ProductData"> | number
    description?: StringNullableWithAggregatesFilter<"ProductData"> | string | null
    import_batch_id?: StringNullableWithAggregatesFilter<"ProductData"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"ProductData"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ProductData"> | Date | string
  }

  export type StockDataWhereInput = {
    AND?: StockDataWhereInput | StockDataWhereInput[]
    OR?: StockDataWhereInput[]
    NOT?: StockDataWhereInput | StockDataWhereInput[]
    id?: StringFilter<"StockData"> | string
    product_code?: StringFilter<"StockData"> | string
    movement_type?: EnumStockMovementTypeFilter<"StockData"> | $Enums.StockMovementType
    quantity?: IntFilter<"StockData"> | number
    reference_number?: StringNullableFilter<"StockData"> | string | null
    notes?: StringNullableFilter<"StockData"> | string | null
    movement_date?: DateTimeFilter<"StockData"> | Date | string
    import_batch_id?: StringNullableFilter<"StockData"> | string | null
    created_at?: DateTimeFilter<"StockData"> | Date | string
    updated_at?: DateTimeFilter<"StockData"> | Date | string
    product?: XOR<ProductDataNullableRelationFilter, ProductDataWhereInput> | null
    import_batch?: XOR<ImportBatchNullableRelationFilter, ImportBatchWhereInput> | null
  }

  export type StockDataOrderByWithRelationInput = {
    id?: SortOrder
    product_code?: SortOrder
    movement_type?: SortOrder
    quantity?: SortOrder
    reference_number?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    movement_date?: SortOrder
    import_batch_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    product?: ProductDataOrderByWithRelationInput
    import_batch?: ImportBatchOrderByWithRelationInput
  }

  export type StockDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StockDataWhereInput | StockDataWhereInput[]
    OR?: StockDataWhereInput[]
    NOT?: StockDataWhereInput | StockDataWhereInput[]
    product_code?: StringFilter<"StockData"> | string
    movement_type?: EnumStockMovementTypeFilter<"StockData"> | $Enums.StockMovementType
    quantity?: IntFilter<"StockData"> | number
    reference_number?: StringNullableFilter<"StockData"> | string | null
    notes?: StringNullableFilter<"StockData"> | string | null
    movement_date?: DateTimeFilter<"StockData"> | Date | string
    import_batch_id?: StringNullableFilter<"StockData"> | string | null
    created_at?: DateTimeFilter<"StockData"> | Date | string
    updated_at?: DateTimeFilter<"StockData"> | Date | string
    product?: XOR<ProductDataNullableRelationFilter, ProductDataWhereInput> | null
    import_batch?: XOR<ImportBatchNullableRelationFilter, ImportBatchWhereInput> | null
  }, "id">

  export type StockDataOrderByWithAggregationInput = {
    id?: SortOrder
    product_code?: SortOrder
    movement_type?: SortOrder
    quantity?: SortOrder
    reference_number?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    movement_date?: SortOrder
    import_batch_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: StockDataCountOrderByAggregateInput
    _avg?: StockDataAvgOrderByAggregateInput
    _max?: StockDataMaxOrderByAggregateInput
    _min?: StockDataMinOrderByAggregateInput
    _sum?: StockDataSumOrderByAggregateInput
  }

  export type StockDataScalarWhereWithAggregatesInput = {
    AND?: StockDataScalarWhereWithAggregatesInput | StockDataScalarWhereWithAggregatesInput[]
    OR?: StockDataScalarWhereWithAggregatesInput[]
    NOT?: StockDataScalarWhereWithAggregatesInput | StockDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StockData"> | string
    product_code?: StringWithAggregatesFilter<"StockData"> | string
    movement_type?: EnumStockMovementTypeWithAggregatesFilter<"StockData"> | $Enums.StockMovementType
    quantity?: IntWithAggregatesFilter<"StockData"> | number
    reference_number?: StringNullableWithAggregatesFilter<"StockData"> | string | null
    notes?: StringNullableWithAggregatesFilter<"StockData"> | string | null
    movement_date?: DateTimeWithAggregatesFilter<"StockData"> | Date | string
    import_batch_id?: StringNullableWithAggregatesFilter<"StockData"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"StockData"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"StockData"> | Date | string
  }

  export type ImportBatchWhereInput = {
    AND?: ImportBatchWhereInput | ImportBatchWhereInput[]
    OR?: ImportBatchWhereInput[]
    NOT?: ImportBatchWhereInput | ImportBatchWhereInput[]
    id?: StringFilter<"ImportBatch"> | string
    batch_name?: StringFilter<"ImportBatch"> | string
    import_type?: EnumImportTypeFilter<"ImportBatch"> | $Enums.ImportType
    file_name?: StringFilter<"ImportBatch"> | string
    file_type?: StringFilter<"ImportBatch"> | string
    total_records?: IntFilter<"ImportBatch"> | number
    valid_records?: IntFilter<"ImportBatch"> | number
    invalid_records?: IntFilter<"ImportBatch"> | number
    imported_records?: IntFilter<"ImportBatch"> | number
    status?: EnumImportStatusFilter<"ImportBatch"> | $Enums.ImportStatus
    error_details?: JsonNullableFilter<"ImportBatch">
    created_at?: DateTimeFilter<"ImportBatch"> | Date | string
    updated_at?: DateTimeFilter<"ImportBatch"> | Date | string
    sales_data?: SalesDataListRelationFilter
    product_data?: ProductDataListRelationFilter
    stock_data?: StockDataListRelationFilter
    advertising_data?: AdvertisingDataListRelationFilter
    advertising_settlement?: AdvertisingSettlementListRelationFilter
    returns_and_cancellations?: ReturnsAndCancellationsListRelationFilter
    marketplace_reimbursements?: MarketplaceReimbursementListRelationFilter
    commission_adjustments?: CommissionAdjustmentsListRelationFilter
    affiliate_samples?: AffiliateSamplesListRelationFilter
  }

  export type ImportBatchOrderByWithRelationInput = {
    id?: SortOrder
    batch_name?: SortOrder
    import_type?: SortOrder
    file_name?: SortOrder
    file_type?: SortOrder
    total_records?: SortOrder
    valid_records?: SortOrder
    invalid_records?: SortOrder
    imported_records?: SortOrder
    status?: SortOrder
    error_details?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    sales_data?: SalesDataOrderByRelationAggregateInput
    product_data?: ProductDataOrderByRelationAggregateInput
    stock_data?: StockDataOrderByRelationAggregateInput
    advertising_data?: AdvertisingDataOrderByRelationAggregateInput
    advertising_settlement?: AdvertisingSettlementOrderByRelationAggregateInput
    returns_and_cancellations?: ReturnsAndCancellationsOrderByRelationAggregateInput
    marketplace_reimbursements?: MarketplaceReimbursementOrderByRelationAggregateInput
    commission_adjustments?: CommissionAdjustmentsOrderByRelationAggregateInput
    affiliate_samples?: AffiliateSamplesOrderByRelationAggregateInput
  }

  export type ImportBatchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ImportBatchWhereInput | ImportBatchWhereInput[]
    OR?: ImportBatchWhereInput[]
    NOT?: ImportBatchWhereInput | ImportBatchWhereInput[]
    batch_name?: StringFilter<"ImportBatch"> | string
    import_type?: EnumImportTypeFilter<"ImportBatch"> | $Enums.ImportType
    file_name?: StringFilter<"ImportBatch"> | string
    file_type?: StringFilter<"ImportBatch"> | string
    total_records?: IntFilter<"ImportBatch"> | number
    valid_records?: IntFilter<"ImportBatch"> | number
    invalid_records?: IntFilter<"ImportBatch"> | number
    imported_records?: IntFilter<"ImportBatch"> | number
    status?: EnumImportStatusFilter<"ImportBatch"> | $Enums.ImportStatus
    error_details?: JsonNullableFilter<"ImportBatch">
    created_at?: DateTimeFilter<"ImportBatch"> | Date | string
    updated_at?: DateTimeFilter<"ImportBatch"> | Date | string
    sales_data?: SalesDataListRelationFilter
    product_data?: ProductDataListRelationFilter
    stock_data?: StockDataListRelationFilter
    advertising_data?: AdvertisingDataListRelationFilter
    advertising_settlement?: AdvertisingSettlementListRelationFilter
    returns_and_cancellations?: ReturnsAndCancellationsListRelationFilter
    marketplace_reimbursements?: MarketplaceReimbursementListRelationFilter
    commission_adjustments?: CommissionAdjustmentsListRelationFilter
    affiliate_samples?: AffiliateSamplesListRelationFilter
  }, "id">

  export type ImportBatchOrderByWithAggregationInput = {
    id?: SortOrder
    batch_name?: SortOrder
    import_type?: SortOrder
    file_name?: SortOrder
    file_type?: SortOrder
    total_records?: SortOrder
    valid_records?: SortOrder
    invalid_records?: SortOrder
    imported_records?: SortOrder
    status?: SortOrder
    error_details?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ImportBatchCountOrderByAggregateInput
    _avg?: ImportBatchAvgOrderByAggregateInput
    _max?: ImportBatchMaxOrderByAggregateInput
    _min?: ImportBatchMinOrderByAggregateInput
    _sum?: ImportBatchSumOrderByAggregateInput
  }

  export type ImportBatchScalarWhereWithAggregatesInput = {
    AND?: ImportBatchScalarWhereWithAggregatesInput | ImportBatchScalarWhereWithAggregatesInput[]
    OR?: ImportBatchScalarWhereWithAggregatesInput[]
    NOT?: ImportBatchScalarWhereWithAggregatesInput | ImportBatchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ImportBatch"> | string
    batch_name?: StringWithAggregatesFilter<"ImportBatch"> | string
    import_type?: EnumImportTypeWithAggregatesFilter<"ImportBatch"> | $Enums.ImportType
    file_name?: StringWithAggregatesFilter<"ImportBatch"> | string
    file_type?: StringWithAggregatesFilter<"ImportBatch"> | string
    total_records?: IntWithAggregatesFilter<"ImportBatch"> | number
    valid_records?: IntWithAggregatesFilter<"ImportBatch"> | number
    invalid_records?: IntWithAggregatesFilter<"ImportBatch"> | number
    imported_records?: IntWithAggregatesFilter<"ImportBatch"> | number
    status?: EnumImportStatusWithAggregatesFilter<"ImportBatch"> | $Enums.ImportStatus
    error_details?: JsonNullableWithAggregatesFilter<"ImportBatch">
    created_at?: DateTimeWithAggregatesFilter<"ImportBatch"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ImportBatch"> | Date | string
  }

  export type AdvertisingDataWhereInput = {
    AND?: AdvertisingDataWhereInput | AdvertisingDataWhereInput[]
    OR?: AdvertisingDataWhereInput[]
    NOT?: AdvertisingDataWhereInput | AdvertisingDataWhereInput[]
    id?: StringFilter<"AdvertisingData"> | string
    campaign_name?: StringFilter<"AdvertisingData"> | string
    ad_creative_type?: StringNullableFilter<"AdvertisingData"> | string | null
    ad_creative?: StringNullableFilter<"AdvertisingData"> | string | null
    account_name?: StringNullableFilter<"AdvertisingData"> | string | null
    cost?: FloatFilter<"AdvertisingData"> | number
    conversions?: IntFilter<"AdvertisingData"> | number
    cpa?: FloatNullableFilter<"AdvertisingData"> | number | null
    revenue?: FloatFilter<"AdvertisingData"> | number
    roi?: FloatNullableFilter<"AdvertisingData"> | number | null
    impressions?: IntFilter<"AdvertisingData"> | number
    clicks?: IntFilter<"AdvertisingData"> | number
    ctr?: FloatNullableFilter<"AdvertisingData"> | number | null
    conversion_rate?: FloatNullableFilter<"AdvertisingData"> | number | null
    date_start?: DateTimeFilter<"AdvertisingData"> | Date | string
    date_end?: DateTimeFilter<"AdvertisingData"> | Date | string
    marketplace?: StringNullableFilter<"AdvertisingData"> | string | null
    nama_produk?: StringNullableFilter<"AdvertisingData"> | string | null
    import_batch_id?: StringNullableFilter<"AdvertisingData"> | string | null
    created_at?: DateTimeFilter<"AdvertisingData"> | Date | string
    updated_at?: DateTimeFilter<"AdvertisingData"> | Date | string
    import_batch?: XOR<ImportBatchNullableRelationFilter, ImportBatchWhereInput> | null
  }

  export type AdvertisingDataOrderByWithRelationInput = {
    id?: SortOrder
    campaign_name?: SortOrder
    ad_creative_type?: SortOrderInput | SortOrder
    ad_creative?: SortOrderInput | SortOrder
    account_name?: SortOrderInput | SortOrder
    cost?: SortOrder
    conversions?: SortOrder
    cpa?: SortOrderInput | SortOrder
    revenue?: SortOrder
    roi?: SortOrderInput | SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    ctr?: SortOrderInput | SortOrder
    conversion_rate?: SortOrderInput | SortOrder
    date_start?: SortOrder
    date_end?: SortOrder
    marketplace?: SortOrderInput | SortOrder
    nama_produk?: SortOrderInput | SortOrder
    import_batch_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    import_batch?: ImportBatchOrderByWithRelationInput
  }

  export type AdvertisingDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdvertisingDataWhereInput | AdvertisingDataWhereInput[]
    OR?: AdvertisingDataWhereInput[]
    NOT?: AdvertisingDataWhereInput | AdvertisingDataWhereInput[]
    campaign_name?: StringFilter<"AdvertisingData"> | string
    ad_creative_type?: StringNullableFilter<"AdvertisingData"> | string | null
    ad_creative?: StringNullableFilter<"AdvertisingData"> | string | null
    account_name?: StringNullableFilter<"AdvertisingData"> | string | null
    cost?: FloatFilter<"AdvertisingData"> | number
    conversions?: IntFilter<"AdvertisingData"> | number
    cpa?: FloatNullableFilter<"AdvertisingData"> | number | null
    revenue?: FloatFilter<"AdvertisingData"> | number
    roi?: FloatNullableFilter<"AdvertisingData"> | number | null
    impressions?: IntFilter<"AdvertisingData"> | number
    clicks?: IntFilter<"AdvertisingData"> | number
    ctr?: FloatNullableFilter<"AdvertisingData"> | number | null
    conversion_rate?: FloatNullableFilter<"AdvertisingData"> | number | null
    date_start?: DateTimeFilter<"AdvertisingData"> | Date | string
    date_end?: DateTimeFilter<"AdvertisingData"> | Date | string
    marketplace?: StringNullableFilter<"AdvertisingData"> | string | null
    nama_produk?: StringNullableFilter<"AdvertisingData"> | string | null
    import_batch_id?: StringNullableFilter<"AdvertisingData"> | string | null
    created_at?: DateTimeFilter<"AdvertisingData"> | Date | string
    updated_at?: DateTimeFilter<"AdvertisingData"> | Date | string
    import_batch?: XOR<ImportBatchNullableRelationFilter, ImportBatchWhereInput> | null
  }, "id">

  export type AdvertisingDataOrderByWithAggregationInput = {
    id?: SortOrder
    campaign_name?: SortOrder
    ad_creative_type?: SortOrderInput | SortOrder
    ad_creative?: SortOrderInput | SortOrder
    account_name?: SortOrderInput | SortOrder
    cost?: SortOrder
    conversions?: SortOrder
    cpa?: SortOrderInput | SortOrder
    revenue?: SortOrder
    roi?: SortOrderInput | SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    ctr?: SortOrderInput | SortOrder
    conversion_rate?: SortOrderInput | SortOrder
    date_start?: SortOrder
    date_end?: SortOrder
    marketplace?: SortOrderInput | SortOrder
    nama_produk?: SortOrderInput | SortOrder
    import_batch_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: AdvertisingDataCountOrderByAggregateInput
    _avg?: AdvertisingDataAvgOrderByAggregateInput
    _max?: AdvertisingDataMaxOrderByAggregateInput
    _min?: AdvertisingDataMinOrderByAggregateInput
    _sum?: AdvertisingDataSumOrderByAggregateInput
  }

  export type AdvertisingDataScalarWhereWithAggregatesInput = {
    AND?: AdvertisingDataScalarWhereWithAggregatesInput | AdvertisingDataScalarWhereWithAggregatesInput[]
    OR?: AdvertisingDataScalarWhereWithAggregatesInput[]
    NOT?: AdvertisingDataScalarWhereWithAggregatesInput | AdvertisingDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdvertisingData"> | string
    campaign_name?: StringWithAggregatesFilter<"AdvertisingData"> | string
    ad_creative_type?: StringNullableWithAggregatesFilter<"AdvertisingData"> | string | null
    ad_creative?: StringNullableWithAggregatesFilter<"AdvertisingData"> | string | null
    account_name?: StringNullableWithAggregatesFilter<"AdvertisingData"> | string | null
    cost?: FloatWithAggregatesFilter<"AdvertisingData"> | number
    conversions?: IntWithAggregatesFilter<"AdvertisingData"> | number
    cpa?: FloatNullableWithAggregatesFilter<"AdvertisingData"> | number | null
    revenue?: FloatWithAggregatesFilter<"AdvertisingData"> | number
    roi?: FloatNullableWithAggregatesFilter<"AdvertisingData"> | number | null
    impressions?: IntWithAggregatesFilter<"AdvertisingData"> | number
    clicks?: IntWithAggregatesFilter<"AdvertisingData"> | number
    ctr?: FloatNullableWithAggregatesFilter<"AdvertisingData"> | number | null
    conversion_rate?: FloatNullableWithAggregatesFilter<"AdvertisingData"> | number | null
    date_start?: DateTimeWithAggregatesFilter<"AdvertisingData"> | Date | string
    date_end?: DateTimeWithAggregatesFilter<"AdvertisingData"> | Date | string
    marketplace?: StringNullableWithAggregatesFilter<"AdvertisingData"> | string | null
    nama_produk?: StringNullableWithAggregatesFilter<"AdvertisingData"> | string | null
    import_batch_id?: StringNullableWithAggregatesFilter<"AdvertisingData"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"AdvertisingData"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"AdvertisingData"> | Date | string
  }

  export type AdvertisingSettlementWhereInput = {
    AND?: AdvertisingSettlementWhereInput | AdvertisingSettlementWhereInput[]
    OR?: AdvertisingSettlementWhereInput[]
    NOT?: AdvertisingSettlementWhereInput | AdvertisingSettlementWhereInput[]
    order_id?: StringFilter<"AdvertisingSettlement"> | string
    type?: StringNullableFilter<"AdvertisingSettlement"> | string | null
    order_created_time?: DateTimeFilter<"AdvertisingSettlement"> | Date | string
    order_settled_time?: DateTimeFilter<"AdvertisingSettlement"> | Date | string
    settlement_amount?: FloatFilter<"AdvertisingSettlement"> | number
    settlement_period?: StringNullableFilter<"AdvertisingSettlement"> | string | null
    account_name?: StringNullableFilter<"AdvertisingSettlement"> | string | null
    marketplace?: StringNullableFilter<"AdvertisingSettlement"> | string | null
    currency?: StringNullableFilter<"AdvertisingSettlement"> | string | null
    import_batch_id?: StringNullableFilter<"AdvertisingSettlement"> | string | null
    created_at?: DateTimeFilter<"AdvertisingSettlement"> | Date | string
    updated_at?: DateTimeFilter<"AdvertisingSettlement"> | Date | string
    import_batch?: XOR<ImportBatchNullableRelationFilter, ImportBatchWhereInput> | null
  }

  export type AdvertisingSettlementOrderByWithRelationInput = {
    order_id?: SortOrder
    type?: SortOrderInput | SortOrder
    order_created_time?: SortOrder
    order_settled_time?: SortOrder
    settlement_amount?: SortOrder
    settlement_period?: SortOrderInput | SortOrder
    account_name?: SortOrderInput | SortOrder
    marketplace?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    import_batch_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    import_batch?: ImportBatchOrderByWithRelationInput
  }

  export type AdvertisingSettlementWhereUniqueInput = Prisma.AtLeast<{
    order_id?: string
    AND?: AdvertisingSettlementWhereInput | AdvertisingSettlementWhereInput[]
    OR?: AdvertisingSettlementWhereInput[]
    NOT?: AdvertisingSettlementWhereInput | AdvertisingSettlementWhereInput[]
    type?: StringNullableFilter<"AdvertisingSettlement"> | string | null
    order_created_time?: DateTimeFilter<"AdvertisingSettlement"> | Date | string
    order_settled_time?: DateTimeFilter<"AdvertisingSettlement"> | Date | string
    settlement_amount?: FloatFilter<"AdvertisingSettlement"> | number
    settlement_period?: StringNullableFilter<"AdvertisingSettlement"> | string | null
    account_name?: StringNullableFilter<"AdvertisingSettlement"> | string | null
    marketplace?: StringNullableFilter<"AdvertisingSettlement"> | string | null
    currency?: StringNullableFilter<"AdvertisingSettlement"> | string | null
    import_batch_id?: StringNullableFilter<"AdvertisingSettlement"> | string | null
    created_at?: DateTimeFilter<"AdvertisingSettlement"> | Date | string
    updated_at?: DateTimeFilter<"AdvertisingSettlement"> | Date | string
    import_batch?: XOR<ImportBatchNullableRelationFilter, ImportBatchWhereInput> | null
  }, "order_id">

  export type AdvertisingSettlementOrderByWithAggregationInput = {
    order_id?: SortOrder
    type?: SortOrderInput | SortOrder
    order_created_time?: SortOrder
    order_settled_time?: SortOrder
    settlement_amount?: SortOrder
    settlement_period?: SortOrderInput | SortOrder
    account_name?: SortOrderInput | SortOrder
    marketplace?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    import_batch_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: AdvertisingSettlementCountOrderByAggregateInput
    _avg?: AdvertisingSettlementAvgOrderByAggregateInput
    _max?: AdvertisingSettlementMaxOrderByAggregateInput
    _min?: AdvertisingSettlementMinOrderByAggregateInput
    _sum?: AdvertisingSettlementSumOrderByAggregateInput
  }

  export type AdvertisingSettlementScalarWhereWithAggregatesInput = {
    AND?: AdvertisingSettlementScalarWhereWithAggregatesInput | AdvertisingSettlementScalarWhereWithAggregatesInput[]
    OR?: AdvertisingSettlementScalarWhereWithAggregatesInput[]
    NOT?: AdvertisingSettlementScalarWhereWithAggregatesInput | AdvertisingSettlementScalarWhereWithAggregatesInput[]
    order_id?: StringWithAggregatesFilter<"AdvertisingSettlement"> | string
    type?: StringNullableWithAggregatesFilter<"AdvertisingSettlement"> | string | null
    order_created_time?: DateTimeWithAggregatesFilter<"AdvertisingSettlement"> | Date | string
    order_settled_time?: DateTimeWithAggregatesFilter<"AdvertisingSettlement"> | Date | string
    settlement_amount?: FloatWithAggregatesFilter<"AdvertisingSettlement"> | number
    settlement_period?: StringNullableWithAggregatesFilter<"AdvertisingSettlement"> | string | null
    account_name?: StringNullableWithAggregatesFilter<"AdvertisingSettlement"> | string | null
    marketplace?: StringNullableWithAggregatesFilter<"AdvertisingSettlement"> | string | null
    currency?: StringNullableWithAggregatesFilter<"AdvertisingSettlement"> | string | null
    import_batch_id?: StringNullableWithAggregatesFilter<"AdvertisingSettlement"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"AdvertisingSettlement"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"AdvertisingSettlement"> | Date | string
  }

  export type ReturnsAndCancellationsWhereInput = {
    AND?: ReturnsAndCancellationsWhereInput | ReturnsAndCancellationsWhereInput[]
    OR?: ReturnsAndCancellationsWhereInput[]
    NOT?: ReturnsAndCancellationsWhereInput | ReturnsAndCancellationsWhereInput[]
    id?: StringFilter<"ReturnsAndCancellations"> | string
    original_order_id?: StringNullableFilter<"ReturnsAndCancellations"> | string | null
    original_sales_id?: StringNullableFilter<"ReturnsAndCancellations"> | string | null
    type?: StringFilter<"ReturnsAndCancellations"> | string
    reason?: StringNullableFilter<"ReturnsAndCancellations"> | string | null
    return_date?: DateTimeFilter<"ReturnsAndCancellations"> | Date | string
    returned_amount?: FloatFilter<"ReturnsAndCancellations"> | number
    refund_amount?: FloatFilter<"ReturnsAndCancellations"> | number
    restocking_fee?: FloatFilter<"ReturnsAndCancellations"> | number
    shipping_cost_loss?: FloatFilter<"ReturnsAndCancellations"> | number
    product_name?: StringFilter<"ReturnsAndCancellations"> | string
    quantity_returned?: IntFilter<"ReturnsAndCancellations"> | number
    original_price?: FloatFilter<"ReturnsAndCancellations"> | number
    marketplace?: StringNullableFilter<"ReturnsAndCancellations"> | string | null
    product_condition?: StringNullableFilter<"ReturnsAndCancellations"> | string | null
    resellable?: BoolFilter<"ReturnsAndCancellations"> | boolean
    import_batch_id?: StringNullableFilter<"ReturnsAndCancellations"> | string | null
    created_at?: DateTimeFilter<"ReturnsAndCancellations"> | Date | string
    updated_at?: DateTimeFilter<"ReturnsAndCancellations"> | Date | string
    import_batch?: XOR<ImportBatchNullableRelationFilter, ImportBatchWhereInput> | null
  }

  export type ReturnsAndCancellationsOrderByWithRelationInput = {
    id?: SortOrder
    original_order_id?: SortOrderInput | SortOrder
    original_sales_id?: SortOrderInput | SortOrder
    type?: SortOrder
    reason?: SortOrderInput | SortOrder
    return_date?: SortOrder
    returned_amount?: SortOrder
    refund_amount?: SortOrder
    restocking_fee?: SortOrder
    shipping_cost_loss?: SortOrder
    product_name?: SortOrder
    quantity_returned?: SortOrder
    original_price?: SortOrder
    marketplace?: SortOrderInput | SortOrder
    product_condition?: SortOrderInput | SortOrder
    resellable?: SortOrder
    import_batch_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    import_batch?: ImportBatchOrderByWithRelationInput
  }

  export type ReturnsAndCancellationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReturnsAndCancellationsWhereInput | ReturnsAndCancellationsWhereInput[]
    OR?: ReturnsAndCancellationsWhereInput[]
    NOT?: ReturnsAndCancellationsWhereInput | ReturnsAndCancellationsWhereInput[]
    original_order_id?: StringNullableFilter<"ReturnsAndCancellations"> | string | null
    original_sales_id?: StringNullableFilter<"ReturnsAndCancellations"> | string | null
    type?: StringFilter<"ReturnsAndCancellations"> | string
    reason?: StringNullableFilter<"ReturnsAndCancellations"> | string | null
    return_date?: DateTimeFilter<"ReturnsAndCancellations"> | Date | string
    returned_amount?: FloatFilter<"ReturnsAndCancellations"> | number
    refund_amount?: FloatFilter<"ReturnsAndCancellations"> | number
    restocking_fee?: FloatFilter<"ReturnsAndCancellations"> | number
    shipping_cost_loss?: FloatFilter<"ReturnsAndCancellations"> | number
    product_name?: StringFilter<"ReturnsAndCancellations"> | string
    quantity_returned?: IntFilter<"ReturnsAndCancellations"> | number
    original_price?: FloatFilter<"ReturnsAndCancellations"> | number
    marketplace?: StringNullableFilter<"ReturnsAndCancellations"> | string | null
    product_condition?: StringNullableFilter<"ReturnsAndCancellations"> | string | null
    resellable?: BoolFilter<"ReturnsAndCancellations"> | boolean
    import_batch_id?: StringNullableFilter<"ReturnsAndCancellations"> | string | null
    created_at?: DateTimeFilter<"ReturnsAndCancellations"> | Date | string
    updated_at?: DateTimeFilter<"ReturnsAndCancellations"> | Date | string
    import_batch?: XOR<ImportBatchNullableRelationFilter, ImportBatchWhereInput> | null
  }, "id">

  export type ReturnsAndCancellationsOrderByWithAggregationInput = {
    id?: SortOrder
    original_order_id?: SortOrderInput | SortOrder
    original_sales_id?: SortOrderInput | SortOrder
    type?: SortOrder
    reason?: SortOrderInput | SortOrder
    return_date?: SortOrder
    returned_amount?: SortOrder
    refund_amount?: SortOrder
    restocking_fee?: SortOrder
    shipping_cost_loss?: SortOrder
    product_name?: SortOrder
    quantity_returned?: SortOrder
    original_price?: SortOrder
    marketplace?: SortOrderInput | SortOrder
    product_condition?: SortOrderInput | SortOrder
    resellable?: SortOrder
    import_batch_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ReturnsAndCancellationsCountOrderByAggregateInput
    _avg?: ReturnsAndCancellationsAvgOrderByAggregateInput
    _max?: ReturnsAndCancellationsMaxOrderByAggregateInput
    _min?: ReturnsAndCancellationsMinOrderByAggregateInput
    _sum?: ReturnsAndCancellationsSumOrderByAggregateInput
  }

  export type ReturnsAndCancellationsScalarWhereWithAggregatesInput = {
    AND?: ReturnsAndCancellationsScalarWhereWithAggregatesInput | ReturnsAndCancellationsScalarWhereWithAggregatesInput[]
    OR?: ReturnsAndCancellationsScalarWhereWithAggregatesInput[]
    NOT?: ReturnsAndCancellationsScalarWhereWithAggregatesInput | ReturnsAndCancellationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReturnsAndCancellations"> | string
    original_order_id?: StringNullableWithAggregatesFilter<"ReturnsAndCancellations"> | string | null
    original_sales_id?: StringNullableWithAggregatesFilter<"ReturnsAndCancellations"> | string | null
    type?: StringWithAggregatesFilter<"ReturnsAndCancellations"> | string
    reason?: StringNullableWithAggregatesFilter<"ReturnsAndCancellations"> | string | null
    return_date?: DateTimeWithAggregatesFilter<"ReturnsAndCancellations"> | Date | string
    returned_amount?: FloatWithAggregatesFilter<"ReturnsAndCancellations"> | number
    refund_amount?: FloatWithAggregatesFilter<"ReturnsAndCancellations"> | number
    restocking_fee?: FloatWithAggregatesFilter<"ReturnsAndCancellations"> | number
    shipping_cost_loss?: FloatWithAggregatesFilter<"ReturnsAndCancellations"> | number
    product_name?: StringWithAggregatesFilter<"ReturnsAndCancellations"> | string
    quantity_returned?: IntWithAggregatesFilter<"ReturnsAndCancellations"> | number
    original_price?: FloatWithAggregatesFilter<"ReturnsAndCancellations"> | number
    marketplace?: StringNullableWithAggregatesFilter<"ReturnsAndCancellations"> | string | null
    product_condition?: StringNullableWithAggregatesFilter<"ReturnsAndCancellations"> | string | null
    resellable?: BoolWithAggregatesFilter<"ReturnsAndCancellations"> | boolean
    import_batch_id?: StringNullableWithAggregatesFilter<"ReturnsAndCancellations"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"ReturnsAndCancellations"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ReturnsAndCancellations"> | Date | string
  }

  export type MarketplaceReimbursementWhereInput = {
    AND?: MarketplaceReimbursementWhereInput | MarketplaceReimbursementWhereInput[]
    OR?: MarketplaceReimbursementWhereInput[]
    NOT?: MarketplaceReimbursementWhereInput | MarketplaceReimbursementWhereInput[]
    id?: StringFilter<"MarketplaceReimbursement"> | string
    claim_id?: StringNullableFilter<"MarketplaceReimbursement"> | string | null
    reimbursement_type?: StringFilter<"MarketplaceReimbursement"> | string
    claim_amount?: FloatFilter<"MarketplaceReimbursement"> | number
    approved_amount?: FloatFilter<"MarketplaceReimbursement"> | number
    received_amount?: FloatFilter<"MarketplaceReimbursement"> | number
    processing_fee?: FloatFilter<"MarketplaceReimbursement"> | number
    incident_date?: DateTimeFilter<"MarketplaceReimbursement"> | Date | string
    claim_date?: DateTimeFilter<"MarketplaceReimbursement"> | Date | string
    approval_date?: DateTimeNullableFilter<"MarketplaceReimbursement"> | Date | string | null
    received_date?: DateTimeNullableFilter<"MarketplaceReimbursement"> | Date | string | null
    affected_order_id?: StringNullableFilter<"MarketplaceReimbursement"> | string | null
    product_name?: StringNullableFilter<"MarketplaceReimbursement"> | string | null
    marketplace?: StringFilter<"MarketplaceReimbursement"> | string
    status?: StringFilter<"MarketplaceReimbursement"> | string
    notes?: StringNullableFilter<"MarketplaceReimbursement"> | string | null
    evidence_provided?: StringNullableFilter<"MarketplaceReimbursement"> | string | null
    import_batch_id?: StringNullableFilter<"MarketplaceReimbursement"> | string | null
    created_at?: DateTimeFilter<"MarketplaceReimbursement"> | Date | string
    updated_at?: DateTimeFilter<"MarketplaceReimbursement"> | Date | string
    import_batch?: XOR<ImportBatchNullableRelationFilter, ImportBatchWhereInput> | null
  }

  export type MarketplaceReimbursementOrderByWithRelationInput = {
    id?: SortOrder
    claim_id?: SortOrderInput | SortOrder
    reimbursement_type?: SortOrder
    claim_amount?: SortOrder
    approved_amount?: SortOrder
    received_amount?: SortOrder
    processing_fee?: SortOrder
    incident_date?: SortOrder
    claim_date?: SortOrder
    approval_date?: SortOrderInput | SortOrder
    received_date?: SortOrderInput | SortOrder
    affected_order_id?: SortOrderInput | SortOrder
    product_name?: SortOrderInput | SortOrder
    marketplace?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    evidence_provided?: SortOrderInput | SortOrder
    import_batch_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    import_batch?: ImportBatchOrderByWithRelationInput
  }

  export type MarketplaceReimbursementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MarketplaceReimbursementWhereInput | MarketplaceReimbursementWhereInput[]
    OR?: MarketplaceReimbursementWhereInput[]
    NOT?: MarketplaceReimbursementWhereInput | MarketplaceReimbursementWhereInput[]
    claim_id?: StringNullableFilter<"MarketplaceReimbursement"> | string | null
    reimbursement_type?: StringFilter<"MarketplaceReimbursement"> | string
    claim_amount?: FloatFilter<"MarketplaceReimbursement"> | number
    approved_amount?: FloatFilter<"MarketplaceReimbursement"> | number
    received_amount?: FloatFilter<"MarketplaceReimbursement"> | number
    processing_fee?: FloatFilter<"MarketplaceReimbursement"> | number
    incident_date?: DateTimeFilter<"MarketplaceReimbursement"> | Date | string
    claim_date?: DateTimeFilter<"MarketplaceReimbursement"> | Date | string
    approval_date?: DateTimeNullableFilter<"MarketplaceReimbursement"> | Date | string | null
    received_date?: DateTimeNullableFilter<"MarketplaceReimbursement"> | Date | string | null
    affected_order_id?: StringNullableFilter<"MarketplaceReimbursement"> | string | null
    product_name?: StringNullableFilter<"MarketplaceReimbursement"> | string | null
    marketplace?: StringFilter<"MarketplaceReimbursement"> | string
    status?: StringFilter<"MarketplaceReimbursement"> | string
    notes?: StringNullableFilter<"MarketplaceReimbursement"> | string | null
    evidence_provided?: StringNullableFilter<"MarketplaceReimbursement"> | string | null
    import_batch_id?: StringNullableFilter<"MarketplaceReimbursement"> | string | null
    created_at?: DateTimeFilter<"MarketplaceReimbursement"> | Date | string
    updated_at?: DateTimeFilter<"MarketplaceReimbursement"> | Date | string
    import_batch?: XOR<ImportBatchNullableRelationFilter, ImportBatchWhereInput> | null
  }, "id">

  export type MarketplaceReimbursementOrderByWithAggregationInput = {
    id?: SortOrder
    claim_id?: SortOrderInput | SortOrder
    reimbursement_type?: SortOrder
    claim_amount?: SortOrder
    approved_amount?: SortOrder
    received_amount?: SortOrder
    processing_fee?: SortOrder
    incident_date?: SortOrder
    claim_date?: SortOrder
    approval_date?: SortOrderInput | SortOrder
    received_date?: SortOrderInput | SortOrder
    affected_order_id?: SortOrderInput | SortOrder
    product_name?: SortOrderInput | SortOrder
    marketplace?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    evidence_provided?: SortOrderInput | SortOrder
    import_batch_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: MarketplaceReimbursementCountOrderByAggregateInput
    _avg?: MarketplaceReimbursementAvgOrderByAggregateInput
    _max?: MarketplaceReimbursementMaxOrderByAggregateInput
    _min?: MarketplaceReimbursementMinOrderByAggregateInput
    _sum?: MarketplaceReimbursementSumOrderByAggregateInput
  }

  export type MarketplaceReimbursementScalarWhereWithAggregatesInput = {
    AND?: MarketplaceReimbursementScalarWhereWithAggregatesInput | MarketplaceReimbursementScalarWhereWithAggregatesInput[]
    OR?: MarketplaceReimbursementScalarWhereWithAggregatesInput[]
    NOT?: MarketplaceReimbursementScalarWhereWithAggregatesInput | MarketplaceReimbursementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MarketplaceReimbursement"> | string
    claim_id?: StringNullableWithAggregatesFilter<"MarketplaceReimbursement"> | string | null
    reimbursement_type?: StringWithAggregatesFilter<"MarketplaceReimbursement"> | string
    claim_amount?: FloatWithAggregatesFilter<"MarketplaceReimbursement"> | number
    approved_amount?: FloatWithAggregatesFilter<"MarketplaceReimbursement"> | number
    received_amount?: FloatWithAggregatesFilter<"MarketplaceReimbursement"> | number
    processing_fee?: FloatWithAggregatesFilter<"MarketplaceReimbursement"> | number
    incident_date?: DateTimeWithAggregatesFilter<"MarketplaceReimbursement"> | Date | string
    claim_date?: DateTimeWithAggregatesFilter<"MarketplaceReimbursement"> | Date | string
    approval_date?: DateTimeNullableWithAggregatesFilter<"MarketplaceReimbursement"> | Date | string | null
    received_date?: DateTimeNullableWithAggregatesFilter<"MarketplaceReimbursement"> | Date | string | null
    affected_order_id?: StringNullableWithAggregatesFilter<"MarketplaceReimbursement"> | string | null
    product_name?: StringNullableWithAggregatesFilter<"MarketplaceReimbursement"> | string | null
    marketplace?: StringWithAggregatesFilter<"MarketplaceReimbursement"> | string
    status?: StringWithAggregatesFilter<"MarketplaceReimbursement"> | string
    notes?: StringNullableWithAggregatesFilter<"MarketplaceReimbursement"> | string | null
    evidence_provided?: StringNullableWithAggregatesFilter<"MarketplaceReimbursement"> | string | null
    import_batch_id?: StringNullableWithAggregatesFilter<"MarketplaceReimbursement"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"MarketplaceReimbursement"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"MarketplaceReimbursement"> | Date | string
  }

  export type CommissionAdjustmentsWhereInput = {
    AND?: CommissionAdjustmentsWhereInput | CommissionAdjustmentsWhereInput[]
    OR?: CommissionAdjustmentsWhereInput[]
    NOT?: CommissionAdjustmentsWhereInput | CommissionAdjustmentsWhereInput[]
    id?: StringFilter<"CommissionAdjustments"> | string
    original_order_id?: StringNullableFilter<"CommissionAdjustments"> | string | null
    original_sales_id?: StringNullableFilter<"CommissionAdjustments"> | string | null
    adjustment_type?: StringFilter<"CommissionAdjustments"> | string
    reason?: StringNullableFilter<"CommissionAdjustments"> | string | null
    original_commission?: FloatFilter<"CommissionAdjustments"> | number
    adjustment_amount?: FloatFilter<"CommissionAdjustments"> | number
    final_commission?: FloatFilter<"CommissionAdjustments"> | number
    marketplace?: StringFilter<"CommissionAdjustments"> | string
    commission_rate?: FloatNullableFilter<"CommissionAdjustments"> | number | null
    dynamic_rate_applied?: BoolFilter<"CommissionAdjustments"> | boolean
    transaction_date?: DateTimeFilter<"CommissionAdjustments"> | Date | string
    adjustment_date?: DateTimeFilter<"CommissionAdjustments"> | Date | string
    product_name?: StringNullableFilter<"CommissionAdjustments"> | string | null
    quantity?: IntFilter<"CommissionAdjustments"> | number
    product_price?: FloatFilter<"CommissionAdjustments"> | number
    import_batch_id?: StringNullableFilter<"CommissionAdjustments"> | string | null
    created_at?: DateTimeFilter<"CommissionAdjustments"> | Date | string
    updated_at?: DateTimeFilter<"CommissionAdjustments"> | Date | string
    import_batch?: XOR<ImportBatchNullableRelationFilter, ImportBatchWhereInput> | null
  }

  export type CommissionAdjustmentsOrderByWithRelationInput = {
    id?: SortOrder
    original_order_id?: SortOrderInput | SortOrder
    original_sales_id?: SortOrderInput | SortOrder
    adjustment_type?: SortOrder
    reason?: SortOrderInput | SortOrder
    original_commission?: SortOrder
    adjustment_amount?: SortOrder
    final_commission?: SortOrder
    marketplace?: SortOrder
    commission_rate?: SortOrderInput | SortOrder
    dynamic_rate_applied?: SortOrder
    transaction_date?: SortOrder
    adjustment_date?: SortOrder
    product_name?: SortOrderInput | SortOrder
    quantity?: SortOrder
    product_price?: SortOrder
    import_batch_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    import_batch?: ImportBatchOrderByWithRelationInput
  }

  export type CommissionAdjustmentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommissionAdjustmentsWhereInput | CommissionAdjustmentsWhereInput[]
    OR?: CommissionAdjustmentsWhereInput[]
    NOT?: CommissionAdjustmentsWhereInput | CommissionAdjustmentsWhereInput[]
    original_order_id?: StringNullableFilter<"CommissionAdjustments"> | string | null
    original_sales_id?: StringNullableFilter<"CommissionAdjustments"> | string | null
    adjustment_type?: StringFilter<"CommissionAdjustments"> | string
    reason?: StringNullableFilter<"CommissionAdjustments"> | string | null
    original_commission?: FloatFilter<"CommissionAdjustments"> | number
    adjustment_amount?: FloatFilter<"CommissionAdjustments"> | number
    final_commission?: FloatFilter<"CommissionAdjustments"> | number
    marketplace?: StringFilter<"CommissionAdjustments"> | string
    commission_rate?: FloatNullableFilter<"CommissionAdjustments"> | number | null
    dynamic_rate_applied?: BoolFilter<"CommissionAdjustments"> | boolean
    transaction_date?: DateTimeFilter<"CommissionAdjustments"> | Date | string
    adjustment_date?: DateTimeFilter<"CommissionAdjustments"> | Date | string
    product_name?: StringNullableFilter<"CommissionAdjustments"> | string | null
    quantity?: IntFilter<"CommissionAdjustments"> | number
    product_price?: FloatFilter<"CommissionAdjustments"> | number
    import_batch_id?: StringNullableFilter<"CommissionAdjustments"> | string | null
    created_at?: DateTimeFilter<"CommissionAdjustments"> | Date | string
    updated_at?: DateTimeFilter<"CommissionAdjustments"> | Date | string
    import_batch?: XOR<ImportBatchNullableRelationFilter, ImportBatchWhereInput> | null
  }, "id">

  export type CommissionAdjustmentsOrderByWithAggregationInput = {
    id?: SortOrder
    original_order_id?: SortOrderInput | SortOrder
    original_sales_id?: SortOrderInput | SortOrder
    adjustment_type?: SortOrder
    reason?: SortOrderInput | SortOrder
    original_commission?: SortOrder
    adjustment_amount?: SortOrder
    final_commission?: SortOrder
    marketplace?: SortOrder
    commission_rate?: SortOrderInput | SortOrder
    dynamic_rate_applied?: SortOrder
    transaction_date?: SortOrder
    adjustment_date?: SortOrder
    product_name?: SortOrderInput | SortOrder
    quantity?: SortOrder
    product_price?: SortOrder
    import_batch_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CommissionAdjustmentsCountOrderByAggregateInput
    _avg?: CommissionAdjustmentsAvgOrderByAggregateInput
    _max?: CommissionAdjustmentsMaxOrderByAggregateInput
    _min?: CommissionAdjustmentsMinOrderByAggregateInput
    _sum?: CommissionAdjustmentsSumOrderByAggregateInput
  }

  export type CommissionAdjustmentsScalarWhereWithAggregatesInput = {
    AND?: CommissionAdjustmentsScalarWhereWithAggregatesInput | CommissionAdjustmentsScalarWhereWithAggregatesInput[]
    OR?: CommissionAdjustmentsScalarWhereWithAggregatesInput[]
    NOT?: CommissionAdjustmentsScalarWhereWithAggregatesInput | CommissionAdjustmentsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CommissionAdjustments"> | string
    original_order_id?: StringNullableWithAggregatesFilter<"CommissionAdjustments"> | string | null
    original_sales_id?: StringNullableWithAggregatesFilter<"CommissionAdjustments"> | string | null
    adjustment_type?: StringWithAggregatesFilter<"CommissionAdjustments"> | string
    reason?: StringNullableWithAggregatesFilter<"CommissionAdjustments"> | string | null
    original_commission?: FloatWithAggregatesFilter<"CommissionAdjustments"> | number
    adjustment_amount?: FloatWithAggregatesFilter<"CommissionAdjustments"> | number
    final_commission?: FloatWithAggregatesFilter<"CommissionAdjustments"> | number
    marketplace?: StringWithAggregatesFilter<"CommissionAdjustments"> | string
    commission_rate?: FloatNullableWithAggregatesFilter<"CommissionAdjustments"> | number | null
    dynamic_rate_applied?: BoolWithAggregatesFilter<"CommissionAdjustments"> | boolean
    transaction_date?: DateTimeWithAggregatesFilter<"CommissionAdjustments"> | Date | string
    adjustment_date?: DateTimeWithAggregatesFilter<"CommissionAdjustments"> | Date | string
    product_name?: StringNullableWithAggregatesFilter<"CommissionAdjustments"> | string | null
    quantity?: IntWithAggregatesFilter<"CommissionAdjustments"> | number
    product_price?: FloatWithAggregatesFilter<"CommissionAdjustments"> | number
    import_batch_id?: StringNullableWithAggregatesFilter<"CommissionAdjustments"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"CommissionAdjustments"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"CommissionAdjustments"> | Date | string
  }

  export type AffiliateSamplesWhereInput = {
    AND?: AffiliateSamplesWhereInput | AffiliateSamplesWhereInput[]
    OR?: AffiliateSamplesWhereInput[]
    NOT?: AffiliateSamplesWhereInput | AffiliateSamplesWhereInput[]
    id?: StringFilter<"AffiliateSamples"> | string
    affiliate_name?: StringFilter<"AffiliateSamples"> | string
    affiliate_platform?: StringNullableFilter<"AffiliateSamples"> | string | null
    affiliate_contact?: StringNullableFilter<"AffiliateSamples"> | string | null
    product_name?: StringFilter<"AffiliateSamples"> | string
    product_sku?: StringNullableFilter<"AffiliateSamples"> | string | null
    quantity_given?: IntFilter<"AffiliateSamples"> | number
    product_cost?: FloatFilter<"AffiliateSamples"> | number
    total_cost?: FloatFilter<"AffiliateSamples"> | number
    shipping_cost?: FloatFilter<"AffiliateSamples"> | number
    packaging_cost?: FloatFilter<"AffiliateSamples"> | number
    campaign_name?: StringNullableFilter<"AffiliateSamples"> | string | null
    expected_reach?: IntNullableFilter<"AffiliateSamples"> | number | null
    content_type?: StringNullableFilter<"AffiliateSamples"> | string | null
    given_date?: DateTimeFilter<"AffiliateSamples"> | Date | string
    expected_content_date?: DateTimeNullableFilter<"AffiliateSamples"> | Date | string | null
    actual_content_date?: DateTimeNullableFilter<"AffiliateSamples"> | Date | string | null
    content_delivered?: BoolFilter<"AffiliateSamples"> | boolean
    performance_notes?: StringNullableFilter<"AffiliateSamples"> | string | null
    roi_estimate?: FloatNullableFilter<"AffiliateSamples"> | number | null
    status?: StringFilter<"AffiliateSamples"> | string
    import_batch_id?: StringNullableFilter<"AffiliateSamples"> | string | null
    created_at?: DateTimeFilter<"AffiliateSamples"> | Date | string
    updated_at?: DateTimeFilter<"AffiliateSamples"> | Date | string
    import_batch?: XOR<ImportBatchNullableRelationFilter, ImportBatchWhereInput> | null
  }

  export type AffiliateSamplesOrderByWithRelationInput = {
    id?: SortOrder
    affiliate_name?: SortOrder
    affiliate_platform?: SortOrderInput | SortOrder
    affiliate_contact?: SortOrderInput | SortOrder
    product_name?: SortOrder
    product_sku?: SortOrderInput | SortOrder
    quantity_given?: SortOrder
    product_cost?: SortOrder
    total_cost?: SortOrder
    shipping_cost?: SortOrder
    packaging_cost?: SortOrder
    campaign_name?: SortOrderInput | SortOrder
    expected_reach?: SortOrderInput | SortOrder
    content_type?: SortOrderInput | SortOrder
    given_date?: SortOrder
    expected_content_date?: SortOrderInput | SortOrder
    actual_content_date?: SortOrderInput | SortOrder
    content_delivered?: SortOrder
    performance_notes?: SortOrderInput | SortOrder
    roi_estimate?: SortOrderInput | SortOrder
    status?: SortOrder
    import_batch_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    import_batch?: ImportBatchOrderByWithRelationInput
  }

  export type AffiliateSamplesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AffiliateSamplesWhereInput | AffiliateSamplesWhereInput[]
    OR?: AffiliateSamplesWhereInput[]
    NOT?: AffiliateSamplesWhereInput | AffiliateSamplesWhereInput[]
    affiliate_name?: StringFilter<"AffiliateSamples"> | string
    affiliate_platform?: StringNullableFilter<"AffiliateSamples"> | string | null
    affiliate_contact?: StringNullableFilter<"AffiliateSamples"> | string | null
    product_name?: StringFilter<"AffiliateSamples"> | string
    product_sku?: StringNullableFilter<"AffiliateSamples"> | string | null
    quantity_given?: IntFilter<"AffiliateSamples"> | number
    product_cost?: FloatFilter<"AffiliateSamples"> | number
    total_cost?: FloatFilter<"AffiliateSamples"> | number
    shipping_cost?: FloatFilter<"AffiliateSamples"> | number
    packaging_cost?: FloatFilter<"AffiliateSamples"> | number
    campaign_name?: StringNullableFilter<"AffiliateSamples"> | string | null
    expected_reach?: IntNullableFilter<"AffiliateSamples"> | number | null
    content_type?: StringNullableFilter<"AffiliateSamples"> | string | null
    given_date?: DateTimeFilter<"AffiliateSamples"> | Date | string
    expected_content_date?: DateTimeNullableFilter<"AffiliateSamples"> | Date | string | null
    actual_content_date?: DateTimeNullableFilter<"AffiliateSamples"> | Date | string | null
    content_delivered?: BoolFilter<"AffiliateSamples"> | boolean
    performance_notes?: StringNullableFilter<"AffiliateSamples"> | string | null
    roi_estimate?: FloatNullableFilter<"AffiliateSamples"> | number | null
    status?: StringFilter<"AffiliateSamples"> | string
    import_batch_id?: StringNullableFilter<"AffiliateSamples"> | string | null
    created_at?: DateTimeFilter<"AffiliateSamples"> | Date | string
    updated_at?: DateTimeFilter<"AffiliateSamples"> | Date | string
    import_batch?: XOR<ImportBatchNullableRelationFilter, ImportBatchWhereInput> | null
  }, "id">

  export type AffiliateSamplesOrderByWithAggregationInput = {
    id?: SortOrder
    affiliate_name?: SortOrder
    affiliate_platform?: SortOrderInput | SortOrder
    affiliate_contact?: SortOrderInput | SortOrder
    product_name?: SortOrder
    product_sku?: SortOrderInput | SortOrder
    quantity_given?: SortOrder
    product_cost?: SortOrder
    total_cost?: SortOrder
    shipping_cost?: SortOrder
    packaging_cost?: SortOrder
    campaign_name?: SortOrderInput | SortOrder
    expected_reach?: SortOrderInput | SortOrder
    content_type?: SortOrderInput | SortOrder
    given_date?: SortOrder
    expected_content_date?: SortOrderInput | SortOrder
    actual_content_date?: SortOrderInput | SortOrder
    content_delivered?: SortOrder
    performance_notes?: SortOrderInput | SortOrder
    roi_estimate?: SortOrderInput | SortOrder
    status?: SortOrder
    import_batch_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: AffiliateSamplesCountOrderByAggregateInput
    _avg?: AffiliateSamplesAvgOrderByAggregateInput
    _max?: AffiliateSamplesMaxOrderByAggregateInput
    _min?: AffiliateSamplesMinOrderByAggregateInput
    _sum?: AffiliateSamplesSumOrderByAggregateInput
  }

  export type AffiliateSamplesScalarWhereWithAggregatesInput = {
    AND?: AffiliateSamplesScalarWhereWithAggregatesInput | AffiliateSamplesScalarWhereWithAggregatesInput[]
    OR?: AffiliateSamplesScalarWhereWithAggregatesInput[]
    NOT?: AffiliateSamplesScalarWhereWithAggregatesInput | AffiliateSamplesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AffiliateSamples"> | string
    affiliate_name?: StringWithAggregatesFilter<"AffiliateSamples"> | string
    affiliate_platform?: StringNullableWithAggregatesFilter<"AffiliateSamples"> | string | null
    affiliate_contact?: StringNullableWithAggregatesFilter<"AffiliateSamples"> | string | null
    product_name?: StringWithAggregatesFilter<"AffiliateSamples"> | string
    product_sku?: StringNullableWithAggregatesFilter<"AffiliateSamples"> | string | null
    quantity_given?: IntWithAggregatesFilter<"AffiliateSamples"> | number
    product_cost?: FloatWithAggregatesFilter<"AffiliateSamples"> | number
    total_cost?: FloatWithAggregatesFilter<"AffiliateSamples"> | number
    shipping_cost?: FloatWithAggregatesFilter<"AffiliateSamples"> | number
    packaging_cost?: FloatWithAggregatesFilter<"AffiliateSamples"> | number
    campaign_name?: StringNullableWithAggregatesFilter<"AffiliateSamples"> | string | null
    expected_reach?: IntNullableWithAggregatesFilter<"AffiliateSamples"> | number | null
    content_type?: StringNullableWithAggregatesFilter<"AffiliateSamples"> | string | null
    given_date?: DateTimeWithAggregatesFilter<"AffiliateSamples"> | Date | string
    expected_content_date?: DateTimeNullableWithAggregatesFilter<"AffiliateSamples"> | Date | string | null
    actual_content_date?: DateTimeNullableWithAggregatesFilter<"AffiliateSamples"> | Date | string | null
    content_delivered?: BoolWithAggregatesFilter<"AffiliateSamples"> | boolean
    performance_notes?: StringNullableWithAggregatesFilter<"AffiliateSamples"> | string | null
    roi_estimate?: FloatNullableWithAggregatesFilter<"AffiliateSamples"> | number | null
    status?: StringWithAggregatesFilter<"AffiliateSamples"> | string
    import_batch_id?: StringNullableWithAggregatesFilter<"AffiliateSamples"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"AffiliateSamples"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"AffiliateSamples"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    color?: StringNullableFilter<"Category"> | string | null
    created_at?: DateTimeFilter<"Category"> | Date | string
    updated_at?: DateTimeFilter<"Category"> | Date | string
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    description?: StringNullableFilter<"Category"> | string | null
    color?: StringNullableFilter<"Category"> | string | null
    created_at?: DateTimeFilter<"Category"> | Date | string
    updated_at?: DateTimeFilter<"Category"> | Date | string
  }, "id" | "name">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    color?: StringNullableWithAggregatesFilter<"Category"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type BrandWhereInput = {
    AND?: BrandWhereInput | BrandWhereInput[]
    OR?: BrandWhereInput[]
    NOT?: BrandWhereInput | BrandWhereInput[]
    id?: StringFilter<"Brand"> | string
    name?: StringFilter<"Brand"> | string
    description?: StringNullableFilter<"Brand"> | string | null
    website?: StringNullableFilter<"Brand"> | string | null
    logo_color?: StringNullableFilter<"Brand"> | string | null
    is_premium?: BoolFilter<"Brand"> | boolean
    created_at?: DateTimeFilter<"Brand"> | Date | string
    updated_at?: DateTimeFilter<"Brand"> | Date | string
  }

  export type BrandOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    logo_color?: SortOrderInput | SortOrder
    is_premium?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BrandWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: BrandWhereInput | BrandWhereInput[]
    OR?: BrandWhereInput[]
    NOT?: BrandWhereInput | BrandWhereInput[]
    description?: StringNullableFilter<"Brand"> | string | null
    website?: StringNullableFilter<"Brand"> | string | null
    logo_color?: StringNullableFilter<"Brand"> | string | null
    is_premium?: BoolFilter<"Brand"> | boolean
    created_at?: DateTimeFilter<"Brand"> | Date | string
    updated_at?: DateTimeFilter<"Brand"> | Date | string
  }, "id" | "name">

  export type BrandOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    logo_color?: SortOrderInput | SortOrder
    is_premium?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: BrandCountOrderByAggregateInput
    _max?: BrandMaxOrderByAggregateInput
    _min?: BrandMinOrderByAggregateInput
  }

  export type BrandScalarWhereWithAggregatesInput = {
    AND?: BrandScalarWhereWithAggregatesInput | BrandScalarWhereWithAggregatesInput[]
    OR?: BrandScalarWhereWithAggregatesInput[]
    NOT?: BrandScalarWhereWithAggregatesInput | BrandScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Brand"> | string
    name?: StringWithAggregatesFilter<"Brand"> | string
    description?: StringNullableWithAggregatesFilter<"Brand"> | string | null
    website?: StringNullableWithAggregatesFilter<"Brand"> | string | null
    logo_color?: StringNullableWithAggregatesFilter<"Brand"> | string | null
    is_premium?: BoolWithAggregatesFilter<"Brand"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Brand"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Brand"> | Date | string
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    id?: StringFilter<"Supplier"> | string
    code?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    contact_person?: StringFilter<"Supplier"> | string
    phone?: StringFilter<"Supplier"> | string
    email?: StringFilter<"Supplier"> | string
    address?: StringFilter<"Supplier"> | string
    category?: StringFilter<"Supplier"> | string
    rating?: FloatFilter<"Supplier"> | number
    status?: EnumSupplierStatusFilter<"Supplier"> | $Enums.SupplierStatus
    payment_terms?: StringFilter<"Supplier"> | string
    created_at?: DateTimeFilter<"Supplier"> | Date | string
    updated_at?: DateTimeFilter<"Supplier"> | Date | string
    purchase_orders?: PurchaseOrderListRelationFilter
  }

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    contact_person?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    category?: SortOrder
    rating?: SortOrder
    status?: SortOrder
    payment_terms?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    purchase_orders?: PurchaseOrderOrderByRelationAggregateInput
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    name?: StringFilter<"Supplier"> | string
    contact_person?: StringFilter<"Supplier"> | string
    phone?: StringFilter<"Supplier"> | string
    email?: StringFilter<"Supplier"> | string
    address?: StringFilter<"Supplier"> | string
    category?: StringFilter<"Supplier"> | string
    rating?: FloatFilter<"Supplier"> | number
    status?: EnumSupplierStatusFilter<"Supplier"> | $Enums.SupplierStatus
    payment_terms?: StringFilter<"Supplier"> | string
    created_at?: DateTimeFilter<"Supplier"> | Date | string
    updated_at?: DateTimeFilter<"Supplier"> | Date | string
    purchase_orders?: PurchaseOrderListRelationFilter
  }, "id" | "code">

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    contact_person?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    category?: SortOrder
    rating?: SortOrder
    status?: SortOrder
    payment_terms?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _avg?: SupplierAvgOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
    _sum?: SupplierSumOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Supplier"> | string
    code?: StringWithAggregatesFilter<"Supplier"> | string
    name?: StringWithAggregatesFilter<"Supplier"> | string
    contact_person?: StringWithAggregatesFilter<"Supplier"> | string
    phone?: StringWithAggregatesFilter<"Supplier"> | string
    email?: StringWithAggregatesFilter<"Supplier"> | string
    address?: StringWithAggregatesFilter<"Supplier"> | string
    category?: StringWithAggregatesFilter<"Supplier"> | string
    rating?: FloatWithAggregatesFilter<"Supplier"> | number
    status?: EnumSupplierStatusWithAggregatesFilter<"Supplier"> | $Enums.SupplierStatus
    payment_terms?: StringWithAggregatesFilter<"Supplier"> | string
    created_at?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
  }

  export type PurchaseOrderWhereInput = {
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    id?: StringFilter<"PurchaseOrder"> | string
    po_number?: StringFilter<"PurchaseOrder"> | string
    supplier_id?: StringFilter<"PurchaseOrder"> | string
    po_date?: DateTimeFilter<"PurchaseOrder"> | Date | string
    expected_date?: DateTimeFilter<"PurchaseOrder"> | Date | string
    delivery_date?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    status?: EnumPOStatusFilter<"PurchaseOrder"> | $Enums.POStatus
    total_amount?: FloatFilter<"PurchaseOrder"> | number
    items_count?: IntFilter<"PurchaseOrder"> | number
    notes?: StringNullableFilter<"PurchaseOrder"> | string | null
    created_by?: StringNullableFilter<"PurchaseOrder"> | string | null
    created_at?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updated_at?: DateTimeFilter<"PurchaseOrder"> | Date | string
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput>
    items?: PurchaseOrderItemListRelationFilter
  }

  export type PurchaseOrderOrderByWithRelationInput = {
    id?: SortOrder
    po_number?: SortOrder
    supplier_id?: SortOrder
    po_date?: SortOrder
    expected_date?: SortOrder
    delivery_date?: SortOrderInput | SortOrder
    status?: SortOrder
    total_amount?: SortOrder
    items_count?: SortOrder
    notes?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    supplier?: SupplierOrderByWithRelationInput
    items?: PurchaseOrderItemOrderByRelationAggregateInput
  }

  export type PurchaseOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    po_number?: string
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    supplier_id?: StringFilter<"PurchaseOrder"> | string
    po_date?: DateTimeFilter<"PurchaseOrder"> | Date | string
    expected_date?: DateTimeFilter<"PurchaseOrder"> | Date | string
    delivery_date?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    status?: EnumPOStatusFilter<"PurchaseOrder"> | $Enums.POStatus
    total_amount?: FloatFilter<"PurchaseOrder"> | number
    items_count?: IntFilter<"PurchaseOrder"> | number
    notes?: StringNullableFilter<"PurchaseOrder"> | string | null
    created_by?: StringNullableFilter<"PurchaseOrder"> | string | null
    created_at?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updated_at?: DateTimeFilter<"PurchaseOrder"> | Date | string
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput>
    items?: PurchaseOrderItemListRelationFilter
  }, "id" | "po_number">

  export type PurchaseOrderOrderByWithAggregationInput = {
    id?: SortOrder
    po_number?: SortOrder
    supplier_id?: SortOrder
    po_date?: SortOrder
    expected_date?: SortOrder
    delivery_date?: SortOrderInput | SortOrder
    status?: SortOrder
    total_amount?: SortOrder
    items_count?: SortOrder
    notes?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: PurchaseOrderCountOrderByAggregateInput
    _avg?: PurchaseOrderAvgOrderByAggregateInput
    _max?: PurchaseOrderMaxOrderByAggregateInput
    _min?: PurchaseOrderMinOrderByAggregateInput
    _sum?: PurchaseOrderSumOrderByAggregateInput
  }

  export type PurchaseOrderScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    po_number?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    supplier_id?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    po_date?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    expected_date?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    delivery_date?: DateTimeNullableWithAggregatesFilter<"PurchaseOrder"> | Date | string | null
    status?: EnumPOStatusWithAggregatesFilter<"PurchaseOrder"> | $Enums.POStatus
    total_amount?: FloatWithAggregatesFilter<"PurchaseOrder"> | number
    items_count?: IntWithAggregatesFilter<"PurchaseOrder"> | number
    notes?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    created_by?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
  }

  export type PurchaseOrderItemWhereInput = {
    AND?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    OR?: PurchaseOrderItemWhereInput[]
    NOT?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    id?: StringFilter<"PurchaseOrderItem"> | string
    purchase_order_id?: StringFilter<"PurchaseOrderItem"> | string
    material_id?: StringFilter<"PurchaseOrderItem"> | string
    material_name?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    material_description?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    quantity?: FloatFilter<"PurchaseOrderItem"> | number
    unit_price?: FloatFilter<"PurchaseOrderItem"> | number
    total_price?: FloatFilter<"PurchaseOrderItem"> | number
    received_quantity?: FloatNullableFilter<"PurchaseOrderItem"> | number | null
    unit?: StringFilter<"PurchaseOrderItem"> | string
    notes?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    created_at?: DateTimeFilter<"PurchaseOrderItem"> | Date | string
    updated_at?: DateTimeFilter<"PurchaseOrderItem"> | Date | string
    purchase_order?: XOR<PurchaseOrderRelationFilter, PurchaseOrderWhereInput>
  }

  export type PurchaseOrderItemOrderByWithRelationInput = {
    id?: SortOrder
    purchase_order_id?: SortOrder
    material_id?: SortOrder
    material_name?: SortOrderInput | SortOrder
    material_description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total_price?: SortOrder
    received_quantity?: SortOrderInput | SortOrder
    unit?: SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    purchase_order?: PurchaseOrderOrderByWithRelationInput
  }

  export type PurchaseOrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    purchase_order_id_material_id?: PurchaseOrderItemPurchase_order_idMaterial_idCompoundUniqueInput
    AND?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    OR?: PurchaseOrderItemWhereInput[]
    NOT?: PurchaseOrderItemWhereInput | PurchaseOrderItemWhereInput[]
    purchase_order_id?: StringFilter<"PurchaseOrderItem"> | string
    material_id?: StringFilter<"PurchaseOrderItem"> | string
    material_name?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    material_description?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    quantity?: FloatFilter<"PurchaseOrderItem"> | number
    unit_price?: FloatFilter<"PurchaseOrderItem"> | number
    total_price?: FloatFilter<"PurchaseOrderItem"> | number
    received_quantity?: FloatNullableFilter<"PurchaseOrderItem"> | number | null
    unit?: StringFilter<"PurchaseOrderItem"> | string
    notes?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    created_at?: DateTimeFilter<"PurchaseOrderItem"> | Date | string
    updated_at?: DateTimeFilter<"PurchaseOrderItem"> | Date | string
    purchase_order?: XOR<PurchaseOrderRelationFilter, PurchaseOrderWhereInput>
  }, "id" | "purchase_order_id_material_id">

  export type PurchaseOrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    purchase_order_id?: SortOrder
    material_id?: SortOrder
    material_name?: SortOrderInput | SortOrder
    material_description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total_price?: SortOrder
    received_quantity?: SortOrderInput | SortOrder
    unit?: SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: PurchaseOrderItemCountOrderByAggregateInput
    _avg?: PurchaseOrderItemAvgOrderByAggregateInput
    _max?: PurchaseOrderItemMaxOrderByAggregateInput
    _min?: PurchaseOrderItemMinOrderByAggregateInput
    _sum?: PurchaseOrderItemSumOrderByAggregateInput
  }

  export type PurchaseOrderItemScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderItemScalarWhereWithAggregatesInput | PurchaseOrderItemScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderItemScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderItemScalarWhereWithAggregatesInput | PurchaseOrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseOrderItem"> | string
    purchase_order_id?: StringWithAggregatesFilter<"PurchaseOrderItem"> | string
    material_id?: StringWithAggregatesFilter<"PurchaseOrderItem"> | string
    material_name?: StringNullableWithAggregatesFilter<"PurchaseOrderItem"> | string | null
    material_description?: StringNullableWithAggregatesFilter<"PurchaseOrderItem"> | string | null
    quantity?: FloatWithAggregatesFilter<"PurchaseOrderItem"> | number
    unit_price?: FloatWithAggregatesFilter<"PurchaseOrderItem"> | number
    total_price?: FloatWithAggregatesFilter<"PurchaseOrderItem"> | number
    received_quantity?: FloatNullableWithAggregatesFilter<"PurchaseOrderItem"> | number | null
    unit?: StringWithAggregatesFilter<"PurchaseOrderItem"> | string
    notes?: StringNullableWithAggregatesFilter<"PurchaseOrderItem"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"PurchaseOrderItem"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"PurchaseOrderItem"> | Date | string
  }

  export type CashFlowEntryWhereInput = {
    AND?: CashFlowEntryWhereInput | CashFlowEntryWhereInput[]
    OR?: CashFlowEntryWhereInput[]
    NOT?: CashFlowEntryWhereInput | CashFlowEntryWhereInput[]
    id?: StringFilter<"CashFlowEntry"> | string
    entry_date?: DateTimeFilter<"CashFlowEntry"> | Date | string
    description?: StringFilter<"CashFlowEntry"> | string
    category?: StringFilter<"CashFlowEntry"> | string
    entry_type?: EnumCashFlowTypeFilter<"CashFlowEntry"> | $Enums.CashFlowType
    amount?: FloatFilter<"CashFlowEntry"> | number
    source?: StringFilter<"CashFlowEntry"> | string
    marketplace?: StringNullableFilter<"CashFlowEntry"> | string | null
    reference?: StringNullableFilter<"CashFlowEntry"> | string | null
    notes?: StringNullableFilter<"CashFlowEntry"> | string | null
    created_by?: StringNullableFilter<"CashFlowEntry"> | string | null
    created_at?: DateTimeFilter<"CashFlowEntry"> | Date | string
    updated_at?: DateTimeFilter<"CashFlowEntry"> | Date | string
  }

  export type CashFlowEntryOrderByWithRelationInput = {
    id?: SortOrder
    entry_date?: SortOrder
    description?: SortOrder
    category?: SortOrder
    entry_type?: SortOrder
    amount?: SortOrder
    source?: SortOrder
    marketplace?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CashFlowEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CashFlowEntryWhereInput | CashFlowEntryWhereInput[]
    OR?: CashFlowEntryWhereInput[]
    NOT?: CashFlowEntryWhereInput | CashFlowEntryWhereInput[]
    entry_date?: DateTimeFilter<"CashFlowEntry"> | Date | string
    description?: StringFilter<"CashFlowEntry"> | string
    category?: StringFilter<"CashFlowEntry"> | string
    entry_type?: EnumCashFlowTypeFilter<"CashFlowEntry"> | $Enums.CashFlowType
    amount?: FloatFilter<"CashFlowEntry"> | number
    source?: StringFilter<"CashFlowEntry"> | string
    marketplace?: StringNullableFilter<"CashFlowEntry"> | string | null
    reference?: StringNullableFilter<"CashFlowEntry"> | string | null
    notes?: StringNullableFilter<"CashFlowEntry"> | string | null
    created_by?: StringNullableFilter<"CashFlowEntry"> | string | null
    created_at?: DateTimeFilter<"CashFlowEntry"> | Date | string
    updated_at?: DateTimeFilter<"CashFlowEntry"> | Date | string
  }, "id">

  export type CashFlowEntryOrderByWithAggregationInput = {
    id?: SortOrder
    entry_date?: SortOrder
    description?: SortOrder
    category?: SortOrder
    entry_type?: SortOrder
    amount?: SortOrder
    source?: SortOrder
    marketplace?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CashFlowEntryCountOrderByAggregateInput
    _avg?: CashFlowEntryAvgOrderByAggregateInput
    _max?: CashFlowEntryMaxOrderByAggregateInput
    _min?: CashFlowEntryMinOrderByAggregateInput
    _sum?: CashFlowEntrySumOrderByAggregateInput
  }

  export type CashFlowEntryScalarWhereWithAggregatesInput = {
    AND?: CashFlowEntryScalarWhereWithAggregatesInput | CashFlowEntryScalarWhereWithAggregatesInput[]
    OR?: CashFlowEntryScalarWhereWithAggregatesInput[]
    NOT?: CashFlowEntryScalarWhereWithAggregatesInput | CashFlowEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CashFlowEntry"> | string
    entry_date?: DateTimeWithAggregatesFilter<"CashFlowEntry"> | Date | string
    description?: StringWithAggregatesFilter<"CashFlowEntry"> | string
    category?: StringWithAggregatesFilter<"CashFlowEntry"> | string
    entry_type?: EnumCashFlowTypeWithAggregatesFilter<"CashFlowEntry"> | $Enums.CashFlowType
    amount?: FloatWithAggregatesFilter<"CashFlowEntry"> | number
    source?: StringWithAggregatesFilter<"CashFlowEntry"> | string
    marketplace?: StringNullableWithAggregatesFilter<"CashFlowEntry"> | string | null
    reference?: StringNullableWithAggregatesFilter<"CashFlowEntry"> | string | null
    notes?: StringNullableWithAggregatesFilter<"CashFlowEntry"> | string | null
    created_by?: StringNullableWithAggregatesFilter<"CashFlowEntry"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"CashFlowEntry"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"CashFlowEntry"> | Date | string
  }

  export type DashboardMetricsWhereInput = {
    AND?: DashboardMetricsWhereInput | DashboardMetricsWhereInput[]
    OR?: DashboardMetricsWhereInput[]
    NOT?: DashboardMetricsWhereInput | DashboardMetricsWhereInput[]
    id?: StringFilter<"DashboardMetrics"> | string
    metric_date?: DateTimeFilter<"DashboardMetrics"> | Date | string
    distinct_orders?: IntFilter<"DashboardMetrics"> | number
    total_quantity_sold?: IntFilter<"DashboardMetrics"> | number
    total_revenue?: FloatFilter<"DashboardMetrics"> | number
    total_profit?: FloatFilter<"DashboardMetrics"> | number
    total_hpp?: FloatFilter<"DashboardMetrics"> | number
    profit_margin?: FloatFilter<"DashboardMetrics"> | number
    average_order_value?: FloatFilter<"DashboardMetrics"> | number
    total_sales_records?: IntFilter<"DashboardMetrics"> | number
    today_revenue?: FloatFilter<"DashboardMetrics"> | number
    today_orders?: IntFilter<"DashboardMetrics"> | number
    month_revenue?: FloatFilter<"DashboardMetrics"> | number
    month_orders?: IntFilter<"DashboardMetrics"> | number
    total_products?: IntFilter<"DashboardMetrics"> | number
    low_stock_products?: IntFilter<"DashboardMetrics"> | number
    out_of_stock_products?: IntFilter<"DashboardMetrics"> | number
    total_categories?: IntFilter<"DashboardMetrics"> | number
    total_brands?: IntFilter<"DashboardMetrics"> | number
    calculated_at?: DateTimeFilter<"DashboardMetrics"> | Date | string
  }

  export type DashboardMetricsOrderByWithRelationInput = {
    id?: SortOrder
    metric_date?: SortOrder
    distinct_orders?: SortOrder
    total_quantity_sold?: SortOrder
    total_revenue?: SortOrder
    total_profit?: SortOrder
    total_hpp?: SortOrder
    profit_margin?: SortOrder
    average_order_value?: SortOrder
    total_sales_records?: SortOrder
    today_revenue?: SortOrder
    today_orders?: SortOrder
    month_revenue?: SortOrder
    month_orders?: SortOrder
    total_products?: SortOrder
    low_stock_products?: SortOrder
    out_of_stock_products?: SortOrder
    total_categories?: SortOrder
    total_brands?: SortOrder
    calculated_at?: SortOrder
  }

  export type DashboardMetricsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    metric_date?: Date | string
    AND?: DashboardMetricsWhereInput | DashboardMetricsWhereInput[]
    OR?: DashboardMetricsWhereInput[]
    NOT?: DashboardMetricsWhereInput | DashboardMetricsWhereInput[]
    distinct_orders?: IntFilter<"DashboardMetrics"> | number
    total_quantity_sold?: IntFilter<"DashboardMetrics"> | number
    total_revenue?: FloatFilter<"DashboardMetrics"> | number
    total_profit?: FloatFilter<"DashboardMetrics"> | number
    total_hpp?: FloatFilter<"DashboardMetrics"> | number
    profit_margin?: FloatFilter<"DashboardMetrics"> | number
    average_order_value?: FloatFilter<"DashboardMetrics"> | number
    total_sales_records?: IntFilter<"DashboardMetrics"> | number
    today_revenue?: FloatFilter<"DashboardMetrics"> | number
    today_orders?: IntFilter<"DashboardMetrics"> | number
    month_revenue?: FloatFilter<"DashboardMetrics"> | number
    month_orders?: IntFilter<"DashboardMetrics"> | number
    total_products?: IntFilter<"DashboardMetrics"> | number
    low_stock_products?: IntFilter<"DashboardMetrics"> | number
    out_of_stock_products?: IntFilter<"DashboardMetrics"> | number
    total_categories?: IntFilter<"DashboardMetrics"> | number
    total_brands?: IntFilter<"DashboardMetrics"> | number
    calculated_at?: DateTimeFilter<"DashboardMetrics"> | Date | string
  }, "id" | "metric_date">

  export type DashboardMetricsOrderByWithAggregationInput = {
    id?: SortOrder
    metric_date?: SortOrder
    distinct_orders?: SortOrder
    total_quantity_sold?: SortOrder
    total_revenue?: SortOrder
    total_profit?: SortOrder
    total_hpp?: SortOrder
    profit_margin?: SortOrder
    average_order_value?: SortOrder
    total_sales_records?: SortOrder
    today_revenue?: SortOrder
    today_orders?: SortOrder
    month_revenue?: SortOrder
    month_orders?: SortOrder
    total_products?: SortOrder
    low_stock_products?: SortOrder
    out_of_stock_products?: SortOrder
    total_categories?: SortOrder
    total_brands?: SortOrder
    calculated_at?: SortOrder
    _count?: DashboardMetricsCountOrderByAggregateInput
    _avg?: DashboardMetricsAvgOrderByAggregateInput
    _max?: DashboardMetricsMaxOrderByAggregateInput
    _min?: DashboardMetricsMinOrderByAggregateInput
    _sum?: DashboardMetricsSumOrderByAggregateInput
  }

  export type DashboardMetricsScalarWhereWithAggregatesInput = {
    AND?: DashboardMetricsScalarWhereWithAggregatesInput | DashboardMetricsScalarWhereWithAggregatesInput[]
    OR?: DashboardMetricsScalarWhereWithAggregatesInput[]
    NOT?: DashboardMetricsScalarWhereWithAggregatesInput | DashboardMetricsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DashboardMetrics"> | string
    metric_date?: DateTimeWithAggregatesFilter<"DashboardMetrics"> | Date | string
    distinct_orders?: IntWithAggregatesFilter<"DashboardMetrics"> | number
    total_quantity_sold?: IntWithAggregatesFilter<"DashboardMetrics"> | number
    total_revenue?: FloatWithAggregatesFilter<"DashboardMetrics"> | number
    total_profit?: FloatWithAggregatesFilter<"DashboardMetrics"> | number
    total_hpp?: FloatWithAggregatesFilter<"DashboardMetrics"> | number
    profit_margin?: FloatWithAggregatesFilter<"DashboardMetrics"> | number
    average_order_value?: FloatWithAggregatesFilter<"DashboardMetrics"> | number
    total_sales_records?: IntWithAggregatesFilter<"DashboardMetrics"> | number
    today_revenue?: FloatWithAggregatesFilter<"DashboardMetrics"> | number
    today_orders?: IntWithAggregatesFilter<"DashboardMetrics"> | number
    month_revenue?: FloatWithAggregatesFilter<"DashboardMetrics"> | number
    month_orders?: IntWithAggregatesFilter<"DashboardMetrics"> | number
    total_products?: IntWithAggregatesFilter<"DashboardMetrics"> | number
    low_stock_products?: IntWithAggregatesFilter<"DashboardMetrics"> | number
    out_of_stock_products?: IntWithAggregatesFilter<"DashboardMetrics"> | number
    total_categories?: IntWithAggregatesFilter<"DashboardMetrics"> | number
    total_brands?: IntWithAggregatesFilter<"DashboardMetrics"> | number
    calculated_at?: DateTimeWithAggregatesFilter<"DashboardMetrics"> | Date | string
  }

  export type ImportHistoryWhereInput = {
    AND?: ImportHistoryWhereInput | ImportHistoryWhereInput[]
    OR?: ImportHistoryWhereInput[]
    NOT?: ImportHistoryWhereInput | ImportHistoryWhereInput[]
    id?: StringFilter<"ImportHistory"> | string
    timestamp?: DateTimeFilter<"ImportHistory"> | Date | string
    user_id?: StringNullableFilter<"ImportHistory"> | string | null
    import_type?: StringFilter<"ImportHistory"> | string
    file_name?: StringNullableFilter<"ImportHistory"> | string | null
    file_size?: IntNullableFilter<"ImportHistory"> | number | null
    file_hash?: StringNullableFilter<"ImportHistory"> | string | null
    total_records?: IntFilter<"ImportHistory"> | number
    imported_records?: IntFilter<"ImportHistory"> | number
    failed_records?: IntFilter<"ImportHistory"> | number
    duplicate_records?: IntFilter<"ImportHistory"> | number
    success_rate?: FloatNullableFilter<"ImportHistory"> | number | null
    processing_time_ms?: IntNullableFilter<"ImportHistory"> | number | null
    import_status?: EnumImportHistoryStatusFilter<"ImportHistory"> | $Enums.ImportHistoryStatus
    error_details?: StringNullableFilter<"ImportHistory"> | string | null
    import_summary?: JsonNullableFilter<"ImportHistory">
    metadata?: JsonNullableFilter<"ImportHistory">
    source_ip?: StringNullableFilter<"ImportHistory"> | string | null
    created_at?: DateTimeFilter<"ImportHistory"> | Date | string
    updated_at?: DateTimeFilter<"ImportHistory"> | Date | string
    importMetadata?: ImportMetadataListRelationFilter
  }

  export type ImportHistoryOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    user_id?: SortOrderInput | SortOrder
    import_type?: SortOrder
    file_name?: SortOrderInput | SortOrder
    file_size?: SortOrderInput | SortOrder
    file_hash?: SortOrderInput | SortOrder
    total_records?: SortOrder
    imported_records?: SortOrder
    failed_records?: SortOrder
    duplicate_records?: SortOrder
    success_rate?: SortOrderInput | SortOrder
    processing_time_ms?: SortOrderInput | SortOrder
    import_status?: SortOrder
    error_details?: SortOrderInput | SortOrder
    import_summary?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    source_ip?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    importMetadata?: ImportMetadataOrderByRelationAggregateInput
  }

  export type ImportHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ImportHistoryWhereInput | ImportHistoryWhereInput[]
    OR?: ImportHistoryWhereInput[]
    NOT?: ImportHistoryWhereInput | ImportHistoryWhereInput[]
    timestamp?: DateTimeFilter<"ImportHistory"> | Date | string
    user_id?: StringNullableFilter<"ImportHistory"> | string | null
    import_type?: StringFilter<"ImportHistory"> | string
    file_name?: StringNullableFilter<"ImportHistory"> | string | null
    file_size?: IntNullableFilter<"ImportHistory"> | number | null
    file_hash?: StringNullableFilter<"ImportHistory"> | string | null
    total_records?: IntFilter<"ImportHistory"> | number
    imported_records?: IntFilter<"ImportHistory"> | number
    failed_records?: IntFilter<"ImportHistory"> | number
    duplicate_records?: IntFilter<"ImportHistory"> | number
    success_rate?: FloatNullableFilter<"ImportHistory"> | number | null
    processing_time_ms?: IntNullableFilter<"ImportHistory"> | number | null
    import_status?: EnumImportHistoryStatusFilter<"ImportHistory"> | $Enums.ImportHistoryStatus
    error_details?: StringNullableFilter<"ImportHistory"> | string | null
    import_summary?: JsonNullableFilter<"ImportHistory">
    metadata?: JsonNullableFilter<"ImportHistory">
    source_ip?: StringNullableFilter<"ImportHistory"> | string | null
    created_at?: DateTimeFilter<"ImportHistory"> | Date | string
    updated_at?: DateTimeFilter<"ImportHistory"> | Date | string
    importMetadata?: ImportMetadataListRelationFilter
  }, "id">

  export type ImportHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    user_id?: SortOrderInput | SortOrder
    import_type?: SortOrder
    file_name?: SortOrderInput | SortOrder
    file_size?: SortOrderInput | SortOrder
    file_hash?: SortOrderInput | SortOrder
    total_records?: SortOrder
    imported_records?: SortOrder
    failed_records?: SortOrder
    duplicate_records?: SortOrder
    success_rate?: SortOrderInput | SortOrder
    processing_time_ms?: SortOrderInput | SortOrder
    import_status?: SortOrder
    error_details?: SortOrderInput | SortOrder
    import_summary?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    source_ip?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ImportHistoryCountOrderByAggregateInput
    _avg?: ImportHistoryAvgOrderByAggregateInput
    _max?: ImportHistoryMaxOrderByAggregateInput
    _min?: ImportHistoryMinOrderByAggregateInput
    _sum?: ImportHistorySumOrderByAggregateInput
  }

  export type ImportHistoryScalarWhereWithAggregatesInput = {
    AND?: ImportHistoryScalarWhereWithAggregatesInput | ImportHistoryScalarWhereWithAggregatesInput[]
    OR?: ImportHistoryScalarWhereWithAggregatesInput[]
    NOT?: ImportHistoryScalarWhereWithAggregatesInput | ImportHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ImportHistory"> | string
    timestamp?: DateTimeWithAggregatesFilter<"ImportHistory"> | Date | string
    user_id?: StringNullableWithAggregatesFilter<"ImportHistory"> | string | null
    import_type?: StringWithAggregatesFilter<"ImportHistory"> | string
    file_name?: StringNullableWithAggregatesFilter<"ImportHistory"> | string | null
    file_size?: IntNullableWithAggregatesFilter<"ImportHistory"> | number | null
    file_hash?: StringNullableWithAggregatesFilter<"ImportHistory"> | string | null
    total_records?: IntWithAggregatesFilter<"ImportHistory"> | number
    imported_records?: IntWithAggregatesFilter<"ImportHistory"> | number
    failed_records?: IntWithAggregatesFilter<"ImportHistory"> | number
    duplicate_records?: IntWithAggregatesFilter<"ImportHistory"> | number
    success_rate?: FloatNullableWithAggregatesFilter<"ImportHistory"> | number | null
    processing_time_ms?: IntNullableWithAggregatesFilter<"ImportHistory"> | number | null
    import_status?: EnumImportHistoryStatusWithAggregatesFilter<"ImportHistory"> | $Enums.ImportHistoryStatus
    error_details?: StringNullableWithAggregatesFilter<"ImportHistory"> | string | null
    import_summary?: JsonNullableWithAggregatesFilter<"ImportHistory">
    metadata?: JsonNullableWithAggregatesFilter<"ImportHistory">
    source_ip?: StringNullableWithAggregatesFilter<"ImportHistory"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"ImportHistory"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ImportHistory"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    invoice_number?: StringFilter<"Invoice"> | string
    customer_name?: StringFilter<"Invoice"> | string
    customer_email?: StringFilter<"Invoice"> | string
    customer_phone?: StringNullableFilter<"Invoice"> | string | null
    issue_date?: DateTimeFilter<"Invoice"> | Date | string
    due_date?: DateTimeFilter<"Invoice"> | Date | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    type?: EnumInvoiceTypeFilter<"Invoice"> | $Enums.InvoiceType
    subtotal?: FloatFilter<"Invoice"> | number
    tax?: FloatFilter<"Invoice"> | number
    discount?: FloatFilter<"Invoice"> | number
    total?: FloatFilter<"Invoice"> | number
    notes?: StringNullableFilter<"Invoice"> | string | null
    payment_method?: StringNullableFilter<"Invoice"> | string | null
    payment_date?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    created_at?: DateTimeFilter<"Invoice"> | Date | string
    updated_at?: DateTimeFilter<"Invoice"> | Date | string
    created_by?: StringNullableFilter<"Invoice"> | string | null
    items?: InvoiceItemListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    invoice_number?: SortOrder
    customer_name?: SortOrder
    customer_email?: SortOrder
    customer_phone?: SortOrderInput | SortOrder
    issue_date?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    type?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    notes?: SortOrderInput | SortOrder
    payment_method?: SortOrderInput | SortOrder
    payment_date?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrderInput | SortOrder
    items?: InvoiceItemOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoice_number?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    customer_name?: StringFilter<"Invoice"> | string
    customer_email?: StringFilter<"Invoice"> | string
    customer_phone?: StringNullableFilter<"Invoice"> | string | null
    issue_date?: DateTimeFilter<"Invoice"> | Date | string
    due_date?: DateTimeFilter<"Invoice"> | Date | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    type?: EnumInvoiceTypeFilter<"Invoice"> | $Enums.InvoiceType
    subtotal?: FloatFilter<"Invoice"> | number
    tax?: FloatFilter<"Invoice"> | number
    discount?: FloatFilter<"Invoice"> | number
    total?: FloatFilter<"Invoice"> | number
    notes?: StringNullableFilter<"Invoice"> | string | null
    payment_method?: StringNullableFilter<"Invoice"> | string | null
    payment_date?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    created_at?: DateTimeFilter<"Invoice"> | Date | string
    updated_at?: DateTimeFilter<"Invoice"> | Date | string
    created_by?: StringNullableFilter<"Invoice"> | string | null
    items?: InvoiceItemListRelationFilter
  }, "id" | "invoice_number">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoice_number?: SortOrder
    customer_name?: SortOrder
    customer_email?: SortOrder
    customer_phone?: SortOrderInput | SortOrder
    issue_date?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    type?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    notes?: SortOrderInput | SortOrder
    payment_method?: SortOrderInput | SortOrder
    payment_date?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrderInput | SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    invoice_number?: StringWithAggregatesFilter<"Invoice"> | string
    customer_name?: StringWithAggregatesFilter<"Invoice"> | string
    customer_email?: StringWithAggregatesFilter<"Invoice"> | string
    customer_phone?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    issue_date?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    due_date?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    status?: EnumInvoiceStatusWithAggregatesFilter<"Invoice"> | $Enums.InvoiceStatus
    type?: EnumInvoiceTypeWithAggregatesFilter<"Invoice"> | $Enums.InvoiceType
    subtotal?: FloatWithAggregatesFilter<"Invoice"> | number
    tax?: FloatWithAggregatesFilter<"Invoice"> | number
    discount?: FloatWithAggregatesFilter<"Invoice"> | number
    total?: FloatWithAggregatesFilter<"Invoice"> | number
    notes?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    payment_method?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    payment_date?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    created_by?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
  }

  export type InvoiceItemWhereInput = {
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    id?: StringFilter<"InvoiceItem"> | string
    invoice_id?: StringFilter<"InvoiceItem"> | string
    product_name?: StringFilter<"InvoiceItem"> | string
    quantity?: IntFilter<"InvoiceItem"> | number
    unit_price?: FloatFilter<"InvoiceItem"> | number
    total?: FloatFilter<"InvoiceItem"> | number
    created_at?: DateTimeFilter<"InvoiceItem"> | Date | string
    updated_at?: DateTimeFilter<"InvoiceItem"> | Date | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }

  export type InvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    product_name?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type InvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    invoice_id?: StringFilter<"InvoiceItem"> | string
    product_name?: StringFilter<"InvoiceItem"> | string
    quantity?: IntFilter<"InvoiceItem"> | number
    unit_price?: FloatFilter<"InvoiceItem"> | number
    total?: FloatFilter<"InvoiceItem"> | number
    created_at?: DateTimeFilter<"InvoiceItem"> | Date | string
    updated_at?: DateTimeFilter<"InvoiceItem"> | Date | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }, "id">

  export type InvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    product_name?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: InvoiceItemCountOrderByAggregateInput
    _avg?: InvoiceItemAvgOrderByAggregateInput
    _max?: InvoiceItemMaxOrderByAggregateInput
    _min?: InvoiceItemMinOrderByAggregateInput
    _sum?: InvoiceItemSumOrderByAggregateInput
  }

  export type InvoiceItemScalarWhereWithAggregatesInput = {
    AND?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    OR?: InvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvoiceItem"> | string
    invoice_id?: StringWithAggregatesFilter<"InvoiceItem"> | string
    product_name?: StringWithAggregatesFilter<"InvoiceItem"> | string
    quantity?: IntWithAggregatesFilter<"InvoiceItem"> | number
    unit_price?: FloatWithAggregatesFilter<"InvoiceItem"> | number
    total?: FloatWithAggregatesFilter<"InvoiceItem"> | number
    created_at?: DateTimeWithAggregatesFilter<"InvoiceItem"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"InvoiceItem"> | Date | string
  }

  export type AffiliateEndorsementWhereInput = {
    AND?: AffiliateEndorsementWhereInput | AffiliateEndorsementWhereInput[]
    OR?: AffiliateEndorsementWhereInput[]
    NOT?: AffiliateEndorsementWhereInput | AffiliateEndorsementWhereInput[]
    id?: StringFilter<"AffiliateEndorsement"> | string
    campaign_name?: StringFilter<"AffiliateEndorsement"> | string
    affiliate_name?: StringFilter<"AffiliateEndorsement"> | string
    affiliate_type?: StringFilter<"AffiliateEndorsement"> | string
    start_date?: DateTimeFilter<"AffiliateEndorsement"> | Date | string
    end_date?: DateTimeFilter<"AffiliateEndorsement"> | Date | string
    endorse_fee?: FloatFilter<"AffiliateEndorsement"> | number
    target_sales?: FloatFilter<"AffiliateEndorsement"> | number
    actual_sales?: FloatFilter<"AffiliateEndorsement"> | number
    total_commission?: FloatFilter<"AffiliateEndorsement"> | number
    payment_method?: StringNullableFilter<"AffiliateEndorsement"> | string | null
    platform?: StringNullableListFilter<"AffiliateEndorsement">
    content_type?: StringNullableFilter<"AffiliateEndorsement"> | string | null
    followers?: IntNullableFilter<"AffiliateEndorsement"> | number | null
    engagement?: FloatNullableFilter<"AffiliateEndorsement"> | number | null
    reference?: StringNullableFilter<"AffiliateEndorsement"> | string | null
    notes?: StringNullableFilter<"AffiliateEndorsement"> | string | null
    status?: StringFilter<"AffiliateEndorsement"> | string
    roi?: FloatNullableFilter<"AffiliateEndorsement"> | number | null
    created_by?: StringNullableFilter<"AffiliateEndorsement"> | string | null
    created_at?: DateTimeFilter<"AffiliateEndorsement"> | Date | string
    updated_at?: DateTimeFilter<"AffiliateEndorsement"> | Date | string
    product_sales?: AffiliateProductSaleListRelationFilter
  }

  export type AffiliateEndorsementOrderByWithRelationInput = {
    id?: SortOrder
    campaign_name?: SortOrder
    affiliate_name?: SortOrder
    affiliate_type?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    endorse_fee?: SortOrder
    target_sales?: SortOrder
    actual_sales?: SortOrder
    total_commission?: SortOrder
    payment_method?: SortOrderInput | SortOrder
    platform?: SortOrder
    content_type?: SortOrderInput | SortOrder
    followers?: SortOrderInput | SortOrder
    engagement?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    roi?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    product_sales?: AffiliateProductSaleOrderByRelationAggregateInput
  }

  export type AffiliateEndorsementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AffiliateEndorsementWhereInput | AffiliateEndorsementWhereInput[]
    OR?: AffiliateEndorsementWhereInput[]
    NOT?: AffiliateEndorsementWhereInput | AffiliateEndorsementWhereInput[]
    campaign_name?: StringFilter<"AffiliateEndorsement"> | string
    affiliate_name?: StringFilter<"AffiliateEndorsement"> | string
    affiliate_type?: StringFilter<"AffiliateEndorsement"> | string
    start_date?: DateTimeFilter<"AffiliateEndorsement"> | Date | string
    end_date?: DateTimeFilter<"AffiliateEndorsement"> | Date | string
    endorse_fee?: FloatFilter<"AffiliateEndorsement"> | number
    target_sales?: FloatFilter<"AffiliateEndorsement"> | number
    actual_sales?: FloatFilter<"AffiliateEndorsement"> | number
    total_commission?: FloatFilter<"AffiliateEndorsement"> | number
    payment_method?: StringNullableFilter<"AffiliateEndorsement"> | string | null
    platform?: StringNullableListFilter<"AffiliateEndorsement">
    content_type?: StringNullableFilter<"AffiliateEndorsement"> | string | null
    followers?: IntNullableFilter<"AffiliateEndorsement"> | number | null
    engagement?: FloatNullableFilter<"AffiliateEndorsement"> | number | null
    reference?: StringNullableFilter<"AffiliateEndorsement"> | string | null
    notes?: StringNullableFilter<"AffiliateEndorsement"> | string | null
    status?: StringFilter<"AffiliateEndorsement"> | string
    roi?: FloatNullableFilter<"AffiliateEndorsement"> | number | null
    created_by?: StringNullableFilter<"AffiliateEndorsement"> | string | null
    created_at?: DateTimeFilter<"AffiliateEndorsement"> | Date | string
    updated_at?: DateTimeFilter<"AffiliateEndorsement"> | Date | string
    product_sales?: AffiliateProductSaleListRelationFilter
  }, "id">

  export type AffiliateEndorsementOrderByWithAggregationInput = {
    id?: SortOrder
    campaign_name?: SortOrder
    affiliate_name?: SortOrder
    affiliate_type?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    endorse_fee?: SortOrder
    target_sales?: SortOrder
    actual_sales?: SortOrder
    total_commission?: SortOrder
    payment_method?: SortOrderInput | SortOrder
    platform?: SortOrder
    content_type?: SortOrderInput | SortOrder
    followers?: SortOrderInput | SortOrder
    engagement?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    roi?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: AffiliateEndorsementCountOrderByAggregateInput
    _avg?: AffiliateEndorsementAvgOrderByAggregateInput
    _max?: AffiliateEndorsementMaxOrderByAggregateInput
    _min?: AffiliateEndorsementMinOrderByAggregateInput
    _sum?: AffiliateEndorsementSumOrderByAggregateInput
  }

  export type AffiliateEndorsementScalarWhereWithAggregatesInput = {
    AND?: AffiliateEndorsementScalarWhereWithAggregatesInput | AffiliateEndorsementScalarWhereWithAggregatesInput[]
    OR?: AffiliateEndorsementScalarWhereWithAggregatesInput[]
    NOT?: AffiliateEndorsementScalarWhereWithAggregatesInput | AffiliateEndorsementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AffiliateEndorsement"> | string
    campaign_name?: StringWithAggregatesFilter<"AffiliateEndorsement"> | string
    affiliate_name?: StringWithAggregatesFilter<"AffiliateEndorsement"> | string
    affiliate_type?: StringWithAggregatesFilter<"AffiliateEndorsement"> | string
    start_date?: DateTimeWithAggregatesFilter<"AffiliateEndorsement"> | Date | string
    end_date?: DateTimeWithAggregatesFilter<"AffiliateEndorsement"> | Date | string
    endorse_fee?: FloatWithAggregatesFilter<"AffiliateEndorsement"> | number
    target_sales?: FloatWithAggregatesFilter<"AffiliateEndorsement"> | number
    actual_sales?: FloatWithAggregatesFilter<"AffiliateEndorsement"> | number
    total_commission?: FloatWithAggregatesFilter<"AffiliateEndorsement"> | number
    payment_method?: StringNullableWithAggregatesFilter<"AffiliateEndorsement"> | string | null
    platform?: StringNullableListFilter<"AffiliateEndorsement">
    content_type?: StringNullableWithAggregatesFilter<"AffiliateEndorsement"> | string | null
    followers?: IntNullableWithAggregatesFilter<"AffiliateEndorsement"> | number | null
    engagement?: FloatNullableWithAggregatesFilter<"AffiliateEndorsement"> | number | null
    reference?: StringNullableWithAggregatesFilter<"AffiliateEndorsement"> | string | null
    notes?: StringNullableWithAggregatesFilter<"AffiliateEndorsement"> | string | null
    status?: StringWithAggregatesFilter<"AffiliateEndorsement"> | string
    roi?: FloatNullableWithAggregatesFilter<"AffiliateEndorsement"> | number | null
    created_by?: StringNullableWithAggregatesFilter<"AffiliateEndorsement"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"AffiliateEndorsement"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"AffiliateEndorsement"> | Date | string
  }

  export type AffiliateProductSaleWhereInput = {
    AND?: AffiliateProductSaleWhereInput | AffiliateProductSaleWhereInput[]
    OR?: AffiliateProductSaleWhereInput[]
    NOT?: AffiliateProductSaleWhereInput | AffiliateProductSaleWhereInput[]
    id?: StringFilter<"AffiliateProductSale"> | string
    endorsement_id?: StringFilter<"AffiliateProductSale"> | string
    product_name?: StringFilter<"AffiliateProductSale"> | string
    quantity?: IntFilter<"AffiliateProductSale"> | number
    unit_price?: FloatFilter<"AffiliateProductSale"> | number
    total_sales?: FloatFilter<"AffiliateProductSale"> | number
    commission?: FloatFilter<"AffiliateProductSale"> | number
    created_at?: DateTimeFilter<"AffiliateProductSale"> | Date | string
    updated_at?: DateTimeFilter<"AffiliateProductSale"> | Date | string
    endorsement?: XOR<AffiliateEndorsementRelationFilter, AffiliateEndorsementWhereInput>
  }

  export type AffiliateProductSaleOrderByWithRelationInput = {
    id?: SortOrder
    endorsement_id?: SortOrder
    product_name?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total_sales?: SortOrder
    commission?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    endorsement?: AffiliateEndorsementOrderByWithRelationInput
  }

  export type AffiliateProductSaleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    endorsement_id_product_name?: AffiliateProductSaleEndorsement_idProduct_nameCompoundUniqueInput
    AND?: AffiliateProductSaleWhereInput | AffiliateProductSaleWhereInput[]
    OR?: AffiliateProductSaleWhereInput[]
    NOT?: AffiliateProductSaleWhereInput | AffiliateProductSaleWhereInput[]
    endorsement_id?: StringFilter<"AffiliateProductSale"> | string
    product_name?: StringFilter<"AffiliateProductSale"> | string
    quantity?: IntFilter<"AffiliateProductSale"> | number
    unit_price?: FloatFilter<"AffiliateProductSale"> | number
    total_sales?: FloatFilter<"AffiliateProductSale"> | number
    commission?: FloatFilter<"AffiliateProductSale"> | number
    created_at?: DateTimeFilter<"AffiliateProductSale"> | Date | string
    updated_at?: DateTimeFilter<"AffiliateProductSale"> | Date | string
    endorsement?: XOR<AffiliateEndorsementRelationFilter, AffiliateEndorsementWhereInput>
  }, "id" | "endorsement_id_product_name">

  export type AffiliateProductSaleOrderByWithAggregationInput = {
    id?: SortOrder
    endorsement_id?: SortOrder
    product_name?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total_sales?: SortOrder
    commission?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: AffiliateProductSaleCountOrderByAggregateInput
    _avg?: AffiliateProductSaleAvgOrderByAggregateInput
    _max?: AffiliateProductSaleMaxOrderByAggregateInput
    _min?: AffiliateProductSaleMinOrderByAggregateInput
    _sum?: AffiliateProductSaleSumOrderByAggregateInput
  }

  export type AffiliateProductSaleScalarWhereWithAggregatesInput = {
    AND?: AffiliateProductSaleScalarWhereWithAggregatesInput | AffiliateProductSaleScalarWhereWithAggregatesInput[]
    OR?: AffiliateProductSaleScalarWhereWithAggregatesInput[]
    NOT?: AffiliateProductSaleScalarWhereWithAggregatesInput | AffiliateProductSaleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AffiliateProductSale"> | string
    endorsement_id?: StringWithAggregatesFilter<"AffiliateProductSale"> | string
    product_name?: StringWithAggregatesFilter<"AffiliateProductSale"> | string
    quantity?: IntWithAggregatesFilter<"AffiliateProductSale"> | number
    unit_price?: FloatWithAggregatesFilter<"AffiliateProductSale"> | number
    total_sales?: FloatWithAggregatesFilter<"AffiliateProductSale"> | number
    commission?: FloatWithAggregatesFilter<"AffiliateProductSale"> | number
    created_at?: DateTimeWithAggregatesFilter<"AffiliateProductSale"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"AffiliateProductSale"> | Date | string
  }

  export type ActivityLogsWhereInput = {
    AND?: ActivityLogsWhereInput | ActivityLogsWhereInput[]
    OR?: ActivityLogsWhereInput[]
    NOT?: ActivityLogsWhereInput | ActivityLogsWhereInput[]
    id?: StringFilter<"ActivityLogs"> | string
    type?: StringFilter<"ActivityLogs"> | string
    title?: StringFilter<"ActivityLogs"> | string
    description?: StringFilter<"ActivityLogs"> | string
    status?: StringNullableFilter<"ActivityLogs"> | string | null
    metadata?: JsonNullableFilter<"ActivityLogs">
    user_id?: StringNullableFilter<"ActivityLogs"> | string | null
    related_id?: StringNullableFilter<"ActivityLogs"> | string | null
    related_type?: StringNullableFilter<"ActivityLogs"> | string | null
    created_at?: DateTimeFilter<"ActivityLogs"> | Date | string
    updated_at?: DateTimeFilter<"ActivityLogs"> | Date | string
  }

  export type ActivityLogsOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    related_id?: SortOrderInput | SortOrder
    related_type?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ActivityLogsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityLogsWhereInput | ActivityLogsWhereInput[]
    OR?: ActivityLogsWhereInput[]
    NOT?: ActivityLogsWhereInput | ActivityLogsWhereInput[]
    type?: StringFilter<"ActivityLogs"> | string
    title?: StringFilter<"ActivityLogs"> | string
    description?: StringFilter<"ActivityLogs"> | string
    status?: StringNullableFilter<"ActivityLogs"> | string | null
    metadata?: JsonNullableFilter<"ActivityLogs">
    user_id?: StringNullableFilter<"ActivityLogs"> | string | null
    related_id?: StringNullableFilter<"ActivityLogs"> | string | null
    related_type?: StringNullableFilter<"ActivityLogs"> | string | null
    created_at?: DateTimeFilter<"ActivityLogs"> | Date | string
    updated_at?: DateTimeFilter<"ActivityLogs"> | Date | string
  }, "id">

  export type ActivityLogsOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    related_id?: SortOrderInput | SortOrder
    related_type?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ActivityLogsCountOrderByAggregateInput
    _max?: ActivityLogsMaxOrderByAggregateInput
    _min?: ActivityLogsMinOrderByAggregateInput
  }

  export type ActivityLogsScalarWhereWithAggregatesInput = {
    AND?: ActivityLogsScalarWhereWithAggregatesInput | ActivityLogsScalarWhereWithAggregatesInput[]
    OR?: ActivityLogsScalarWhereWithAggregatesInput[]
    NOT?: ActivityLogsScalarWhereWithAggregatesInput | ActivityLogsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActivityLogs"> | string
    type?: StringWithAggregatesFilter<"ActivityLogs"> | string
    title?: StringWithAggregatesFilter<"ActivityLogs"> | string
    description?: StringWithAggregatesFilter<"ActivityLogs"> | string
    status?: StringNullableWithAggregatesFilter<"ActivityLogs"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"ActivityLogs">
    user_id?: StringNullableWithAggregatesFilter<"ActivityLogs"> | string | null
    related_id?: StringNullableWithAggregatesFilter<"ActivityLogs"> | string | null
    related_type?: StringNullableWithAggregatesFilter<"ActivityLogs"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"ActivityLogs"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ActivityLogs"> | Date | string
  }

  export type DuplicateCheckLogsWhereInput = {
    AND?: DuplicateCheckLogsWhereInput | DuplicateCheckLogsWhereInput[]
    OR?: DuplicateCheckLogsWhereInput[]
    NOT?: DuplicateCheckLogsWhereInput | DuplicateCheckLogsWhereInput[]
    id?: StringFilter<"DuplicateCheckLogs"> | string
    file_name?: StringFilter<"DuplicateCheckLogs"> | string
    file_size?: BigIntNullableFilter<"DuplicateCheckLogs"> | bigint | number | null
    file_hash?: StringNullableFilter<"DuplicateCheckLogs"> | string | null
    import_type?: StringFilter<"DuplicateCheckLogs"> | string
    check_result?: JsonNullableFilter<"DuplicateCheckLogs">
    created_at?: DateTimeFilter<"DuplicateCheckLogs"> | Date | string
    updated_at?: DateTimeFilter<"DuplicateCheckLogs"> | Date | string
  }

  export type DuplicateCheckLogsOrderByWithRelationInput = {
    id?: SortOrder
    file_name?: SortOrder
    file_size?: SortOrderInput | SortOrder
    file_hash?: SortOrderInput | SortOrder
    import_type?: SortOrder
    check_result?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DuplicateCheckLogsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DuplicateCheckLogsWhereInput | DuplicateCheckLogsWhereInput[]
    OR?: DuplicateCheckLogsWhereInput[]
    NOT?: DuplicateCheckLogsWhereInput | DuplicateCheckLogsWhereInput[]
    file_name?: StringFilter<"DuplicateCheckLogs"> | string
    file_size?: BigIntNullableFilter<"DuplicateCheckLogs"> | bigint | number | null
    file_hash?: StringNullableFilter<"DuplicateCheckLogs"> | string | null
    import_type?: StringFilter<"DuplicateCheckLogs"> | string
    check_result?: JsonNullableFilter<"DuplicateCheckLogs">
    created_at?: DateTimeFilter<"DuplicateCheckLogs"> | Date | string
    updated_at?: DateTimeFilter<"DuplicateCheckLogs"> | Date | string
  }, "id">

  export type DuplicateCheckLogsOrderByWithAggregationInput = {
    id?: SortOrder
    file_name?: SortOrder
    file_size?: SortOrderInput | SortOrder
    file_hash?: SortOrderInput | SortOrder
    import_type?: SortOrder
    check_result?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: DuplicateCheckLogsCountOrderByAggregateInput
    _avg?: DuplicateCheckLogsAvgOrderByAggregateInput
    _max?: DuplicateCheckLogsMaxOrderByAggregateInput
    _min?: DuplicateCheckLogsMinOrderByAggregateInput
    _sum?: DuplicateCheckLogsSumOrderByAggregateInput
  }

  export type DuplicateCheckLogsScalarWhereWithAggregatesInput = {
    AND?: DuplicateCheckLogsScalarWhereWithAggregatesInput | DuplicateCheckLogsScalarWhereWithAggregatesInput[]
    OR?: DuplicateCheckLogsScalarWhereWithAggregatesInput[]
    NOT?: DuplicateCheckLogsScalarWhereWithAggregatesInput | DuplicateCheckLogsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DuplicateCheckLogs"> | string
    file_name?: StringWithAggregatesFilter<"DuplicateCheckLogs"> | string
    file_size?: BigIntNullableWithAggregatesFilter<"DuplicateCheckLogs"> | bigint | number | null
    file_hash?: StringNullableWithAggregatesFilter<"DuplicateCheckLogs"> | string | null
    import_type?: StringWithAggregatesFilter<"DuplicateCheckLogs"> | string
    check_result?: JsonNullableWithAggregatesFilter<"DuplicateCheckLogs">
    created_at?: DateTimeWithAggregatesFilter<"DuplicateCheckLogs"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"DuplicateCheckLogs"> | Date | string
  }

  export type ImportMetadataWhereInput = {
    AND?: ImportMetadataWhereInput | ImportMetadataWhereInput[]
    OR?: ImportMetadataWhereInput[]
    NOT?: ImportMetadataWhereInput | ImportMetadataWhereInput[]
    id?: StringFilter<"ImportMetadata"> | string
    import_history_id?: StringFilter<"ImportMetadata"> | string
    metadata_type?: StringFilter<"ImportMetadata"> | string
    metadata?: JsonFilter<"ImportMetadata">
    created_at?: DateTimeFilter<"ImportMetadata"> | Date | string
    import_history?: XOR<ImportHistoryRelationFilter, ImportHistoryWhereInput>
  }

  export type ImportMetadataOrderByWithRelationInput = {
    id?: SortOrder
    import_history_id?: SortOrder
    metadata_type?: SortOrder
    metadata?: SortOrder
    created_at?: SortOrder
    import_history?: ImportHistoryOrderByWithRelationInput
  }

  export type ImportMetadataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ImportMetadataWhereInput | ImportMetadataWhereInput[]
    OR?: ImportMetadataWhereInput[]
    NOT?: ImportMetadataWhereInput | ImportMetadataWhereInput[]
    import_history_id?: StringFilter<"ImportMetadata"> | string
    metadata_type?: StringFilter<"ImportMetadata"> | string
    metadata?: JsonFilter<"ImportMetadata">
    created_at?: DateTimeFilter<"ImportMetadata"> | Date | string
    import_history?: XOR<ImportHistoryRelationFilter, ImportHistoryWhereInput>
  }, "id">

  export type ImportMetadataOrderByWithAggregationInput = {
    id?: SortOrder
    import_history_id?: SortOrder
    metadata_type?: SortOrder
    metadata?: SortOrder
    created_at?: SortOrder
    _count?: ImportMetadataCountOrderByAggregateInput
    _max?: ImportMetadataMaxOrderByAggregateInput
    _min?: ImportMetadataMinOrderByAggregateInput
  }

  export type ImportMetadataScalarWhereWithAggregatesInput = {
    AND?: ImportMetadataScalarWhereWithAggregatesInput | ImportMetadataScalarWhereWithAggregatesInput[]
    OR?: ImportMetadataScalarWhereWithAggregatesInput[]
    NOT?: ImportMetadataScalarWhereWithAggregatesInput | ImportMetadataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ImportMetadata"> | string
    import_history_id?: StringWithAggregatesFilter<"ImportMetadata"> | string
    metadata_type?: StringWithAggregatesFilter<"ImportMetadata"> | string
    metadata?: JsonWithAggregatesFilter<"ImportMetadata">
    created_at?: DateTimeWithAggregatesFilter<"ImportMetadata"> | Date | string
  }

  export type TailorWhereInput = {
    AND?: TailorWhereInput | TailorWhereInput[]
    OR?: TailorWhereInput[]
    NOT?: TailorWhereInput | TailorWhereInput[]
    id?: StringFilter<"Tailor"> | string
    code?: StringFilter<"Tailor"> | string
    name?: StringFilter<"Tailor"> | string
    contact_person?: StringFilter<"Tailor"> | string
    phone?: StringFilter<"Tailor"> | string
    email?: StringFilter<"Tailor"> | string
    address?: StringFilter<"Tailor"> | string
    specialization?: StringFilter<"Tailor"> | string
    rating?: FloatFilter<"Tailor"> | number
    status?: EnumTailorStatusFilter<"Tailor"> | $Enums.TailorStatus
    payment_terms?: StringFilter<"Tailor"> | string
    created_at?: DateTimeFilter<"Tailor"> | Date | string
    updated_at?: DateTimeFilter<"Tailor"> | Date | string
    productions?: TailorProductionListRelationFilter
  }

  export type TailorOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    contact_person?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    specialization?: SortOrder
    rating?: SortOrder
    status?: SortOrder
    payment_terms?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    productions?: TailorProductionOrderByRelationAggregateInput
  }

  export type TailorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: TailorWhereInput | TailorWhereInput[]
    OR?: TailorWhereInput[]
    NOT?: TailorWhereInput | TailorWhereInput[]
    name?: StringFilter<"Tailor"> | string
    contact_person?: StringFilter<"Tailor"> | string
    phone?: StringFilter<"Tailor"> | string
    email?: StringFilter<"Tailor"> | string
    address?: StringFilter<"Tailor"> | string
    specialization?: StringFilter<"Tailor"> | string
    rating?: FloatFilter<"Tailor"> | number
    status?: EnumTailorStatusFilter<"Tailor"> | $Enums.TailorStatus
    payment_terms?: StringFilter<"Tailor"> | string
    created_at?: DateTimeFilter<"Tailor"> | Date | string
    updated_at?: DateTimeFilter<"Tailor"> | Date | string
    productions?: TailorProductionListRelationFilter
  }, "id" | "code">

  export type TailorOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    contact_person?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    specialization?: SortOrder
    rating?: SortOrder
    status?: SortOrder
    payment_terms?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: TailorCountOrderByAggregateInput
    _avg?: TailorAvgOrderByAggregateInput
    _max?: TailorMaxOrderByAggregateInput
    _min?: TailorMinOrderByAggregateInput
    _sum?: TailorSumOrderByAggregateInput
  }

  export type TailorScalarWhereWithAggregatesInput = {
    AND?: TailorScalarWhereWithAggregatesInput | TailorScalarWhereWithAggregatesInput[]
    OR?: TailorScalarWhereWithAggregatesInput[]
    NOT?: TailorScalarWhereWithAggregatesInput | TailorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tailor"> | string
    code?: StringWithAggregatesFilter<"Tailor"> | string
    name?: StringWithAggregatesFilter<"Tailor"> | string
    contact_person?: StringWithAggregatesFilter<"Tailor"> | string
    phone?: StringWithAggregatesFilter<"Tailor"> | string
    email?: StringWithAggregatesFilter<"Tailor"> | string
    address?: StringWithAggregatesFilter<"Tailor"> | string
    specialization?: StringWithAggregatesFilter<"Tailor"> | string
    rating?: FloatWithAggregatesFilter<"Tailor"> | number
    status?: EnumTailorStatusWithAggregatesFilter<"Tailor"> | $Enums.TailorStatus
    payment_terms?: StringWithAggregatesFilter<"Tailor"> | string
    created_at?: DateTimeWithAggregatesFilter<"Tailor"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Tailor"> | Date | string
  }

  export type TailorProductionWhereInput = {
    AND?: TailorProductionWhereInput | TailorProductionWhereInput[]
    OR?: TailorProductionWhereInput[]
    NOT?: TailorProductionWhereInput | TailorProductionWhereInput[]
    id?: StringFilter<"TailorProduction"> | string
    tailor_id?: StringFilter<"TailorProduction"> | string
    product_name?: StringFilter<"TailorProduction"> | string
    color?: StringFilter<"TailorProduction"> | string
    size?: StringFilter<"TailorProduction"> | string
    finished_stock?: IntFilter<"TailorProduction"> | number
    meters_needed?: FloatFilter<"TailorProduction"> | number
    cost_per_piece?: FloatFilter<"TailorProduction"> | number
    defective_stock?: IntNullableFilter<"TailorProduction"> | number | null
    additional_costs?: FloatNullableFilter<"TailorProduction"> | number | null
    additional_cost_description?: StringNullableFilter<"TailorProduction"> | string | null
    delivery_date?: DateTimeNullableFilter<"TailorProduction"> | Date | string | null
    notes?: StringNullableFilter<"TailorProduction"> | string | null
    status?: EnumTailorProductionStatusFilter<"TailorProduction"> | $Enums.TailorProductionStatus
    created_at?: DateTimeFilter<"TailorProduction"> | Date | string
    updated_at?: DateTimeFilter<"TailorProduction"> | Date | string
    tailor?: XOR<TailorRelationFilter, TailorWhereInput>
  }

  export type TailorProductionOrderByWithRelationInput = {
    id?: SortOrder
    tailor_id?: SortOrder
    product_name?: SortOrder
    color?: SortOrder
    size?: SortOrder
    finished_stock?: SortOrder
    meters_needed?: SortOrder
    cost_per_piece?: SortOrder
    defective_stock?: SortOrderInput | SortOrder
    additional_costs?: SortOrderInput | SortOrder
    additional_cost_description?: SortOrderInput | SortOrder
    delivery_date?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    tailor?: TailorOrderByWithRelationInput
  }

  export type TailorProductionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TailorProductionWhereInput | TailorProductionWhereInput[]
    OR?: TailorProductionWhereInput[]
    NOT?: TailorProductionWhereInput | TailorProductionWhereInput[]
    tailor_id?: StringFilter<"TailorProduction"> | string
    product_name?: StringFilter<"TailorProduction"> | string
    color?: StringFilter<"TailorProduction"> | string
    size?: StringFilter<"TailorProduction"> | string
    finished_stock?: IntFilter<"TailorProduction"> | number
    meters_needed?: FloatFilter<"TailorProduction"> | number
    cost_per_piece?: FloatFilter<"TailorProduction"> | number
    defective_stock?: IntNullableFilter<"TailorProduction"> | number | null
    additional_costs?: FloatNullableFilter<"TailorProduction"> | number | null
    additional_cost_description?: StringNullableFilter<"TailorProduction"> | string | null
    delivery_date?: DateTimeNullableFilter<"TailorProduction"> | Date | string | null
    notes?: StringNullableFilter<"TailorProduction"> | string | null
    status?: EnumTailorProductionStatusFilter<"TailorProduction"> | $Enums.TailorProductionStatus
    created_at?: DateTimeFilter<"TailorProduction"> | Date | string
    updated_at?: DateTimeFilter<"TailorProduction"> | Date | string
    tailor?: XOR<TailorRelationFilter, TailorWhereInput>
  }, "id">

  export type TailorProductionOrderByWithAggregationInput = {
    id?: SortOrder
    tailor_id?: SortOrder
    product_name?: SortOrder
    color?: SortOrder
    size?: SortOrder
    finished_stock?: SortOrder
    meters_needed?: SortOrder
    cost_per_piece?: SortOrder
    defective_stock?: SortOrderInput | SortOrder
    additional_costs?: SortOrderInput | SortOrder
    additional_cost_description?: SortOrderInput | SortOrder
    delivery_date?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: TailorProductionCountOrderByAggregateInput
    _avg?: TailorProductionAvgOrderByAggregateInput
    _max?: TailorProductionMaxOrderByAggregateInput
    _min?: TailorProductionMinOrderByAggregateInput
    _sum?: TailorProductionSumOrderByAggregateInput
  }

  export type TailorProductionScalarWhereWithAggregatesInput = {
    AND?: TailorProductionScalarWhereWithAggregatesInput | TailorProductionScalarWhereWithAggregatesInput[]
    OR?: TailorProductionScalarWhereWithAggregatesInput[]
    NOT?: TailorProductionScalarWhereWithAggregatesInput | TailorProductionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TailorProduction"> | string
    tailor_id?: StringWithAggregatesFilter<"TailorProduction"> | string
    product_name?: StringWithAggregatesFilter<"TailorProduction"> | string
    color?: StringWithAggregatesFilter<"TailorProduction"> | string
    size?: StringWithAggregatesFilter<"TailorProduction"> | string
    finished_stock?: IntWithAggregatesFilter<"TailorProduction"> | number
    meters_needed?: FloatWithAggregatesFilter<"TailorProduction"> | number
    cost_per_piece?: FloatWithAggregatesFilter<"TailorProduction"> | number
    defective_stock?: IntNullableWithAggregatesFilter<"TailorProduction"> | number | null
    additional_costs?: FloatNullableWithAggregatesFilter<"TailorProduction"> | number | null
    additional_cost_description?: StringNullableWithAggregatesFilter<"TailorProduction"> | string | null
    delivery_date?: DateTimeNullableWithAggregatesFilter<"TailorProduction"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"TailorProduction"> | string | null
    status?: EnumTailorProductionStatusWithAggregatesFilter<"TailorProduction"> | $Enums.TailorProductionStatus
    created_at?: DateTimeWithAggregatesFilter<"TailorProduction"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"TailorProduction"> | Date | string
  }

  export type ProductHPPWhereInput = {
    AND?: ProductHPPWhereInput | ProductHPPWhereInput[]
    OR?: ProductHPPWhereInput[]
    NOT?: ProductHPPWhereInput | ProductHPPWhereInput[]
    id?: StringFilter<"ProductHPP"> | string
    nama_produk?: StringFilter<"ProductHPP"> | string
    size?: StringNullableFilter<"ProductHPP"> | string | null
    hpp?: FloatFilter<"ProductHPP"> | number
    kategori?: StringNullableFilter<"ProductHPP"> | string | null
    deskripsi?: StringNullableFilter<"ProductHPP"> | string | null
    created_at?: DateTimeFilter<"ProductHPP"> | Date | string
    updated_at?: DateTimeFilter<"ProductHPP"> | Date | string
  }

  export type ProductHPPOrderByWithRelationInput = {
    id?: SortOrder
    nama_produk?: SortOrder
    size?: SortOrderInput | SortOrder
    hpp?: SortOrder
    kategori?: SortOrderInput | SortOrder
    deskripsi?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductHPPWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    nama_produk_size?: ProductHPPNama_produkSizeCompoundUniqueInput
    AND?: ProductHPPWhereInput | ProductHPPWhereInput[]
    OR?: ProductHPPWhereInput[]
    NOT?: ProductHPPWhereInput | ProductHPPWhereInput[]
    nama_produk?: StringFilter<"ProductHPP"> | string
    size?: StringNullableFilter<"ProductHPP"> | string | null
    hpp?: FloatFilter<"ProductHPP"> | number
    kategori?: StringNullableFilter<"ProductHPP"> | string | null
    deskripsi?: StringNullableFilter<"ProductHPP"> | string | null
    created_at?: DateTimeFilter<"ProductHPP"> | Date | string
    updated_at?: DateTimeFilter<"ProductHPP"> | Date | string
  }, "id" | "nama_produk_size">

  export type ProductHPPOrderByWithAggregationInput = {
    id?: SortOrder
    nama_produk?: SortOrder
    size?: SortOrderInput | SortOrder
    hpp?: SortOrder
    kategori?: SortOrderInput | SortOrder
    deskripsi?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ProductHPPCountOrderByAggregateInput
    _avg?: ProductHPPAvgOrderByAggregateInput
    _max?: ProductHPPMaxOrderByAggregateInput
    _min?: ProductHPPMinOrderByAggregateInput
    _sum?: ProductHPPSumOrderByAggregateInput
  }

  export type ProductHPPScalarWhereWithAggregatesInput = {
    AND?: ProductHPPScalarWhereWithAggregatesInput | ProductHPPScalarWhereWithAggregatesInput[]
    OR?: ProductHPPScalarWhereWithAggregatesInput[]
    NOT?: ProductHPPScalarWhereWithAggregatesInput | ProductHPPScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductHPP"> | string
    nama_produk?: StringWithAggregatesFilter<"ProductHPP"> | string
    size?: StringNullableWithAggregatesFilter<"ProductHPP"> | string | null
    hpp?: FloatWithAggregatesFilter<"ProductHPP"> | number
    kategori?: StringNullableWithAggregatesFilter<"ProductHPP"> | string | null
    deskripsi?: StringNullableWithAggregatesFilter<"ProductHPP"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"ProductHPP"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"ProductHPP"> | Date | string
  }

  export type SalesDataCreateInput = {
    id?: string
    order_id: string
    seller_sku: string
    product_name: string
    color: string
    size: string
    quantity: number
    order_amount: number
    created_time: Date | string
    delivered_time?: Date | string | null
    settlement_amount?: number | null
    total_revenue?: number | null
    hpp?: number | null
    total?: number | null
    marketplace?: string | null
    customer?: string | null
    province?: string | null
    regency_city?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    import_batch?: ImportBatchCreateNestedOneWithoutSales_dataInput
  }

  export type SalesDataUncheckedCreateInput = {
    id?: string
    order_id: string
    seller_sku: string
    product_name: string
    color: string
    size: string
    quantity: number
    order_amount: number
    created_time: Date | string
    delivered_time?: Date | string | null
    settlement_amount?: number | null
    total_revenue?: number | null
    hpp?: number | null
    total?: number | null
    marketplace?: string | null
    customer?: string | null
    province?: string | null
    regency_city?: string | null
    import_batch_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SalesDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    seller_sku?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    order_amount?: FloatFieldUpdateOperationsInput | number
    created_time?: DateTimeFieldUpdateOperationsInput | Date | string
    delivered_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settlement_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    total_revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    hpp?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    regency_city?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    import_batch?: ImportBatchUpdateOneWithoutSales_dataNestedInput
  }

  export type SalesDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    seller_sku?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    order_amount?: FloatFieldUpdateOperationsInput | number
    created_time?: DateTimeFieldUpdateOperationsInput | Date | string
    delivered_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settlement_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    total_revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    hpp?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    regency_city?: NullableStringFieldUpdateOperationsInput | string | null
    import_batch_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesDataCreateManyInput = {
    id?: string
    order_id: string
    seller_sku: string
    product_name: string
    color: string
    size: string
    quantity: number
    order_amount: number
    created_time: Date | string
    delivered_time?: Date | string | null
    settlement_amount?: number | null
    total_revenue?: number | null
    hpp?: number | null
    total?: number | null
    marketplace?: string | null
    customer?: string | null
    province?: string | null
    regency_city?: string | null
    import_batch_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SalesDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    seller_sku?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    order_amount?: FloatFieldUpdateOperationsInput | number
    created_time?: DateTimeFieldUpdateOperationsInput | Date | string
    delivered_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settlement_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    total_revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    hpp?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    regency_city?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    seller_sku?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    order_amount?: FloatFieldUpdateOperationsInput | number
    created_time?: DateTimeFieldUpdateOperationsInput | Date | string
    delivered_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settlement_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    total_revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    hpp?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    regency_city?: NullableStringFieldUpdateOperationsInput | string | null
    import_batch_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductDataCreateInput = {
    id?: string
    product_code: string
    product_name: string
    category: string
    brand: string
    size: string
    color: string
    price: number
    cost: number
    stock_quantity: number
    min_stock: number
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stock_movements?: StockDataCreateNestedManyWithoutProductInput
    import_batch?: ImportBatchCreateNestedOneWithoutProduct_dataInput
  }

  export type ProductDataUncheckedCreateInput = {
    id?: string
    product_code: string
    product_name: string
    category: string
    brand: string
    size: string
    color: string
    price: number
    cost: number
    stock_quantity: number
    min_stock: number
    description?: string | null
    import_batch_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stock_movements?: StockDataUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_code?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    stock_quantity?: IntFieldUpdateOperationsInput | number
    min_stock?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stock_movements?: StockDataUpdateManyWithoutProductNestedInput
    import_batch?: ImportBatchUpdateOneWithoutProduct_dataNestedInput
  }

  export type ProductDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_code?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    stock_quantity?: IntFieldUpdateOperationsInput | number
    min_stock?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    import_batch_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stock_movements?: StockDataUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductDataCreateManyInput = {
    id?: string
    product_code: string
    product_name: string
    category: string
    brand: string
    size: string
    color: string
    price: number
    cost: number
    stock_quantity: number
    min_stock: number
    description?: string | null
    import_batch_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_code?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    stock_quantity?: IntFieldUpdateOperationsInput | number
    min_stock?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_code?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    stock_quantity?: IntFieldUpdateOperationsInput | number
    min_stock?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    import_batch_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockDataCreateInput = {
    id?: string
    movement_type: $Enums.StockMovementType
    quantity: number
    reference_number?: string | null
    notes?: string | null
    movement_date: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    product?: ProductDataCreateNestedOneWithoutStock_movementsInput
    import_batch?: ImportBatchCreateNestedOneWithoutStock_dataInput
  }

  export type StockDataUncheckedCreateInput = {
    id?: string
    product_code: string
    movement_type: $Enums.StockMovementType
    quantity: number
    reference_number?: string | null
    notes?: string | null
    movement_date: Date | string
    import_batch_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StockDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    movement_type?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movement_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductDataUpdateOneWithoutStock_movementsNestedInput
    import_batch?: ImportBatchUpdateOneWithoutStock_dataNestedInput
  }

  export type StockDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_code?: StringFieldUpdateOperationsInput | string
    movement_type?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movement_date?: DateTimeFieldUpdateOperationsInput | Date | string
    import_batch_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockDataCreateManyInput = {
    id?: string
    product_code: string
    movement_type: $Enums.StockMovementType
    quantity: number
    reference_number?: string | null
    notes?: string | null
    movement_date: Date | string
    import_batch_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StockDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    movement_type?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movement_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_code?: StringFieldUpdateOperationsInput | string
    movement_type?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movement_date?: DateTimeFieldUpdateOperationsInput | Date | string
    import_batch_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportBatchCreateInput = {
    id?: string
    batch_name: string
    import_type: $Enums.ImportType
    file_name: string
    file_type: string
    total_records: number
    valid_records: number
    invalid_records: number
    imported_records: number
    status: $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    sales_data?: SalesDataCreateNestedManyWithoutImport_batchInput
    product_data?: ProductDataCreateNestedManyWithoutImport_batchInput
    stock_data?: StockDataCreateNestedManyWithoutImport_batchInput
    advertising_data?: AdvertisingDataCreateNestedManyWithoutImport_batchInput
    advertising_settlement?: AdvertisingSettlementCreateNestedManyWithoutImport_batchInput
    returns_and_cancellations?: ReturnsAndCancellationsCreateNestedManyWithoutImport_batchInput
    marketplace_reimbursements?: MarketplaceReimbursementCreateNestedManyWithoutImport_batchInput
    commission_adjustments?: CommissionAdjustmentsCreateNestedManyWithoutImport_batchInput
    affiliate_samples?: AffiliateSamplesCreateNestedManyWithoutImport_batchInput
  }

  export type ImportBatchUncheckedCreateInput = {
    id?: string
    batch_name: string
    import_type: $Enums.ImportType
    file_name: string
    file_type: string
    total_records: number
    valid_records: number
    invalid_records: number
    imported_records: number
    status: $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    sales_data?: SalesDataUncheckedCreateNestedManyWithoutImport_batchInput
    product_data?: ProductDataUncheckedCreateNestedManyWithoutImport_batchInput
    stock_data?: StockDataUncheckedCreateNestedManyWithoutImport_batchInput
    advertising_data?: AdvertisingDataUncheckedCreateNestedManyWithoutImport_batchInput
    advertising_settlement?: AdvertisingSettlementUncheckedCreateNestedManyWithoutImport_batchInput
    returns_and_cancellations?: ReturnsAndCancellationsUncheckedCreateNestedManyWithoutImport_batchInput
    marketplace_reimbursements?: MarketplaceReimbursementUncheckedCreateNestedManyWithoutImport_batchInput
    commission_adjustments?: CommissionAdjustmentsUncheckedCreateNestedManyWithoutImport_batchInput
    affiliate_samples?: AffiliateSamplesUncheckedCreateNestedManyWithoutImport_batchInput
  }

  export type ImportBatchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    batch_name?: StringFieldUpdateOperationsInput | string
    import_type?: EnumImportTypeFieldUpdateOperationsInput | $Enums.ImportType
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    total_records?: IntFieldUpdateOperationsInput | number
    valid_records?: IntFieldUpdateOperationsInput | number
    invalid_records?: IntFieldUpdateOperationsInput | number
    imported_records?: IntFieldUpdateOperationsInput | number
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_data?: SalesDataUpdateManyWithoutImport_batchNestedInput
    product_data?: ProductDataUpdateManyWithoutImport_batchNestedInput
    stock_data?: StockDataUpdateManyWithoutImport_batchNestedInput
    advertising_data?: AdvertisingDataUpdateManyWithoutImport_batchNestedInput
    advertising_settlement?: AdvertisingSettlementUpdateManyWithoutImport_batchNestedInput
    returns_and_cancellations?: ReturnsAndCancellationsUpdateManyWithoutImport_batchNestedInput
    marketplace_reimbursements?: MarketplaceReimbursementUpdateManyWithoutImport_batchNestedInput
    commission_adjustments?: CommissionAdjustmentsUpdateManyWithoutImport_batchNestedInput
    affiliate_samples?: AffiliateSamplesUpdateManyWithoutImport_batchNestedInput
  }

  export type ImportBatchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    batch_name?: StringFieldUpdateOperationsInput | string
    import_type?: EnumImportTypeFieldUpdateOperationsInput | $Enums.ImportType
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    total_records?: IntFieldUpdateOperationsInput | number
    valid_records?: IntFieldUpdateOperationsInput | number
    invalid_records?: IntFieldUpdateOperationsInput | number
    imported_records?: IntFieldUpdateOperationsInput | number
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_data?: SalesDataUncheckedUpdateManyWithoutImport_batchNestedInput
    product_data?: ProductDataUncheckedUpdateManyWithoutImport_batchNestedInput
    stock_data?: StockDataUncheckedUpdateManyWithoutImport_batchNestedInput
    advertising_data?: AdvertisingDataUncheckedUpdateManyWithoutImport_batchNestedInput
    advertising_settlement?: AdvertisingSettlementUncheckedUpdateManyWithoutImport_batchNestedInput
    returns_and_cancellations?: ReturnsAndCancellationsUncheckedUpdateManyWithoutImport_batchNestedInput
    marketplace_reimbursements?: MarketplaceReimbursementUncheckedUpdateManyWithoutImport_batchNestedInput
    commission_adjustments?: CommissionAdjustmentsUncheckedUpdateManyWithoutImport_batchNestedInput
    affiliate_samples?: AffiliateSamplesUncheckedUpdateManyWithoutImport_batchNestedInput
  }

  export type ImportBatchCreateManyInput = {
    id?: string
    batch_name: string
    import_type: $Enums.ImportType
    file_name: string
    file_type: string
    total_records: number
    valid_records: number
    invalid_records: number
    imported_records: number
    status: $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ImportBatchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    batch_name?: StringFieldUpdateOperationsInput | string
    import_type?: EnumImportTypeFieldUpdateOperationsInput | $Enums.ImportType
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    total_records?: IntFieldUpdateOperationsInput | number
    valid_records?: IntFieldUpdateOperationsInput | number
    invalid_records?: IntFieldUpdateOperationsInput | number
    imported_records?: IntFieldUpdateOperationsInput | number
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportBatchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    batch_name?: StringFieldUpdateOperationsInput | string
    import_type?: EnumImportTypeFieldUpdateOperationsInput | $Enums.ImportType
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    total_records?: IntFieldUpdateOperationsInput | number
    valid_records?: IntFieldUpdateOperationsInput | number
    invalid_records?: IntFieldUpdateOperationsInput | number
    imported_records?: IntFieldUpdateOperationsInput | number
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvertisingDataCreateInput = {
    id?: string
    campaign_name: string
    ad_creative_type?: string | null
    ad_creative?: string | null
    account_name?: string | null
    cost?: number
    conversions?: number
    cpa?: number | null
    revenue?: number
    roi?: number | null
    impressions?: number
    clicks?: number
    ctr?: number | null
    conversion_rate?: number | null
    date_start: Date | string
    date_end: Date | string
    marketplace?: string | null
    nama_produk?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    import_batch?: ImportBatchCreateNestedOneWithoutAdvertising_dataInput
  }

  export type AdvertisingDataUncheckedCreateInput = {
    id?: string
    campaign_name: string
    ad_creative_type?: string | null
    ad_creative?: string | null
    account_name?: string | null
    cost?: number
    conversions?: number
    cpa?: number | null
    revenue?: number
    roi?: number | null
    impressions?: number
    clicks?: number
    ctr?: number | null
    conversion_rate?: number | null
    date_start: Date | string
    date_end: Date | string
    marketplace?: string | null
    nama_produk?: string | null
    import_batch_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AdvertisingDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaign_name?: StringFieldUpdateOperationsInput | string
    ad_creative_type?: NullableStringFieldUpdateOperationsInput | string | null
    ad_creative?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    cpa?: NullableFloatFieldUpdateOperationsInput | number | null
    revenue?: FloatFieldUpdateOperationsInput | number
    roi?: NullableFloatFieldUpdateOperationsInput | number | null
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    conversion_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    date_start?: DateTimeFieldUpdateOperationsInput | Date | string
    date_end?: DateTimeFieldUpdateOperationsInput | Date | string
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    nama_produk?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    import_batch?: ImportBatchUpdateOneWithoutAdvertising_dataNestedInput
  }

  export type AdvertisingDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaign_name?: StringFieldUpdateOperationsInput | string
    ad_creative_type?: NullableStringFieldUpdateOperationsInput | string | null
    ad_creative?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    cpa?: NullableFloatFieldUpdateOperationsInput | number | null
    revenue?: FloatFieldUpdateOperationsInput | number
    roi?: NullableFloatFieldUpdateOperationsInput | number | null
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    conversion_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    date_start?: DateTimeFieldUpdateOperationsInput | Date | string
    date_end?: DateTimeFieldUpdateOperationsInput | Date | string
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    nama_produk?: NullableStringFieldUpdateOperationsInput | string | null
    import_batch_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvertisingDataCreateManyInput = {
    id?: string
    campaign_name: string
    ad_creative_type?: string | null
    ad_creative?: string | null
    account_name?: string | null
    cost?: number
    conversions?: number
    cpa?: number | null
    revenue?: number
    roi?: number | null
    impressions?: number
    clicks?: number
    ctr?: number | null
    conversion_rate?: number | null
    date_start: Date | string
    date_end: Date | string
    marketplace?: string | null
    nama_produk?: string | null
    import_batch_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AdvertisingDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaign_name?: StringFieldUpdateOperationsInput | string
    ad_creative_type?: NullableStringFieldUpdateOperationsInput | string | null
    ad_creative?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    cpa?: NullableFloatFieldUpdateOperationsInput | number | null
    revenue?: FloatFieldUpdateOperationsInput | number
    roi?: NullableFloatFieldUpdateOperationsInput | number | null
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    conversion_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    date_start?: DateTimeFieldUpdateOperationsInput | Date | string
    date_end?: DateTimeFieldUpdateOperationsInput | Date | string
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    nama_produk?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvertisingDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaign_name?: StringFieldUpdateOperationsInput | string
    ad_creative_type?: NullableStringFieldUpdateOperationsInput | string | null
    ad_creative?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    cpa?: NullableFloatFieldUpdateOperationsInput | number | null
    revenue?: FloatFieldUpdateOperationsInput | number
    roi?: NullableFloatFieldUpdateOperationsInput | number | null
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    conversion_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    date_start?: DateTimeFieldUpdateOperationsInput | Date | string
    date_end?: DateTimeFieldUpdateOperationsInput | Date | string
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    nama_produk?: NullableStringFieldUpdateOperationsInput | string | null
    import_batch_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvertisingSettlementCreateInput = {
    order_id: string
    type?: string | null
    order_created_time: Date | string
    order_settled_time: Date | string
    settlement_amount?: number
    settlement_period?: string | null
    account_name?: string | null
    marketplace?: string | null
    currency?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    import_batch?: ImportBatchCreateNestedOneWithoutAdvertising_settlementInput
  }

  export type AdvertisingSettlementUncheckedCreateInput = {
    order_id: string
    type?: string | null
    order_created_time: Date | string
    order_settled_time: Date | string
    settlement_amount?: number
    settlement_period?: string | null
    account_name?: string | null
    marketplace?: string | null
    currency?: string | null
    import_batch_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AdvertisingSettlementUpdateInput = {
    order_id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    order_created_time?: DateTimeFieldUpdateOperationsInput | Date | string
    order_settled_time?: DateTimeFieldUpdateOperationsInput | Date | string
    settlement_amount?: FloatFieldUpdateOperationsInput | number
    settlement_period?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    import_batch?: ImportBatchUpdateOneWithoutAdvertising_settlementNestedInput
  }

  export type AdvertisingSettlementUncheckedUpdateInput = {
    order_id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    order_created_time?: DateTimeFieldUpdateOperationsInput | Date | string
    order_settled_time?: DateTimeFieldUpdateOperationsInput | Date | string
    settlement_amount?: FloatFieldUpdateOperationsInput | number
    settlement_period?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    import_batch_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvertisingSettlementCreateManyInput = {
    order_id: string
    type?: string | null
    order_created_time: Date | string
    order_settled_time: Date | string
    settlement_amount?: number
    settlement_period?: string | null
    account_name?: string | null
    marketplace?: string | null
    currency?: string | null
    import_batch_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AdvertisingSettlementUpdateManyMutationInput = {
    order_id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    order_created_time?: DateTimeFieldUpdateOperationsInput | Date | string
    order_settled_time?: DateTimeFieldUpdateOperationsInput | Date | string
    settlement_amount?: FloatFieldUpdateOperationsInput | number
    settlement_period?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvertisingSettlementUncheckedUpdateManyInput = {
    order_id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    order_created_time?: DateTimeFieldUpdateOperationsInput | Date | string
    order_settled_time?: DateTimeFieldUpdateOperationsInput | Date | string
    settlement_amount?: FloatFieldUpdateOperationsInput | number
    settlement_period?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    import_batch_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnsAndCancellationsCreateInput = {
    id?: string
    original_order_id?: string | null
    original_sales_id?: string | null
    type: string
    reason?: string | null
    return_date: Date | string
    returned_amount?: number
    refund_amount?: number
    restocking_fee?: number
    shipping_cost_loss?: number
    product_name: string
    quantity_returned?: number
    original_price?: number
    marketplace?: string | null
    product_condition?: string | null
    resellable?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    import_batch?: ImportBatchCreateNestedOneWithoutReturns_and_cancellationsInput
  }

  export type ReturnsAndCancellationsUncheckedCreateInput = {
    id?: string
    original_order_id?: string | null
    original_sales_id?: string | null
    type: string
    reason?: string | null
    return_date: Date | string
    returned_amount?: number
    refund_amount?: number
    restocking_fee?: number
    shipping_cost_loss?: number
    product_name: string
    quantity_returned?: number
    original_price?: number
    marketplace?: string | null
    product_condition?: string | null
    resellable?: boolean
    import_batch_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ReturnsAndCancellationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    original_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    original_sales_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    returned_amount?: FloatFieldUpdateOperationsInput | number
    refund_amount?: FloatFieldUpdateOperationsInput | number
    restocking_fee?: FloatFieldUpdateOperationsInput | number
    shipping_cost_loss?: FloatFieldUpdateOperationsInput | number
    product_name?: StringFieldUpdateOperationsInput | string
    quantity_returned?: IntFieldUpdateOperationsInput | number
    original_price?: FloatFieldUpdateOperationsInput | number
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    product_condition?: NullableStringFieldUpdateOperationsInput | string | null
    resellable?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    import_batch?: ImportBatchUpdateOneWithoutReturns_and_cancellationsNestedInput
  }

  export type ReturnsAndCancellationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    original_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    original_sales_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    returned_amount?: FloatFieldUpdateOperationsInput | number
    refund_amount?: FloatFieldUpdateOperationsInput | number
    restocking_fee?: FloatFieldUpdateOperationsInput | number
    shipping_cost_loss?: FloatFieldUpdateOperationsInput | number
    product_name?: StringFieldUpdateOperationsInput | string
    quantity_returned?: IntFieldUpdateOperationsInput | number
    original_price?: FloatFieldUpdateOperationsInput | number
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    product_condition?: NullableStringFieldUpdateOperationsInput | string | null
    resellable?: BoolFieldUpdateOperationsInput | boolean
    import_batch_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnsAndCancellationsCreateManyInput = {
    id?: string
    original_order_id?: string | null
    original_sales_id?: string | null
    type: string
    reason?: string | null
    return_date: Date | string
    returned_amount?: number
    refund_amount?: number
    restocking_fee?: number
    shipping_cost_loss?: number
    product_name: string
    quantity_returned?: number
    original_price?: number
    marketplace?: string | null
    product_condition?: string | null
    resellable?: boolean
    import_batch_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ReturnsAndCancellationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    original_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    original_sales_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    returned_amount?: FloatFieldUpdateOperationsInput | number
    refund_amount?: FloatFieldUpdateOperationsInput | number
    restocking_fee?: FloatFieldUpdateOperationsInput | number
    shipping_cost_loss?: FloatFieldUpdateOperationsInput | number
    product_name?: StringFieldUpdateOperationsInput | string
    quantity_returned?: IntFieldUpdateOperationsInput | number
    original_price?: FloatFieldUpdateOperationsInput | number
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    product_condition?: NullableStringFieldUpdateOperationsInput | string | null
    resellable?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnsAndCancellationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    original_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    original_sales_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    returned_amount?: FloatFieldUpdateOperationsInput | number
    refund_amount?: FloatFieldUpdateOperationsInput | number
    restocking_fee?: FloatFieldUpdateOperationsInput | number
    shipping_cost_loss?: FloatFieldUpdateOperationsInput | number
    product_name?: StringFieldUpdateOperationsInput | string
    quantity_returned?: IntFieldUpdateOperationsInput | number
    original_price?: FloatFieldUpdateOperationsInput | number
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    product_condition?: NullableStringFieldUpdateOperationsInput | string | null
    resellable?: BoolFieldUpdateOperationsInput | boolean
    import_batch_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceReimbursementCreateInput = {
    id?: string
    claim_id?: string | null
    reimbursement_type: string
    claim_amount?: number
    approved_amount?: number
    received_amount?: number
    processing_fee?: number
    incident_date: Date | string
    claim_date: Date | string
    approval_date?: Date | string | null
    received_date?: Date | string | null
    affected_order_id?: string | null
    product_name?: string | null
    marketplace: string
    status?: string
    notes?: string | null
    evidence_provided?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    import_batch?: ImportBatchCreateNestedOneWithoutMarketplace_reimbursementsInput
  }

  export type MarketplaceReimbursementUncheckedCreateInput = {
    id?: string
    claim_id?: string | null
    reimbursement_type: string
    claim_amount?: number
    approved_amount?: number
    received_amount?: number
    processing_fee?: number
    incident_date: Date | string
    claim_date: Date | string
    approval_date?: Date | string | null
    received_date?: Date | string | null
    affected_order_id?: string | null
    product_name?: string | null
    marketplace: string
    status?: string
    notes?: string | null
    evidence_provided?: string | null
    import_batch_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MarketplaceReimbursementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    claim_id?: NullableStringFieldUpdateOperationsInput | string | null
    reimbursement_type?: StringFieldUpdateOperationsInput | string
    claim_amount?: FloatFieldUpdateOperationsInput | number
    approved_amount?: FloatFieldUpdateOperationsInput | number
    received_amount?: FloatFieldUpdateOperationsInput | number
    processing_fee?: FloatFieldUpdateOperationsInput | number
    incident_date?: DateTimeFieldUpdateOperationsInput | Date | string
    claim_date?: DateTimeFieldUpdateOperationsInput | Date | string
    approval_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    received_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affected_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    marketplace?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    evidence_provided?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    import_batch?: ImportBatchUpdateOneWithoutMarketplace_reimbursementsNestedInput
  }

  export type MarketplaceReimbursementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    claim_id?: NullableStringFieldUpdateOperationsInput | string | null
    reimbursement_type?: StringFieldUpdateOperationsInput | string
    claim_amount?: FloatFieldUpdateOperationsInput | number
    approved_amount?: FloatFieldUpdateOperationsInput | number
    received_amount?: FloatFieldUpdateOperationsInput | number
    processing_fee?: FloatFieldUpdateOperationsInput | number
    incident_date?: DateTimeFieldUpdateOperationsInput | Date | string
    claim_date?: DateTimeFieldUpdateOperationsInput | Date | string
    approval_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    received_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affected_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    marketplace?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    evidence_provided?: NullableStringFieldUpdateOperationsInput | string | null
    import_batch_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceReimbursementCreateManyInput = {
    id?: string
    claim_id?: string | null
    reimbursement_type: string
    claim_amount?: number
    approved_amount?: number
    received_amount?: number
    processing_fee?: number
    incident_date: Date | string
    claim_date: Date | string
    approval_date?: Date | string | null
    received_date?: Date | string | null
    affected_order_id?: string | null
    product_name?: string | null
    marketplace: string
    status?: string
    notes?: string | null
    evidence_provided?: string | null
    import_batch_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MarketplaceReimbursementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    claim_id?: NullableStringFieldUpdateOperationsInput | string | null
    reimbursement_type?: StringFieldUpdateOperationsInput | string
    claim_amount?: FloatFieldUpdateOperationsInput | number
    approved_amount?: FloatFieldUpdateOperationsInput | number
    received_amount?: FloatFieldUpdateOperationsInput | number
    processing_fee?: FloatFieldUpdateOperationsInput | number
    incident_date?: DateTimeFieldUpdateOperationsInput | Date | string
    claim_date?: DateTimeFieldUpdateOperationsInput | Date | string
    approval_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    received_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affected_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    marketplace?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    evidence_provided?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceReimbursementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    claim_id?: NullableStringFieldUpdateOperationsInput | string | null
    reimbursement_type?: StringFieldUpdateOperationsInput | string
    claim_amount?: FloatFieldUpdateOperationsInput | number
    approved_amount?: FloatFieldUpdateOperationsInput | number
    received_amount?: FloatFieldUpdateOperationsInput | number
    processing_fee?: FloatFieldUpdateOperationsInput | number
    incident_date?: DateTimeFieldUpdateOperationsInput | Date | string
    claim_date?: DateTimeFieldUpdateOperationsInput | Date | string
    approval_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    received_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affected_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    marketplace?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    evidence_provided?: NullableStringFieldUpdateOperationsInput | string | null
    import_batch_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionAdjustmentsCreateInput = {
    id?: string
    original_order_id?: string | null
    original_sales_id?: string | null
    adjustment_type: string
    reason?: string | null
    original_commission?: number
    adjustment_amount?: number
    final_commission?: number
    marketplace: string
    commission_rate?: number | null
    dynamic_rate_applied?: boolean
    transaction_date: Date | string
    adjustment_date: Date | string
    product_name?: string | null
    quantity?: number
    product_price?: number
    created_at?: Date | string
    updated_at?: Date | string
    import_batch?: ImportBatchCreateNestedOneWithoutCommission_adjustmentsInput
  }

  export type CommissionAdjustmentsUncheckedCreateInput = {
    id?: string
    original_order_id?: string | null
    original_sales_id?: string | null
    adjustment_type: string
    reason?: string | null
    original_commission?: number
    adjustment_amount?: number
    final_commission?: number
    marketplace: string
    commission_rate?: number | null
    dynamic_rate_applied?: boolean
    transaction_date: Date | string
    adjustment_date: Date | string
    product_name?: string | null
    quantity?: number
    product_price?: number
    import_batch_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CommissionAdjustmentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    original_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    original_sales_id?: NullableStringFieldUpdateOperationsInput | string | null
    adjustment_type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    original_commission?: FloatFieldUpdateOperationsInput | number
    adjustment_amount?: FloatFieldUpdateOperationsInput | number
    final_commission?: FloatFieldUpdateOperationsInput | number
    marketplace?: StringFieldUpdateOperationsInput | string
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    dynamic_rate_applied?: BoolFieldUpdateOperationsInput | boolean
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    adjustment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    product_price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    import_batch?: ImportBatchUpdateOneWithoutCommission_adjustmentsNestedInput
  }

  export type CommissionAdjustmentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    original_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    original_sales_id?: NullableStringFieldUpdateOperationsInput | string | null
    adjustment_type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    original_commission?: FloatFieldUpdateOperationsInput | number
    adjustment_amount?: FloatFieldUpdateOperationsInput | number
    final_commission?: FloatFieldUpdateOperationsInput | number
    marketplace?: StringFieldUpdateOperationsInput | string
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    dynamic_rate_applied?: BoolFieldUpdateOperationsInput | boolean
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    adjustment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    product_price?: FloatFieldUpdateOperationsInput | number
    import_batch_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionAdjustmentsCreateManyInput = {
    id?: string
    original_order_id?: string | null
    original_sales_id?: string | null
    adjustment_type: string
    reason?: string | null
    original_commission?: number
    adjustment_amount?: number
    final_commission?: number
    marketplace: string
    commission_rate?: number | null
    dynamic_rate_applied?: boolean
    transaction_date: Date | string
    adjustment_date: Date | string
    product_name?: string | null
    quantity?: number
    product_price?: number
    import_batch_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CommissionAdjustmentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    original_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    original_sales_id?: NullableStringFieldUpdateOperationsInput | string | null
    adjustment_type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    original_commission?: FloatFieldUpdateOperationsInput | number
    adjustment_amount?: FloatFieldUpdateOperationsInput | number
    final_commission?: FloatFieldUpdateOperationsInput | number
    marketplace?: StringFieldUpdateOperationsInput | string
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    dynamic_rate_applied?: BoolFieldUpdateOperationsInput | boolean
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    adjustment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    product_price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionAdjustmentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    original_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    original_sales_id?: NullableStringFieldUpdateOperationsInput | string | null
    adjustment_type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    original_commission?: FloatFieldUpdateOperationsInput | number
    adjustment_amount?: FloatFieldUpdateOperationsInput | number
    final_commission?: FloatFieldUpdateOperationsInput | number
    marketplace?: StringFieldUpdateOperationsInput | string
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    dynamic_rate_applied?: BoolFieldUpdateOperationsInput | boolean
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    adjustment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    product_price?: FloatFieldUpdateOperationsInput | number
    import_batch_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateSamplesCreateInput = {
    id?: string
    affiliate_name: string
    affiliate_platform?: string | null
    affiliate_contact?: string | null
    product_name: string
    product_sku?: string | null
    quantity_given?: number
    product_cost?: number
    total_cost?: number
    shipping_cost?: number
    packaging_cost?: number
    campaign_name?: string | null
    expected_reach?: number | null
    content_type?: string | null
    given_date: Date | string
    expected_content_date?: Date | string | null
    actual_content_date?: Date | string | null
    content_delivered?: boolean
    performance_notes?: string | null
    roi_estimate?: number | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    import_batch?: ImportBatchCreateNestedOneWithoutAffiliate_samplesInput
  }

  export type AffiliateSamplesUncheckedCreateInput = {
    id?: string
    affiliate_name: string
    affiliate_platform?: string | null
    affiliate_contact?: string | null
    product_name: string
    product_sku?: string | null
    quantity_given?: number
    product_cost?: number
    total_cost?: number
    shipping_cost?: number
    packaging_cost?: number
    campaign_name?: string | null
    expected_reach?: number | null
    content_type?: string | null
    given_date: Date | string
    expected_content_date?: Date | string | null
    actual_content_date?: Date | string | null
    content_delivered?: boolean
    performance_notes?: string | null
    roi_estimate?: number | null
    status?: string
    import_batch_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AffiliateSamplesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliate_name?: StringFieldUpdateOperationsInput | string
    affiliate_platform?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_contact?: NullableStringFieldUpdateOperationsInput | string | null
    product_name?: StringFieldUpdateOperationsInput | string
    product_sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity_given?: IntFieldUpdateOperationsInput | number
    product_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    shipping_cost?: FloatFieldUpdateOperationsInput | number
    packaging_cost?: FloatFieldUpdateOperationsInput | number
    campaign_name?: NullableStringFieldUpdateOperationsInput | string | null
    expected_reach?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    given_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expected_content_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_content_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content_delivered?: BoolFieldUpdateOperationsInput | boolean
    performance_notes?: NullableStringFieldUpdateOperationsInput | string | null
    roi_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    import_batch?: ImportBatchUpdateOneWithoutAffiliate_samplesNestedInput
  }

  export type AffiliateSamplesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliate_name?: StringFieldUpdateOperationsInput | string
    affiliate_platform?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_contact?: NullableStringFieldUpdateOperationsInput | string | null
    product_name?: StringFieldUpdateOperationsInput | string
    product_sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity_given?: IntFieldUpdateOperationsInput | number
    product_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    shipping_cost?: FloatFieldUpdateOperationsInput | number
    packaging_cost?: FloatFieldUpdateOperationsInput | number
    campaign_name?: NullableStringFieldUpdateOperationsInput | string | null
    expected_reach?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    given_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expected_content_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_content_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content_delivered?: BoolFieldUpdateOperationsInput | boolean
    performance_notes?: NullableStringFieldUpdateOperationsInput | string | null
    roi_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    import_batch_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateSamplesCreateManyInput = {
    id?: string
    affiliate_name: string
    affiliate_platform?: string | null
    affiliate_contact?: string | null
    product_name: string
    product_sku?: string | null
    quantity_given?: number
    product_cost?: number
    total_cost?: number
    shipping_cost?: number
    packaging_cost?: number
    campaign_name?: string | null
    expected_reach?: number | null
    content_type?: string | null
    given_date: Date | string
    expected_content_date?: Date | string | null
    actual_content_date?: Date | string | null
    content_delivered?: boolean
    performance_notes?: string | null
    roi_estimate?: number | null
    status?: string
    import_batch_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AffiliateSamplesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliate_name?: StringFieldUpdateOperationsInput | string
    affiliate_platform?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_contact?: NullableStringFieldUpdateOperationsInput | string | null
    product_name?: StringFieldUpdateOperationsInput | string
    product_sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity_given?: IntFieldUpdateOperationsInput | number
    product_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    shipping_cost?: FloatFieldUpdateOperationsInput | number
    packaging_cost?: FloatFieldUpdateOperationsInput | number
    campaign_name?: NullableStringFieldUpdateOperationsInput | string | null
    expected_reach?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    given_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expected_content_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_content_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content_delivered?: BoolFieldUpdateOperationsInput | boolean
    performance_notes?: NullableStringFieldUpdateOperationsInput | string | null
    roi_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateSamplesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliate_name?: StringFieldUpdateOperationsInput | string
    affiliate_platform?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_contact?: NullableStringFieldUpdateOperationsInput | string | null
    product_name?: StringFieldUpdateOperationsInput | string
    product_sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity_given?: IntFieldUpdateOperationsInput | number
    product_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    shipping_cost?: FloatFieldUpdateOperationsInput | number
    packaging_cost?: FloatFieldUpdateOperationsInput | number
    campaign_name?: NullableStringFieldUpdateOperationsInput | string | null
    expected_reach?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    given_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expected_content_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_content_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content_delivered?: BoolFieldUpdateOperationsInput | boolean
    performance_notes?: NullableStringFieldUpdateOperationsInput | string | null
    roi_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    import_batch_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrandCreateInput = {
    id?: string
    name: string
    description?: string | null
    website?: string | null
    logo_color?: string | null
    is_premium?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BrandUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    website?: string | null
    logo_color?: string | null
    is_premium?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BrandUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo_color?: NullableStringFieldUpdateOperationsInput | string | null
    is_premium?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrandUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo_color?: NullableStringFieldUpdateOperationsInput | string | null
    is_premium?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrandCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    website?: string | null
    logo_color?: string | null
    is_premium?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BrandUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo_color?: NullableStringFieldUpdateOperationsInput | string | null
    is_premium?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrandUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo_color?: NullableStringFieldUpdateOperationsInput | string | null
    is_premium?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierCreateInput = {
    id?: string
    code: string
    name: string
    contact_person: string
    phone: string
    email: string
    address: string
    category: string
    rating?: number
    status?: $Enums.SupplierStatus
    payment_terms: string
    created_at?: Date | string
    updated_at?: Date | string
    purchase_orders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    contact_person: string
    phone: string
    email: string
    address: string
    category: string
    rating?: number
    status?: $Enums.SupplierStatus
    payment_terms: string
    created_at?: Date | string
    updated_at?: Date | string
    purchase_orders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    status?: EnumSupplierStatusFieldUpdateOperationsInput | $Enums.SupplierStatus
    payment_terms?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase_orders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    status?: EnumSupplierStatusFieldUpdateOperationsInput | $Enums.SupplierStatus
    payment_terms?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase_orders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierCreateManyInput = {
    id?: string
    code: string
    name: string
    contact_person: string
    phone: string
    email: string
    address: string
    category: string
    rating?: number
    status?: $Enums.SupplierStatus
    payment_terms: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SupplierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    status?: EnumSupplierStatusFieldUpdateOperationsInput | $Enums.SupplierStatus
    payment_terms?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    status?: EnumSupplierStatusFieldUpdateOperationsInput | $Enums.SupplierStatus
    payment_terms?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderCreateInput = {
    id?: string
    po_number: string
    po_date: Date | string
    expected_date: Date | string
    delivery_date?: Date | string | null
    status?: $Enums.POStatus
    total_amount?: number
    items_count?: number
    notes?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    supplier: SupplierCreateNestedOneWithoutPurchase_ordersInput
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchase_orderInput
  }

  export type PurchaseOrderUncheckedCreateInput = {
    id?: string
    po_number: string
    supplier_id: string
    po_date: Date | string
    expected_date: Date | string
    delivery_date?: Date | string | null
    status?: $Enums.POStatus
    total_amount?: number
    items_count?: number
    notes?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchase_orderInput
  }

  export type PurchaseOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    po_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expected_date?: DateTimeFieldUpdateOperationsInput | Date | string
    delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPOStatusFieldUpdateOperationsInput | $Enums.POStatus
    total_amount?: FloatFieldUpdateOperationsInput | number
    items_count?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutPurchase_ordersNestedInput
    items?: PurchaseOrderItemUpdateManyWithoutPurchase_orderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    supplier_id?: StringFieldUpdateOperationsInput | string
    po_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expected_date?: DateTimeFieldUpdateOperationsInput | Date | string
    delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPOStatusFieldUpdateOperationsInput | $Enums.POStatus
    total_amount?: FloatFieldUpdateOperationsInput | number
    items_count?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchase_orderNestedInput
  }

  export type PurchaseOrderCreateManyInput = {
    id?: string
    po_number: string
    supplier_id: string
    po_date: Date | string
    expected_date: Date | string
    delivery_date?: Date | string | null
    status?: $Enums.POStatus
    total_amount?: number
    items_count?: number
    notes?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PurchaseOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    po_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expected_date?: DateTimeFieldUpdateOperationsInput | Date | string
    delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPOStatusFieldUpdateOperationsInput | $Enums.POStatus
    total_amount?: FloatFieldUpdateOperationsInput | number
    items_count?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    supplier_id?: StringFieldUpdateOperationsInput | string
    po_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expected_date?: DateTimeFieldUpdateOperationsInput | Date | string
    delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPOStatusFieldUpdateOperationsInput | $Enums.POStatus
    total_amount?: FloatFieldUpdateOperationsInput | number
    items_count?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemCreateInput = {
    id?: string
    material_id: string
    material_name?: string | null
    material_description?: string | null
    quantity: number
    unit_price: number
    total_price: number
    received_quantity?: number | null
    unit: string
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    purchase_order: PurchaseOrderCreateNestedOneWithoutItemsInput
  }

  export type PurchaseOrderItemUncheckedCreateInput = {
    id?: string
    purchase_order_id: string
    material_id: string
    material_name?: string | null
    material_description?: string | null
    quantity: number
    unit_price: number
    total_price: number
    received_quantity?: number | null
    unit: string
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PurchaseOrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    material_id?: StringFieldUpdateOperationsInput | string
    material_name?: NullableStringFieldUpdateOperationsInput | string | null
    material_description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    received_quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase_order?: PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type PurchaseOrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchase_order_id?: StringFieldUpdateOperationsInput | string
    material_id?: StringFieldUpdateOperationsInput | string
    material_name?: NullableStringFieldUpdateOperationsInput | string | null
    material_description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    received_quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemCreateManyInput = {
    id?: string
    purchase_order_id: string
    material_id: string
    material_name?: string | null
    material_description?: string | null
    quantity: number
    unit_price: number
    total_price: number
    received_quantity?: number | null
    unit: string
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PurchaseOrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    material_id?: StringFieldUpdateOperationsInput | string
    material_name?: NullableStringFieldUpdateOperationsInput | string | null
    material_description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    received_quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchase_order_id?: StringFieldUpdateOperationsInput | string
    material_id?: StringFieldUpdateOperationsInput | string
    material_name?: NullableStringFieldUpdateOperationsInput | string | null
    material_description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    received_quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashFlowEntryCreateInput = {
    id?: string
    entry_date: Date | string
    description: string
    category: string
    entry_type: $Enums.CashFlowType
    amount: number
    source: string
    marketplace?: string | null
    reference?: string | null
    notes?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CashFlowEntryUncheckedCreateInput = {
    id?: string
    entry_date: Date | string
    description: string
    category: string
    entry_type: $Enums.CashFlowType
    amount: number
    source: string
    marketplace?: string | null
    reference?: string | null
    notes?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CashFlowEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    entry_type?: EnumCashFlowTypeFieldUpdateOperationsInput | $Enums.CashFlowType
    amount?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashFlowEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    entry_type?: EnumCashFlowTypeFieldUpdateOperationsInput | $Enums.CashFlowType
    amount?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashFlowEntryCreateManyInput = {
    id?: string
    entry_date: Date | string
    description: string
    category: string
    entry_type: $Enums.CashFlowType
    amount: number
    source: string
    marketplace?: string | null
    reference?: string | null
    notes?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CashFlowEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    entry_type?: EnumCashFlowTypeFieldUpdateOperationsInput | $Enums.CashFlowType
    amount?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashFlowEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entry_date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    entry_type?: EnumCashFlowTypeFieldUpdateOperationsInput | $Enums.CashFlowType
    amount?: FloatFieldUpdateOperationsInput | number
    source?: StringFieldUpdateOperationsInput | string
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardMetricsCreateInput = {
    id?: string
    metric_date: Date | string
    distinct_orders: number
    total_quantity_sold: number
    total_revenue: number
    total_profit: number
    total_hpp: number
    profit_margin: number
    average_order_value: number
    total_sales_records: number
    today_revenue: number
    today_orders: number
    month_revenue: number
    month_orders: number
    total_products: number
    low_stock_products: number
    out_of_stock_products: number
    total_categories: number
    total_brands: number
    calculated_at?: Date | string
  }

  export type DashboardMetricsUncheckedCreateInput = {
    id?: string
    metric_date: Date | string
    distinct_orders: number
    total_quantity_sold: number
    total_revenue: number
    total_profit: number
    total_hpp: number
    profit_margin: number
    average_order_value: number
    total_sales_records: number
    today_revenue: number
    today_orders: number
    month_revenue: number
    month_orders: number
    total_products: number
    low_stock_products: number
    out_of_stock_products: number
    total_categories: number
    total_brands: number
    calculated_at?: Date | string
  }

  export type DashboardMetricsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    metric_date?: DateTimeFieldUpdateOperationsInput | Date | string
    distinct_orders?: IntFieldUpdateOperationsInput | number
    total_quantity_sold?: IntFieldUpdateOperationsInput | number
    total_revenue?: FloatFieldUpdateOperationsInput | number
    total_profit?: FloatFieldUpdateOperationsInput | number
    total_hpp?: FloatFieldUpdateOperationsInput | number
    profit_margin?: FloatFieldUpdateOperationsInput | number
    average_order_value?: FloatFieldUpdateOperationsInput | number
    total_sales_records?: IntFieldUpdateOperationsInput | number
    today_revenue?: FloatFieldUpdateOperationsInput | number
    today_orders?: IntFieldUpdateOperationsInput | number
    month_revenue?: FloatFieldUpdateOperationsInput | number
    month_orders?: IntFieldUpdateOperationsInput | number
    total_products?: IntFieldUpdateOperationsInput | number
    low_stock_products?: IntFieldUpdateOperationsInput | number
    out_of_stock_products?: IntFieldUpdateOperationsInput | number
    total_categories?: IntFieldUpdateOperationsInput | number
    total_brands?: IntFieldUpdateOperationsInput | number
    calculated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardMetricsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    metric_date?: DateTimeFieldUpdateOperationsInput | Date | string
    distinct_orders?: IntFieldUpdateOperationsInput | number
    total_quantity_sold?: IntFieldUpdateOperationsInput | number
    total_revenue?: FloatFieldUpdateOperationsInput | number
    total_profit?: FloatFieldUpdateOperationsInput | number
    total_hpp?: FloatFieldUpdateOperationsInput | number
    profit_margin?: FloatFieldUpdateOperationsInput | number
    average_order_value?: FloatFieldUpdateOperationsInput | number
    total_sales_records?: IntFieldUpdateOperationsInput | number
    today_revenue?: FloatFieldUpdateOperationsInput | number
    today_orders?: IntFieldUpdateOperationsInput | number
    month_revenue?: FloatFieldUpdateOperationsInput | number
    month_orders?: IntFieldUpdateOperationsInput | number
    total_products?: IntFieldUpdateOperationsInput | number
    low_stock_products?: IntFieldUpdateOperationsInput | number
    out_of_stock_products?: IntFieldUpdateOperationsInput | number
    total_categories?: IntFieldUpdateOperationsInput | number
    total_brands?: IntFieldUpdateOperationsInput | number
    calculated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardMetricsCreateManyInput = {
    id?: string
    metric_date: Date | string
    distinct_orders: number
    total_quantity_sold: number
    total_revenue: number
    total_profit: number
    total_hpp: number
    profit_margin: number
    average_order_value: number
    total_sales_records: number
    today_revenue: number
    today_orders: number
    month_revenue: number
    month_orders: number
    total_products: number
    low_stock_products: number
    out_of_stock_products: number
    total_categories: number
    total_brands: number
    calculated_at?: Date | string
  }

  export type DashboardMetricsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    metric_date?: DateTimeFieldUpdateOperationsInput | Date | string
    distinct_orders?: IntFieldUpdateOperationsInput | number
    total_quantity_sold?: IntFieldUpdateOperationsInput | number
    total_revenue?: FloatFieldUpdateOperationsInput | number
    total_profit?: FloatFieldUpdateOperationsInput | number
    total_hpp?: FloatFieldUpdateOperationsInput | number
    profit_margin?: FloatFieldUpdateOperationsInput | number
    average_order_value?: FloatFieldUpdateOperationsInput | number
    total_sales_records?: IntFieldUpdateOperationsInput | number
    today_revenue?: FloatFieldUpdateOperationsInput | number
    today_orders?: IntFieldUpdateOperationsInput | number
    month_revenue?: FloatFieldUpdateOperationsInput | number
    month_orders?: IntFieldUpdateOperationsInput | number
    total_products?: IntFieldUpdateOperationsInput | number
    low_stock_products?: IntFieldUpdateOperationsInput | number
    out_of_stock_products?: IntFieldUpdateOperationsInput | number
    total_categories?: IntFieldUpdateOperationsInput | number
    total_brands?: IntFieldUpdateOperationsInput | number
    calculated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DashboardMetricsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    metric_date?: DateTimeFieldUpdateOperationsInput | Date | string
    distinct_orders?: IntFieldUpdateOperationsInput | number
    total_quantity_sold?: IntFieldUpdateOperationsInput | number
    total_revenue?: FloatFieldUpdateOperationsInput | number
    total_profit?: FloatFieldUpdateOperationsInput | number
    total_hpp?: FloatFieldUpdateOperationsInput | number
    profit_margin?: FloatFieldUpdateOperationsInput | number
    average_order_value?: FloatFieldUpdateOperationsInput | number
    total_sales_records?: IntFieldUpdateOperationsInput | number
    today_revenue?: FloatFieldUpdateOperationsInput | number
    today_orders?: IntFieldUpdateOperationsInput | number
    month_revenue?: FloatFieldUpdateOperationsInput | number
    month_orders?: IntFieldUpdateOperationsInput | number
    total_products?: IntFieldUpdateOperationsInput | number
    low_stock_products?: IntFieldUpdateOperationsInput | number
    out_of_stock_products?: IntFieldUpdateOperationsInput | number
    total_categories?: IntFieldUpdateOperationsInput | number
    total_brands?: IntFieldUpdateOperationsInput | number
    calculated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportHistoryCreateInput = {
    id?: string
    timestamp?: Date | string
    user_id?: string | null
    import_type: string
    file_name?: string | null
    file_size?: number | null
    file_hash?: string | null
    total_records: number
    imported_records: number
    failed_records?: number
    duplicate_records?: number
    success_rate?: number | null
    processing_time_ms?: number | null
    import_status?: $Enums.ImportHistoryStatus
    error_details?: string | null
    import_summary?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    source_ip?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    importMetadata?: ImportMetadataCreateNestedManyWithoutImport_historyInput
  }

  export type ImportHistoryUncheckedCreateInput = {
    id?: string
    timestamp?: Date | string
    user_id?: string | null
    import_type: string
    file_name?: string | null
    file_size?: number | null
    file_hash?: string | null
    total_records: number
    imported_records: number
    failed_records?: number
    duplicate_records?: number
    success_rate?: number | null
    processing_time_ms?: number | null
    import_status?: $Enums.ImportHistoryStatus
    error_details?: string | null
    import_summary?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    source_ip?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    importMetadata?: ImportMetadataUncheckedCreateNestedManyWithoutImport_historyInput
  }

  export type ImportHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    import_type?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    file_hash?: NullableStringFieldUpdateOperationsInput | string | null
    total_records?: IntFieldUpdateOperationsInput | number
    imported_records?: IntFieldUpdateOperationsInput | number
    failed_records?: IntFieldUpdateOperationsInput | number
    duplicate_records?: IntFieldUpdateOperationsInput | number
    success_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    processing_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    import_status?: EnumImportHistoryStatusFieldUpdateOperationsInput | $Enums.ImportHistoryStatus
    error_details?: NullableStringFieldUpdateOperationsInput | string | null
    import_summary?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    source_ip?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    importMetadata?: ImportMetadataUpdateManyWithoutImport_historyNestedInput
  }

  export type ImportHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    import_type?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    file_hash?: NullableStringFieldUpdateOperationsInput | string | null
    total_records?: IntFieldUpdateOperationsInput | number
    imported_records?: IntFieldUpdateOperationsInput | number
    failed_records?: IntFieldUpdateOperationsInput | number
    duplicate_records?: IntFieldUpdateOperationsInput | number
    success_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    processing_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    import_status?: EnumImportHistoryStatusFieldUpdateOperationsInput | $Enums.ImportHistoryStatus
    error_details?: NullableStringFieldUpdateOperationsInput | string | null
    import_summary?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    source_ip?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    importMetadata?: ImportMetadataUncheckedUpdateManyWithoutImport_historyNestedInput
  }

  export type ImportHistoryCreateManyInput = {
    id?: string
    timestamp?: Date | string
    user_id?: string | null
    import_type: string
    file_name?: string | null
    file_size?: number | null
    file_hash?: string | null
    total_records: number
    imported_records: number
    failed_records?: number
    duplicate_records?: number
    success_rate?: number | null
    processing_time_ms?: number | null
    import_status?: $Enums.ImportHistoryStatus
    error_details?: string | null
    import_summary?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    source_ip?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ImportHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    import_type?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    file_hash?: NullableStringFieldUpdateOperationsInput | string | null
    total_records?: IntFieldUpdateOperationsInput | number
    imported_records?: IntFieldUpdateOperationsInput | number
    failed_records?: IntFieldUpdateOperationsInput | number
    duplicate_records?: IntFieldUpdateOperationsInput | number
    success_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    processing_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    import_status?: EnumImportHistoryStatusFieldUpdateOperationsInput | $Enums.ImportHistoryStatus
    error_details?: NullableStringFieldUpdateOperationsInput | string | null
    import_summary?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    source_ip?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    import_type?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    file_hash?: NullableStringFieldUpdateOperationsInput | string | null
    total_records?: IntFieldUpdateOperationsInput | number
    imported_records?: IntFieldUpdateOperationsInput | number
    failed_records?: IntFieldUpdateOperationsInput | number
    duplicate_records?: IntFieldUpdateOperationsInput | number
    success_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    processing_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    import_status?: EnumImportHistoryStatusFieldUpdateOperationsInput | $Enums.ImportHistoryStatus
    error_details?: NullableStringFieldUpdateOperationsInput | string | null
    import_summary?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    source_ip?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    invoice_number: string
    customer_name: string
    customer_email: string
    customer_phone?: string | null
    issue_date?: Date | string
    due_date: Date | string
    status?: $Enums.InvoiceStatus
    type?: $Enums.InvoiceType
    subtotal: number
    tax?: number
    discount?: number
    total: number
    notes?: string | null
    payment_method?: string | null
    payment_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    invoice_number: string
    customer_name: string
    customer_email: string
    customer_phone?: string | null
    issue_date?: Date | string
    due_date: Date | string
    status?: $Enums.InvoiceStatus
    type?: $Enums.InvoiceType
    subtotal: number
    tax?: number
    discount?: number
    total: number
    notes?: string | null
    payment_method?: string | null
    payment_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    customer_name?: StringFieldUpdateOperationsInput | string
    customer_email?: StringFieldUpdateOperationsInput | string
    customer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    customer_name?: StringFieldUpdateOperationsInput | string
    customer_email?: StringFieldUpdateOperationsInput | string
    customer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    invoice_number: string
    customer_name: string
    customer_email: string
    customer_phone?: string | null
    issue_date?: Date | string
    due_date: Date | string
    status?: $Enums.InvoiceStatus
    type?: $Enums.InvoiceType
    subtotal: number
    tax?: number
    discount?: number
    total: number
    notes?: string | null
    payment_method?: string | null
    payment_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    customer_name?: StringFieldUpdateOperationsInput | string
    customer_email?: StringFieldUpdateOperationsInput | string
    customer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    customer_name?: StringFieldUpdateOperationsInput | string
    customer_email?: StringFieldUpdateOperationsInput | string
    customer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceItemCreateInput = {
    id?: string
    product_name: string
    quantity: number
    unit_price: number
    total: number
    created_at?: Date | string
    updated_at?: Date | string
    invoice: InvoiceCreateNestedOneWithoutItemsInput
  }

  export type InvoiceItemUncheckedCreateInput = {
    id?: string
    invoice_id: string
    product_name: string
    quantity: number
    unit_price: number
    total: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InvoiceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateManyInput = {
    id?: string
    invoice_id: string
    product_name: string
    quantity: number
    unit_price: number
    total: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InvoiceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateEndorsementCreateInput = {
    id?: string
    campaign_name: string
    affiliate_name: string
    affiliate_type: string
    start_date: Date | string
    end_date: Date | string
    endorse_fee?: number
    target_sales?: number
    actual_sales?: number
    total_commission?: number
    payment_method?: string | null
    platform?: AffiliateEndorsementCreateplatformInput | string[]
    content_type?: string | null
    followers?: number | null
    engagement?: number | null
    reference?: string | null
    notes?: string | null
    status?: string
    roi?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    product_sales?: AffiliateProductSaleCreateNestedManyWithoutEndorsementInput
  }

  export type AffiliateEndorsementUncheckedCreateInput = {
    id?: string
    campaign_name: string
    affiliate_name: string
    affiliate_type: string
    start_date: Date | string
    end_date: Date | string
    endorse_fee?: number
    target_sales?: number
    actual_sales?: number
    total_commission?: number
    payment_method?: string | null
    platform?: AffiliateEndorsementCreateplatformInput | string[]
    content_type?: string | null
    followers?: number | null
    engagement?: number | null
    reference?: string | null
    notes?: string | null
    status?: string
    roi?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    product_sales?: AffiliateProductSaleUncheckedCreateNestedManyWithoutEndorsementInput
  }

  export type AffiliateEndorsementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaign_name?: StringFieldUpdateOperationsInput | string
    affiliate_name?: StringFieldUpdateOperationsInput | string
    affiliate_type?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    endorse_fee?: FloatFieldUpdateOperationsInput | number
    target_sales?: FloatFieldUpdateOperationsInput | number
    actual_sales?: FloatFieldUpdateOperationsInput | number
    total_commission?: FloatFieldUpdateOperationsInput | number
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: AffiliateEndorsementUpdateplatformInput | string[]
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    engagement?: NullableFloatFieldUpdateOperationsInput | number | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    roi?: NullableFloatFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product_sales?: AffiliateProductSaleUpdateManyWithoutEndorsementNestedInput
  }

  export type AffiliateEndorsementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaign_name?: StringFieldUpdateOperationsInput | string
    affiliate_name?: StringFieldUpdateOperationsInput | string
    affiliate_type?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    endorse_fee?: FloatFieldUpdateOperationsInput | number
    target_sales?: FloatFieldUpdateOperationsInput | number
    actual_sales?: FloatFieldUpdateOperationsInput | number
    total_commission?: FloatFieldUpdateOperationsInput | number
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: AffiliateEndorsementUpdateplatformInput | string[]
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    engagement?: NullableFloatFieldUpdateOperationsInput | number | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    roi?: NullableFloatFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product_sales?: AffiliateProductSaleUncheckedUpdateManyWithoutEndorsementNestedInput
  }

  export type AffiliateEndorsementCreateManyInput = {
    id?: string
    campaign_name: string
    affiliate_name: string
    affiliate_type: string
    start_date: Date | string
    end_date: Date | string
    endorse_fee?: number
    target_sales?: number
    actual_sales?: number
    total_commission?: number
    payment_method?: string | null
    platform?: AffiliateEndorsementCreateplatformInput | string[]
    content_type?: string | null
    followers?: number | null
    engagement?: number | null
    reference?: string | null
    notes?: string | null
    status?: string
    roi?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AffiliateEndorsementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaign_name?: StringFieldUpdateOperationsInput | string
    affiliate_name?: StringFieldUpdateOperationsInput | string
    affiliate_type?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    endorse_fee?: FloatFieldUpdateOperationsInput | number
    target_sales?: FloatFieldUpdateOperationsInput | number
    actual_sales?: FloatFieldUpdateOperationsInput | number
    total_commission?: FloatFieldUpdateOperationsInput | number
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: AffiliateEndorsementUpdateplatformInput | string[]
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    engagement?: NullableFloatFieldUpdateOperationsInput | number | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    roi?: NullableFloatFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateEndorsementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaign_name?: StringFieldUpdateOperationsInput | string
    affiliate_name?: StringFieldUpdateOperationsInput | string
    affiliate_type?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    endorse_fee?: FloatFieldUpdateOperationsInput | number
    target_sales?: FloatFieldUpdateOperationsInput | number
    actual_sales?: FloatFieldUpdateOperationsInput | number
    total_commission?: FloatFieldUpdateOperationsInput | number
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: AffiliateEndorsementUpdateplatformInput | string[]
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    engagement?: NullableFloatFieldUpdateOperationsInput | number | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    roi?: NullableFloatFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateProductSaleCreateInput = {
    id?: string
    product_name: string
    quantity?: number
    unit_price?: number
    total_sales?: number
    commission?: number
    created_at?: Date | string
    updated_at?: Date | string
    endorsement: AffiliateEndorsementCreateNestedOneWithoutProduct_salesInput
  }

  export type AffiliateProductSaleUncheckedCreateInput = {
    id?: string
    endorsement_id: string
    product_name: string
    quantity?: number
    unit_price?: number
    total_sales?: number
    commission?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AffiliateProductSaleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    total_sales?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    endorsement?: AffiliateEndorsementUpdateOneRequiredWithoutProduct_salesNestedInput
  }

  export type AffiliateProductSaleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    endorsement_id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    total_sales?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateProductSaleCreateManyInput = {
    id?: string
    endorsement_id: string
    product_name: string
    quantity?: number
    unit_price?: number
    total_sales?: number
    commission?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AffiliateProductSaleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    total_sales?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateProductSaleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    endorsement_id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    total_sales?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogsCreateInput = {
    id?: string
    type: string
    title: string
    description: string
    status?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user_id?: string | null
    related_id?: string | null
    related_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivityLogsUncheckedCreateInput = {
    id?: string
    type: string
    title: string
    description: string
    status?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user_id?: string | null
    related_id?: string | null
    related_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivityLogsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    related_id?: NullableStringFieldUpdateOperationsInput | string | null
    related_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    related_id?: NullableStringFieldUpdateOperationsInput | string | null
    related_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogsCreateManyInput = {
    id?: string
    type: string
    title: string
    description: string
    status?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user_id?: string | null
    related_id?: string | null
    related_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivityLogsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    related_id?: NullableStringFieldUpdateOperationsInput | string | null
    related_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    related_id?: NullableStringFieldUpdateOperationsInput | string | null
    related_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DuplicateCheckLogsCreateInput = {
    id?: string
    file_name: string
    file_size?: bigint | number | null
    file_hash?: string | null
    import_type: string
    check_result?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DuplicateCheckLogsUncheckedCreateInput = {
    id?: string
    file_name: string
    file_size?: bigint | number | null
    file_hash?: string | null
    import_type: string
    check_result?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DuplicateCheckLogsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    file_size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    file_hash?: NullableStringFieldUpdateOperationsInput | string | null
    import_type?: StringFieldUpdateOperationsInput | string
    check_result?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DuplicateCheckLogsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    file_size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    file_hash?: NullableStringFieldUpdateOperationsInput | string | null
    import_type?: StringFieldUpdateOperationsInput | string
    check_result?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DuplicateCheckLogsCreateManyInput = {
    id?: string
    file_name: string
    file_size?: bigint | number | null
    file_hash?: string | null
    import_type: string
    check_result?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type DuplicateCheckLogsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    file_size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    file_hash?: NullableStringFieldUpdateOperationsInput | string | null
    import_type?: StringFieldUpdateOperationsInput | string
    check_result?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DuplicateCheckLogsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    file_size?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    file_hash?: NullableStringFieldUpdateOperationsInput | string | null
    import_type?: StringFieldUpdateOperationsInput | string
    check_result?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportMetadataCreateInput = {
    id?: string
    metadata_type: string
    metadata: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
    import_history: ImportHistoryCreateNestedOneWithoutImportMetadataInput
  }

  export type ImportMetadataUncheckedCreateInput = {
    id?: string
    import_history_id: string
    metadata_type: string
    metadata: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type ImportMetadataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    metadata_type?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    import_history?: ImportHistoryUpdateOneRequiredWithoutImportMetadataNestedInput
  }

  export type ImportMetadataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    import_history_id?: StringFieldUpdateOperationsInput | string
    metadata_type?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportMetadataCreateManyInput = {
    id?: string
    import_history_id: string
    metadata_type: string
    metadata: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type ImportMetadataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    metadata_type?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportMetadataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    import_history_id?: StringFieldUpdateOperationsInput | string
    metadata_type?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TailorCreateInput = {
    id?: string
    code: string
    name: string
    contact_person: string
    phone: string
    email: string
    address: string
    specialization: string
    rating?: number
    status?: $Enums.TailorStatus
    payment_terms?: string
    created_at?: Date | string
    updated_at?: Date | string
    productions?: TailorProductionCreateNestedManyWithoutTailorInput
  }

  export type TailorUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    contact_person: string
    phone: string
    email: string
    address: string
    specialization: string
    rating?: number
    status?: $Enums.TailorStatus
    payment_terms?: string
    created_at?: Date | string
    updated_at?: Date | string
    productions?: TailorProductionUncheckedCreateNestedManyWithoutTailorInput
  }

  export type TailorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    specialization?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    status?: EnumTailorStatusFieldUpdateOperationsInput | $Enums.TailorStatus
    payment_terms?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    productions?: TailorProductionUpdateManyWithoutTailorNestedInput
  }

  export type TailorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    specialization?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    status?: EnumTailorStatusFieldUpdateOperationsInput | $Enums.TailorStatus
    payment_terms?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    productions?: TailorProductionUncheckedUpdateManyWithoutTailorNestedInput
  }

  export type TailorCreateManyInput = {
    id?: string
    code: string
    name: string
    contact_person: string
    phone: string
    email: string
    address: string
    specialization: string
    rating?: number
    status?: $Enums.TailorStatus
    payment_terms?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TailorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    specialization?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    status?: EnumTailorStatusFieldUpdateOperationsInput | $Enums.TailorStatus
    payment_terms?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TailorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    specialization?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    status?: EnumTailorStatusFieldUpdateOperationsInput | $Enums.TailorStatus
    payment_terms?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TailorProductionCreateInput = {
    id?: string
    product_name: string
    color: string
    size: string
    finished_stock?: number
    meters_needed?: number
    cost_per_piece?: number
    defective_stock?: number | null
    additional_costs?: number | null
    additional_cost_description?: string | null
    delivery_date?: Date | string | null
    notes?: string | null
    status?: $Enums.TailorProductionStatus
    created_at?: Date | string
    updated_at?: Date | string
    tailor: TailorCreateNestedOneWithoutProductionsInput
  }

  export type TailorProductionUncheckedCreateInput = {
    id?: string
    tailor_id: string
    product_name: string
    color: string
    size: string
    finished_stock?: number
    meters_needed?: number
    cost_per_piece?: number
    defective_stock?: number | null
    additional_costs?: number | null
    additional_cost_description?: string | null
    delivery_date?: Date | string | null
    notes?: string | null
    status?: $Enums.TailorProductionStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TailorProductionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    finished_stock?: IntFieldUpdateOperationsInput | number
    meters_needed?: FloatFieldUpdateOperationsInput | number
    cost_per_piece?: FloatFieldUpdateOperationsInput | number
    defective_stock?: NullableIntFieldUpdateOperationsInput | number | null
    additional_costs?: NullableFloatFieldUpdateOperationsInput | number | null
    additional_cost_description?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTailorProductionStatusFieldUpdateOperationsInput | $Enums.TailorProductionStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    tailor?: TailorUpdateOneRequiredWithoutProductionsNestedInput
  }

  export type TailorProductionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tailor_id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    finished_stock?: IntFieldUpdateOperationsInput | number
    meters_needed?: FloatFieldUpdateOperationsInput | number
    cost_per_piece?: FloatFieldUpdateOperationsInput | number
    defective_stock?: NullableIntFieldUpdateOperationsInput | number | null
    additional_costs?: NullableFloatFieldUpdateOperationsInput | number | null
    additional_cost_description?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTailorProductionStatusFieldUpdateOperationsInput | $Enums.TailorProductionStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TailorProductionCreateManyInput = {
    id?: string
    tailor_id: string
    product_name: string
    color: string
    size: string
    finished_stock?: number
    meters_needed?: number
    cost_per_piece?: number
    defective_stock?: number | null
    additional_costs?: number | null
    additional_cost_description?: string | null
    delivery_date?: Date | string | null
    notes?: string | null
    status?: $Enums.TailorProductionStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TailorProductionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    finished_stock?: IntFieldUpdateOperationsInput | number
    meters_needed?: FloatFieldUpdateOperationsInput | number
    cost_per_piece?: FloatFieldUpdateOperationsInput | number
    defective_stock?: NullableIntFieldUpdateOperationsInput | number | null
    additional_costs?: NullableFloatFieldUpdateOperationsInput | number | null
    additional_cost_description?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTailorProductionStatusFieldUpdateOperationsInput | $Enums.TailorProductionStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TailorProductionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tailor_id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    finished_stock?: IntFieldUpdateOperationsInput | number
    meters_needed?: FloatFieldUpdateOperationsInput | number
    cost_per_piece?: FloatFieldUpdateOperationsInput | number
    defective_stock?: NullableIntFieldUpdateOperationsInput | number | null
    additional_costs?: NullableFloatFieldUpdateOperationsInput | number | null
    additional_cost_description?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTailorProductionStatusFieldUpdateOperationsInput | $Enums.TailorProductionStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductHPPCreateInput = {
    id?: string
    nama_produk: string
    size?: string | null
    hpp: number
    kategori?: string | null
    deskripsi?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductHPPUncheckedCreateInput = {
    id?: string
    nama_produk: string
    size?: string | null
    hpp: number
    kategori?: string | null
    deskripsi?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductHPPUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama_produk?: StringFieldUpdateOperationsInput | string
    size?: NullableStringFieldUpdateOperationsInput | string | null
    hpp?: FloatFieldUpdateOperationsInput | number
    kategori?: NullableStringFieldUpdateOperationsInput | string | null
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductHPPUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama_produk?: StringFieldUpdateOperationsInput | string
    size?: NullableStringFieldUpdateOperationsInput | string | null
    hpp?: FloatFieldUpdateOperationsInput | number
    kategori?: NullableStringFieldUpdateOperationsInput | string | null
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductHPPCreateManyInput = {
    id?: string
    nama_produk: string
    size?: string | null
    hpp: number
    kategori?: string | null
    deskripsi?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductHPPUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama_produk?: StringFieldUpdateOperationsInput | string
    size?: NullableStringFieldUpdateOperationsInput | string | null
    hpp?: FloatFieldUpdateOperationsInput | number
    kategori?: NullableStringFieldUpdateOperationsInput | string | null
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductHPPUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama_produk?: StringFieldUpdateOperationsInput | string
    size?: NullableStringFieldUpdateOperationsInput | string | null
    hpp?: FloatFieldUpdateOperationsInput | number
    kategori?: NullableStringFieldUpdateOperationsInput | string | null
    deskripsi?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type ImportBatchNullableRelationFilter = {
    is?: ImportBatchWhereInput | null
    isNot?: ImportBatchWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SalesDataOrder_idSeller_skuColorSizeCompoundUniqueInput = {
    order_id: string
    seller_sku: string
    color: string
    size: string
  }

  export type SalesDataCountOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    seller_sku?: SortOrder
    product_name?: SortOrder
    color?: SortOrder
    size?: SortOrder
    quantity?: SortOrder
    order_amount?: SortOrder
    created_time?: SortOrder
    delivered_time?: SortOrder
    settlement_amount?: SortOrder
    total_revenue?: SortOrder
    hpp?: SortOrder
    total?: SortOrder
    marketplace?: SortOrder
    customer?: SortOrder
    province?: SortOrder
    regency_city?: SortOrder
    import_batch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SalesDataAvgOrderByAggregateInput = {
    quantity?: SortOrder
    order_amount?: SortOrder
    settlement_amount?: SortOrder
    total_revenue?: SortOrder
    hpp?: SortOrder
    total?: SortOrder
  }

  export type SalesDataMaxOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    seller_sku?: SortOrder
    product_name?: SortOrder
    color?: SortOrder
    size?: SortOrder
    quantity?: SortOrder
    order_amount?: SortOrder
    created_time?: SortOrder
    delivered_time?: SortOrder
    settlement_amount?: SortOrder
    total_revenue?: SortOrder
    hpp?: SortOrder
    total?: SortOrder
    marketplace?: SortOrder
    customer?: SortOrder
    province?: SortOrder
    regency_city?: SortOrder
    import_batch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SalesDataMinOrderByAggregateInput = {
    id?: SortOrder
    order_id?: SortOrder
    seller_sku?: SortOrder
    product_name?: SortOrder
    color?: SortOrder
    size?: SortOrder
    quantity?: SortOrder
    order_amount?: SortOrder
    created_time?: SortOrder
    delivered_time?: SortOrder
    settlement_amount?: SortOrder
    total_revenue?: SortOrder
    hpp?: SortOrder
    total?: SortOrder
    marketplace?: SortOrder
    customer?: SortOrder
    province?: SortOrder
    regency_city?: SortOrder
    import_batch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SalesDataSumOrderByAggregateInput = {
    quantity?: SortOrder
    order_amount?: SortOrder
    settlement_amount?: SortOrder
    total_revenue?: SortOrder
    hpp?: SortOrder
    total?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StockDataListRelationFilter = {
    every?: StockDataWhereInput
    some?: StockDataWhereInput
    none?: StockDataWhereInput
  }

  export type StockDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductDataCountOrderByAggregateInput = {
    id?: SortOrder
    product_code?: SortOrder
    product_name?: SortOrder
    category?: SortOrder
    brand?: SortOrder
    size?: SortOrder
    color?: SortOrder
    price?: SortOrder
    cost?: SortOrder
    stock_quantity?: SortOrder
    min_stock?: SortOrder
    description?: SortOrder
    import_batch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductDataAvgOrderByAggregateInput = {
    price?: SortOrder
    cost?: SortOrder
    stock_quantity?: SortOrder
    min_stock?: SortOrder
  }

  export type ProductDataMaxOrderByAggregateInput = {
    id?: SortOrder
    product_code?: SortOrder
    product_name?: SortOrder
    category?: SortOrder
    brand?: SortOrder
    size?: SortOrder
    color?: SortOrder
    price?: SortOrder
    cost?: SortOrder
    stock_quantity?: SortOrder
    min_stock?: SortOrder
    description?: SortOrder
    import_batch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductDataMinOrderByAggregateInput = {
    id?: SortOrder
    product_code?: SortOrder
    product_name?: SortOrder
    category?: SortOrder
    brand?: SortOrder
    size?: SortOrder
    color?: SortOrder
    price?: SortOrder
    cost?: SortOrder
    stock_quantity?: SortOrder
    min_stock?: SortOrder
    description?: SortOrder
    import_batch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductDataSumOrderByAggregateInput = {
    price?: SortOrder
    cost?: SortOrder
    stock_quantity?: SortOrder
    min_stock?: SortOrder
  }

  export type EnumStockMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StockMovementType | EnumStockMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StockMovementType[] | ListEnumStockMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StockMovementType[] | ListEnumStockMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStockMovementTypeFilter<$PrismaModel> | $Enums.StockMovementType
  }

  export type ProductDataNullableRelationFilter = {
    is?: ProductDataWhereInput | null
    isNot?: ProductDataWhereInput | null
  }

  export type StockDataCountOrderByAggregateInput = {
    id?: SortOrder
    product_code?: SortOrder
    movement_type?: SortOrder
    quantity?: SortOrder
    reference_number?: SortOrder
    notes?: SortOrder
    movement_date?: SortOrder
    import_batch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StockDataAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type StockDataMaxOrderByAggregateInput = {
    id?: SortOrder
    product_code?: SortOrder
    movement_type?: SortOrder
    quantity?: SortOrder
    reference_number?: SortOrder
    notes?: SortOrder
    movement_date?: SortOrder
    import_batch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StockDataMinOrderByAggregateInput = {
    id?: SortOrder
    product_code?: SortOrder
    movement_type?: SortOrder
    quantity?: SortOrder
    reference_number?: SortOrder
    notes?: SortOrder
    movement_date?: SortOrder
    import_batch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StockDataSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EnumStockMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StockMovementType | EnumStockMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StockMovementType[] | ListEnumStockMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StockMovementType[] | ListEnumStockMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStockMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.StockMovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStockMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumStockMovementTypeFilter<$PrismaModel>
  }

  export type EnumImportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportType | EnumImportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImportType[] | ListEnumImportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportType[] | ListEnumImportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImportTypeFilter<$PrismaModel> | $Enums.ImportType
  }

  export type EnumImportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportStatus | EnumImportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportStatusFilter<$PrismaModel> | $Enums.ImportStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SalesDataListRelationFilter = {
    every?: SalesDataWhereInput
    some?: SalesDataWhereInput
    none?: SalesDataWhereInput
  }

  export type ProductDataListRelationFilter = {
    every?: ProductDataWhereInput
    some?: ProductDataWhereInput
    none?: ProductDataWhereInput
  }

  export type AdvertisingDataListRelationFilter = {
    every?: AdvertisingDataWhereInput
    some?: AdvertisingDataWhereInput
    none?: AdvertisingDataWhereInput
  }

  export type AdvertisingSettlementListRelationFilter = {
    every?: AdvertisingSettlementWhereInput
    some?: AdvertisingSettlementWhereInput
    none?: AdvertisingSettlementWhereInput
  }

  export type ReturnsAndCancellationsListRelationFilter = {
    every?: ReturnsAndCancellationsWhereInput
    some?: ReturnsAndCancellationsWhereInput
    none?: ReturnsAndCancellationsWhereInput
  }

  export type MarketplaceReimbursementListRelationFilter = {
    every?: MarketplaceReimbursementWhereInput
    some?: MarketplaceReimbursementWhereInput
    none?: MarketplaceReimbursementWhereInput
  }

  export type CommissionAdjustmentsListRelationFilter = {
    every?: CommissionAdjustmentsWhereInput
    some?: CommissionAdjustmentsWhereInput
    none?: CommissionAdjustmentsWhereInput
  }

  export type AffiliateSamplesListRelationFilter = {
    every?: AffiliateSamplesWhereInput
    some?: AffiliateSamplesWhereInput
    none?: AffiliateSamplesWhereInput
  }

  export type SalesDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdvertisingDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdvertisingSettlementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReturnsAndCancellationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MarketplaceReimbursementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommissionAdjustmentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AffiliateSamplesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImportBatchCountOrderByAggregateInput = {
    id?: SortOrder
    batch_name?: SortOrder
    import_type?: SortOrder
    file_name?: SortOrder
    file_type?: SortOrder
    total_records?: SortOrder
    valid_records?: SortOrder
    invalid_records?: SortOrder
    imported_records?: SortOrder
    status?: SortOrder
    error_details?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ImportBatchAvgOrderByAggregateInput = {
    total_records?: SortOrder
    valid_records?: SortOrder
    invalid_records?: SortOrder
    imported_records?: SortOrder
  }

  export type ImportBatchMaxOrderByAggregateInput = {
    id?: SortOrder
    batch_name?: SortOrder
    import_type?: SortOrder
    file_name?: SortOrder
    file_type?: SortOrder
    total_records?: SortOrder
    valid_records?: SortOrder
    invalid_records?: SortOrder
    imported_records?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ImportBatchMinOrderByAggregateInput = {
    id?: SortOrder
    batch_name?: SortOrder
    import_type?: SortOrder
    file_name?: SortOrder
    file_type?: SortOrder
    total_records?: SortOrder
    valid_records?: SortOrder
    invalid_records?: SortOrder
    imported_records?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ImportBatchSumOrderByAggregateInput = {
    total_records?: SortOrder
    valid_records?: SortOrder
    invalid_records?: SortOrder
    imported_records?: SortOrder
  }

  export type EnumImportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportType | EnumImportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImportType[] | ListEnumImportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportType[] | ListEnumImportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImportTypeWithAggregatesFilter<$PrismaModel> | $Enums.ImportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImportTypeFilter<$PrismaModel>
    _max?: NestedEnumImportTypeFilter<$PrismaModel>
  }

  export type EnumImportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportStatus | EnumImportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ImportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImportStatusFilter<$PrismaModel>
    _max?: NestedEnumImportStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type AdvertisingDataCountOrderByAggregateInput = {
    id?: SortOrder
    campaign_name?: SortOrder
    ad_creative_type?: SortOrder
    ad_creative?: SortOrder
    account_name?: SortOrder
    cost?: SortOrder
    conversions?: SortOrder
    cpa?: SortOrder
    revenue?: SortOrder
    roi?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    ctr?: SortOrder
    conversion_rate?: SortOrder
    date_start?: SortOrder
    date_end?: SortOrder
    marketplace?: SortOrder
    nama_produk?: SortOrder
    import_batch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AdvertisingDataAvgOrderByAggregateInput = {
    cost?: SortOrder
    conversions?: SortOrder
    cpa?: SortOrder
    revenue?: SortOrder
    roi?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    ctr?: SortOrder
    conversion_rate?: SortOrder
  }

  export type AdvertisingDataMaxOrderByAggregateInput = {
    id?: SortOrder
    campaign_name?: SortOrder
    ad_creative_type?: SortOrder
    ad_creative?: SortOrder
    account_name?: SortOrder
    cost?: SortOrder
    conversions?: SortOrder
    cpa?: SortOrder
    revenue?: SortOrder
    roi?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    ctr?: SortOrder
    conversion_rate?: SortOrder
    date_start?: SortOrder
    date_end?: SortOrder
    marketplace?: SortOrder
    nama_produk?: SortOrder
    import_batch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AdvertisingDataMinOrderByAggregateInput = {
    id?: SortOrder
    campaign_name?: SortOrder
    ad_creative_type?: SortOrder
    ad_creative?: SortOrder
    account_name?: SortOrder
    cost?: SortOrder
    conversions?: SortOrder
    cpa?: SortOrder
    revenue?: SortOrder
    roi?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    ctr?: SortOrder
    conversion_rate?: SortOrder
    date_start?: SortOrder
    date_end?: SortOrder
    marketplace?: SortOrder
    nama_produk?: SortOrder
    import_batch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AdvertisingDataSumOrderByAggregateInput = {
    cost?: SortOrder
    conversions?: SortOrder
    cpa?: SortOrder
    revenue?: SortOrder
    roi?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    ctr?: SortOrder
    conversion_rate?: SortOrder
  }

  export type AdvertisingSettlementCountOrderByAggregateInput = {
    order_id?: SortOrder
    type?: SortOrder
    order_created_time?: SortOrder
    order_settled_time?: SortOrder
    settlement_amount?: SortOrder
    settlement_period?: SortOrder
    account_name?: SortOrder
    marketplace?: SortOrder
    currency?: SortOrder
    import_batch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AdvertisingSettlementAvgOrderByAggregateInput = {
    settlement_amount?: SortOrder
  }

  export type AdvertisingSettlementMaxOrderByAggregateInput = {
    order_id?: SortOrder
    type?: SortOrder
    order_created_time?: SortOrder
    order_settled_time?: SortOrder
    settlement_amount?: SortOrder
    settlement_period?: SortOrder
    account_name?: SortOrder
    marketplace?: SortOrder
    currency?: SortOrder
    import_batch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AdvertisingSettlementMinOrderByAggregateInput = {
    order_id?: SortOrder
    type?: SortOrder
    order_created_time?: SortOrder
    order_settled_time?: SortOrder
    settlement_amount?: SortOrder
    settlement_period?: SortOrder
    account_name?: SortOrder
    marketplace?: SortOrder
    currency?: SortOrder
    import_batch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AdvertisingSettlementSumOrderByAggregateInput = {
    settlement_amount?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ReturnsAndCancellationsCountOrderByAggregateInput = {
    id?: SortOrder
    original_order_id?: SortOrder
    original_sales_id?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    return_date?: SortOrder
    returned_amount?: SortOrder
    refund_amount?: SortOrder
    restocking_fee?: SortOrder
    shipping_cost_loss?: SortOrder
    product_name?: SortOrder
    quantity_returned?: SortOrder
    original_price?: SortOrder
    marketplace?: SortOrder
    product_condition?: SortOrder
    resellable?: SortOrder
    import_batch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ReturnsAndCancellationsAvgOrderByAggregateInput = {
    returned_amount?: SortOrder
    refund_amount?: SortOrder
    restocking_fee?: SortOrder
    shipping_cost_loss?: SortOrder
    quantity_returned?: SortOrder
    original_price?: SortOrder
  }

  export type ReturnsAndCancellationsMaxOrderByAggregateInput = {
    id?: SortOrder
    original_order_id?: SortOrder
    original_sales_id?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    return_date?: SortOrder
    returned_amount?: SortOrder
    refund_amount?: SortOrder
    restocking_fee?: SortOrder
    shipping_cost_loss?: SortOrder
    product_name?: SortOrder
    quantity_returned?: SortOrder
    original_price?: SortOrder
    marketplace?: SortOrder
    product_condition?: SortOrder
    resellable?: SortOrder
    import_batch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ReturnsAndCancellationsMinOrderByAggregateInput = {
    id?: SortOrder
    original_order_id?: SortOrder
    original_sales_id?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    return_date?: SortOrder
    returned_amount?: SortOrder
    refund_amount?: SortOrder
    restocking_fee?: SortOrder
    shipping_cost_loss?: SortOrder
    product_name?: SortOrder
    quantity_returned?: SortOrder
    original_price?: SortOrder
    marketplace?: SortOrder
    product_condition?: SortOrder
    resellable?: SortOrder
    import_batch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ReturnsAndCancellationsSumOrderByAggregateInput = {
    returned_amount?: SortOrder
    refund_amount?: SortOrder
    restocking_fee?: SortOrder
    shipping_cost_loss?: SortOrder
    quantity_returned?: SortOrder
    original_price?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type MarketplaceReimbursementCountOrderByAggregateInput = {
    id?: SortOrder
    claim_id?: SortOrder
    reimbursement_type?: SortOrder
    claim_amount?: SortOrder
    approved_amount?: SortOrder
    received_amount?: SortOrder
    processing_fee?: SortOrder
    incident_date?: SortOrder
    claim_date?: SortOrder
    approval_date?: SortOrder
    received_date?: SortOrder
    affected_order_id?: SortOrder
    product_name?: SortOrder
    marketplace?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    evidence_provided?: SortOrder
    import_batch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MarketplaceReimbursementAvgOrderByAggregateInput = {
    claim_amount?: SortOrder
    approved_amount?: SortOrder
    received_amount?: SortOrder
    processing_fee?: SortOrder
  }

  export type MarketplaceReimbursementMaxOrderByAggregateInput = {
    id?: SortOrder
    claim_id?: SortOrder
    reimbursement_type?: SortOrder
    claim_amount?: SortOrder
    approved_amount?: SortOrder
    received_amount?: SortOrder
    processing_fee?: SortOrder
    incident_date?: SortOrder
    claim_date?: SortOrder
    approval_date?: SortOrder
    received_date?: SortOrder
    affected_order_id?: SortOrder
    product_name?: SortOrder
    marketplace?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    evidence_provided?: SortOrder
    import_batch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MarketplaceReimbursementMinOrderByAggregateInput = {
    id?: SortOrder
    claim_id?: SortOrder
    reimbursement_type?: SortOrder
    claim_amount?: SortOrder
    approved_amount?: SortOrder
    received_amount?: SortOrder
    processing_fee?: SortOrder
    incident_date?: SortOrder
    claim_date?: SortOrder
    approval_date?: SortOrder
    received_date?: SortOrder
    affected_order_id?: SortOrder
    product_name?: SortOrder
    marketplace?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    evidence_provided?: SortOrder
    import_batch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MarketplaceReimbursementSumOrderByAggregateInput = {
    claim_amount?: SortOrder
    approved_amount?: SortOrder
    received_amount?: SortOrder
    processing_fee?: SortOrder
  }

  export type CommissionAdjustmentsCountOrderByAggregateInput = {
    id?: SortOrder
    original_order_id?: SortOrder
    original_sales_id?: SortOrder
    adjustment_type?: SortOrder
    reason?: SortOrder
    original_commission?: SortOrder
    adjustment_amount?: SortOrder
    final_commission?: SortOrder
    marketplace?: SortOrder
    commission_rate?: SortOrder
    dynamic_rate_applied?: SortOrder
    transaction_date?: SortOrder
    adjustment_date?: SortOrder
    product_name?: SortOrder
    quantity?: SortOrder
    product_price?: SortOrder
    import_batch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CommissionAdjustmentsAvgOrderByAggregateInput = {
    original_commission?: SortOrder
    adjustment_amount?: SortOrder
    final_commission?: SortOrder
    commission_rate?: SortOrder
    quantity?: SortOrder
    product_price?: SortOrder
  }

  export type CommissionAdjustmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    original_order_id?: SortOrder
    original_sales_id?: SortOrder
    adjustment_type?: SortOrder
    reason?: SortOrder
    original_commission?: SortOrder
    adjustment_amount?: SortOrder
    final_commission?: SortOrder
    marketplace?: SortOrder
    commission_rate?: SortOrder
    dynamic_rate_applied?: SortOrder
    transaction_date?: SortOrder
    adjustment_date?: SortOrder
    product_name?: SortOrder
    quantity?: SortOrder
    product_price?: SortOrder
    import_batch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CommissionAdjustmentsMinOrderByAggregateInput = {
    id?: SortOrder
    original_order_id?: SortOrder
    original_sales_id?: SortOrder
    adjustment_type?: SortOrder
    reason?: SortOrder
    original_commission?: SortOrder
    adjustment_amount?: SortOrder
    final_commission?: SortOrder
    marketplace?: SortOrder
    commission_rate?: SortOrder
    dynamic_rate_applied?: SortOrder
    transaction_date?: SortOrder
    adjustment_date?: SortOrder
    product_name?: SortOrder
    quantity?: SortOrder
    product_price?: SortOrder
    import_batch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CommissionAdjustmentsSumOrderByAggregateInput = {
    original_commission?: SortOrder
    adjustment_amount?: SortOrder
    final_commission?: SortOrder
    commission_rate?: SortOrder
    quantity?: SortOrder
    product_price?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AffiliateSamplesCountOrderByAggregateInput = {
    id?: SortOrder
    affiliate_name?: SortOrder
    affiliate_platform?: SortOrder
    affiliate_contact?: SortOrder
    product_name?: SortOrder
    product_sku?: SortOrder
    quantity_given?: SortOrder
    product_cost?: SortOrder
    total_cost?: SortOrder
    shipping_cost?: SortOrder
    packaging_cost?: SortOrder
    campaign_name?: SortOrder
    expected_reach?: SortOrder
    content_type?: SortOrder
    given_date?: SortOrder
    expected_content_date?: SortOrder
    actual_content_date?: SortOrder
    content_delivered?: SortOrder
    performance_notes?: SortOrder
    roi_estimate?: SortOrder
    status?: SortOrder
    import_batch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AffiliateSamplesAvgOrderByAggregateInput = {
    quantity_given?: SortOrder
    product_cost?: SortOrder
    total_cost?: SortOrder
    shipping_cost?: SortOrder
    packaging_cost?: SortOrder
    expected_reach?: SortOrder
    roi_estimate?: SortOrder
  }

  export type AffiliateSamplesMaxOrderByAggregateInput = {
    id?: SortOrder
    affiliate_name?: SortOrder
    affiliate_platform?: SortOrder
    affiliate_contact?: SortOrder
    product_name?: SortOrder
    product_sku?: SortOrder
    quantity_given?: SortOrder
    product_cost?: SortOrder
    total_cost?: SortOrder
    shipping_cost?: SortOrder
    packaging_cost?: SortOrder
    campaign_name?: SortOrder
    expected_reach?: SortOrder
    content_type?: SortOrder
    given_date?: SortOrder
    expected_content_date?: SortOrder
    actual_content_date?: SortOrder
    content_delivered?: SortOrder
    performance_notes?: SortOrder
    roi_estimate?: SortOrder
    status?: SortOrder
    import_batch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AffiliateSamplesMinOrderByAggregateInput = {
    id?: SortOrder
    affiliate_name?: SortOrder
    affiliate_platform?: SortOrder
    affiliate_contact?: SortOrder
    product_name?: SortOrder
    product_sku?: SortOrder
    quantity_given?: SortOrder
    product_cost?: SortOrder
    total_cost?: SortOrder
    shipping_cost?: SortOrder
    packaging_cost?: SortOrder
    campaign_name?: SortOrder
    expected_reach?: SortOrder
    content_type?: SortOrder
    given_date?: SortOrder
    expected_content_date?: SortOrder
    actual_content_date?: SortOrder
    content_delivered?: SortOrder
    performance_notes?: SortOrder
    roi_estimate?: SortOrder
    status?: SortOrder
    import_batch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AffiliateSamplesSumOrderByAggregateInput = {
    quantity_given?: SortOrder
    product_cost?: SortOrder
    total_cost?: SortOrder
    shipping_cost?: SortOrder
    packaging_cost?: SortOrder
    expected_reach?: SortOrder
    roi_estimate?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BrandCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    website?: SortOrder
    logo_color?: SortOrder
    is_premium?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BrandMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    website?: SortOrder
    logo_color?: SortOrder
    is_premium?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BrandMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    website?: SortOrder
    logo_color?: SortOrder
    is_premium?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumSupplierStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SupplierStatus | EnumSupplierStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SupplierStatus[] | ListEnumSupplierStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupplierStatus[] | ListEnumSupplierStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSupplierStatusFilter<$PrismaModel> | $Enums.SupplierStatus
  }

  export type PurchaseOrderListRelationFilter = {
    every?: PurchaseOrderWhereInput
    some?: PurchaseOrderWhereInput
    none?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    contact_person?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    category?: SortOrder
    rating?: SortOrder
    status?: SortOrder
    payment_terms?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SupplierAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    contact_person?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    category?: SortOrder
    rating?: SortOrder
    status?: SortOrder
    payment_terms?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    contact_person?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    category?: SortOrder
    rating?: SortOrder
    status?: SortOrder
    payment_terms?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SupplierSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type EnumSupplierStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SupplierStatus | EnumSupplierStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SupplierStatus[] | ListEnumSupplierStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupplierStatus[] | ListEnumSupplierStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSupplierStatusWithAggregatesFilter<$PrismaModel> | $Enums.SupplierStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSupplierStatusFilter<$PrismaModel>
    _max?: NestedEnumSupplierStatusFilter<$PrismaModel>
  }

  export type EnumPOStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.POStatus | EnumPOStatusFieldRefInput<$PrismaModel>
    in?: $Enums.POStatus[] | ListEnumPOStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.POStatus[] | ListEnumPOStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPOStatusFilter<$PrismaModel> | $Enums.POStatus
  }

  export type SupplierRelationFilter = {
    is?: SupplierWhereInput
    isNot?: SupplierWhereInput
  }

  export type PurchaseOrderItemListRelationFilter = {
    every?: PurchaseOrderItemWhereInput
    some?: PurchaseOrderItemWhereInput
    none?: PurchaseOrderItemWhereInput
  }

  export type PurchaseOrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderCountOrderByAggregateInput = {
    id?: SortOrder
    po_number?: SortOrder
    supplier_id?: SortOrder
    po_date?: SortOrder
    expected_date?: SortOrder
    delivery_date?: SortOrder
    status?: SortOrder
    total_amount?: SortOrder
    items_count?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PurchaseOrderAvgOrderByAggregateInput = {
    total_amount?: SortOrder
    items_count?: SortOrder
  }

  export type PurchaseOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    po_number?: SortOrder
    supplier_id?: SortOrder
    po_date?: SortOrder
    expected_date?: SortOrder
    delivery_date?: SortOrder
    status?: SortOrder
    total_amount?: SortOrder
    items_count?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PurchaseOrderMinOrderByAggregateInput = {
    id?: SortOrder
    po_number?: SortOrder
    supplier_id?: SortOrder
    po_date?: SortOrder
    expected_date?: SortOrder
    delivery_date?: SortOrder
    status?: SortOrder
    total_amount?: SortOrder
    items_count?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PurchaseOrderSumOrderByAggregateInput = {
    total_amount?: SortOrder
    items_count?: SortOrder
  }

  export type EnumPOStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.POStatus | EnumPOStatusFieldRefInput<$PrismaModel>
    in?: $Enums.POStatus[] | ListEnumPOStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.POStatus[] | ListEnumPOStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPOStatusWithAggregatesFilter<$PrismaModel> | $Enums.POStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPOStatusFilter<$PrismaModel>
    _max?: NestedEnumPOStatusFilter<$PrismaModel>
  }

  export type PurchaseOrderRelationFilter = {
    is?: PurchaseOrderWhereInput
    isNot?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderItemPurchase_order_idMaterial_idCompoundUniqueInput = {
    purchase_order_id: string
    material_id: string
  }

  export type PurchaseOrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    purchase_order_id?: SortOrder
    material_id?: SortOrder
    material_name?: SortOrder
    material_description?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total_price?: SortOrder
    received_quantity?: SortOrder
    unit?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PurchaseOrderItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unit_price?: SortOrder
    total_price?: SortOrder
    received_quantity?: SortOrder
  }

  export type PurchaseOrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    purchase_order_id?: SortOrder
    material_id?: SortOrder
    material_name?: SortOrder
    material_description?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total_price?: SortOrder
    received_quantity?: SortOrder
    unit?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PurchaseOrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    purchase_order_id?: SortOrder
    material_id?: SortOrder
    material_name?: SortOrder
    material_description?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total_price?: SortOrder
    received_quantity?: SortOrder
    unit?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PurchaseOrderItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unit_price?: SortOrder
    total_price?: SortOrder
    received_quantity?: SortOrder
  }

  export type EnumCashFlowTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CashFlowType | EnumCashFlowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CashFlowType[] | ListEnumCashFlowTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CashFlowType[] | ListEnumCashFlowTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCashFlowTypeFilter<$PrismaModel> | $Enums.CashFlowType
  }

  export type CashFlowEntryCountOrderByAggregateInput = {
    id?: SortOrder
    entry_date?: SortOrder
    description?: SortOrder
    category?: SortOrder
    entry_type?: SortOrder
    amount?: SortOrder
    source?: SortOrder
    marketplace?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CashFlowEntryAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type CashFlowEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    entry_date?: SortOrder
    description?: SortOrder
    category?: SortOrder
    entry_type?: SortOrder
    amount?: SortOrder
    source?: SortOrder
    marketplace?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CashFlowEntryMinOrderByAggregateInput = {
    id?: SortOrder
    entry_date?: SortOrder
    description?: SortOrder
    category?: SortOrder
    entry_type?: SortOrder
    amount?: SortOrder
    source?: SortOrder
    marketplace?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CashFlowEntrySumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumCashFlowTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CashFlowType | EnumCashFlowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CashFlowType[] | ListEnumCashFlowTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CashFlowType[] | ListEnumCashFlowTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCashFlowTypeWithAggregatesFilter<$PrismaModel> | $Enums.CashFlowType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCashFlowTypeFilter<$PrismaModel>
    _max?: NestedEnumCashFlowTypeFilter<$PrismaModel>
  }

  export type DashboardMetricsCountOrderByAggregateInput = {
    id?: SortOrder
    metric_date?: SortOrder
    distinct_orders?: SortOrder
    total_quantity_sold?: SortOrder
    total_revenue?: SortOrder
    total_profit?: SortOrder
    total_hpp?: SortOrder
    profit_margin?: SortOrder
    average_order_value?: SortOrder
    total_sales_records?: SortOrder
    today_revenue?: SortOrder
    today_orders?: SortOrder
    month_revenue?: SortOrder
    month_orders?: SortOrder
    total_products?: SortOrder
    low_stock_products?: SortOrder
    out_of_stock_products?: SortOrder
    total_categories?: SortOrder
    total_brands?: SortOrder
    calculated_at?: SortOrder
  }

  export type DashboardMetricsAvgOrderByAggregateInput = {
    distinct_orders?: SortOrder
    total_quantity_sold?: SortOrder
    total_revenue?: SortOrder
    total_profit?: SortOrder
    total_hpp?: SortOrder
    profit_margin?: SortOrder
    average_order_value?: SortOrder
    total_sales_records?: SortOrder
    today_revenue?: SortOrder
    today_orders?: SortOrder
    month_revenue?: SortOrder
    month_orders?: SortOrder
    total_products?: SortOrder
    low_stock_products?: SortOrder
    out_of_stock_products?: SortOrder
    total_categories?: SortOrder
    total_brands?: SortOrder
  }

  export type DashboardMetricsMaxOrderByAggregateInput = {
    id?: SortOrder
    metric_date?: SortOrder
    distinct_orders?: SortOrder
    total_quantity_sold?: SortOrder
    total_revenue?: SortOrder
    total_profit?: SortOrder
    total_hpp?: SortOrder
    profit_margin?: SortOrder
    average_order_value?: SortOrder
    total_sales_records?: SortOrder
    today_revenue?: SortOrder
    today_orders?: SortOrder
    month_revenue?: SortOrder
    month_orders?: SortOrder
    total_products?: SortOrder
    low_stock_products?: SortOrder
    out_of_stock_products?: SortOrder
    total_categories?: SortOrder
    total_brands?: SortOrder
    calculated_at?: SortOrder
  }

  export type DashboardMetricsMinOrderByAggregateInput = {
    id?: SortOrder
    metric_date?: SortOrder
    distinct_orders?: SortOrder
    total_quantity_sold?: SortOrder
    total_revenue?: SortOrder
    total_profit?: SortOrder
    total_hpp?: SortOrder
    profit_margin?: SortOrder
    average_order_value?: SortOrder
    total_sales_records?: SortOrder
    today_revenue?: SortOrder
    today_orders?: SortOrder
    month_revenue?: SortOrder
    month_orders?: SortOrder
    total_products?: SortOrder
    low_stock_products?: SortOrder
    out_of_stock_products?: SortOrder
    total_categories?: SortOrder
    total_brands?: SortOrder
    calculated_at?: SortOrder
  }

  export type DashboardMetricsSumOrderByAggregateInput = {
    distinct_orders?: SortOrder
    total_quantity_sold?: SortOrder
    total_revenue?: SortOrder
    total_profit?: SortOrder
    total_hpp?: SortOrder
    profit_margin?: SortOrder
    average_order_value?: SortOrder
    total_sales_records?: SortOrder
    today_revenue?: SortOrder
    today_orders?: SortOrder
    month_revenue?: SortOrder
    month_orders?: SortOrder
    total_products?: SortOrder
    low_stock_products?: SortOrder
    out_of_stock_products?: SortOrder
    total_categories?: SortOrder
    total_brands?: SortOrder
  }

  export type EnumImportHistoryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportHistoryStatus | EnumImportHistoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportHistoryStatus[] | ListEnumImportHistoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportHistoryStatus[] | ListEnumImportHistoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportHistoryStatusFilter<$PrismaModel> | $Enums.ImportHistoryStatus
  }

  export type ImportMetadataListRelationFilter = {
    every?: ImportMetadataWhereInput
    some?: ImportMetadataWhereInput
    none?: ImportMetadataWhereInput
  }

  export type ImportMetadataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImportHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    user_id?: SortOrder
    import_type?: SortOrder
    file_name?: SortOrder
    file_size?: SortOrder
    file_hash?: SortOrder
    total_records?: SortOrder
    imported_records?: SortOrder
    failed_records?: SortOrder
    duplicate_records?: SortOrder
    success_rate?: SortOrder
    processing_time_ms?: SortOrder
    import_status?: SortOrder
    error_details?: SortOrder
    import_summary?: SortOrder
    metadata?: SortOrder
    source_ip?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ImportHistoryAvgOrderByAggregateInput = {
    file_size?: SortOrder
    total_records?: SortOrder
    imported_records?: SortOrder
    failed_records?: SortOrder
    duplicate_records?: SortOrder
    success_rate?: SortOrder
    processing_time_ms?: SortOrder
  }

  export type ImportHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    user_id?: SortOrder
    import_type?: SortOrder
    file_name?: SortOrder
    file_size?: SortOrder
    file_hash?: SortOrder
    total_records?: SortOrder
    imported_records?: SortOrder
    failed_records?: SortOrder
    duplicate_records?: SortOrder
    success_rate?: SortOrder
    processing_time_ms?: SortOrder
    import_status?: SortOrder
    error_details?: SortOrder
    source_ip?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ImportHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    user_id?: SortOrder
    import_type?: SortOrder
    file_name?: SortOrder
    file_size?: SortOrder
    file_hash?: SortOrder
    total_records?: SortOrder
    imported_records?: SortOrder
    failed_records?: SortOrder
    duplicate_records?: SortOrder
    success_rate?: SortOrder
    processing_time_ms?: SortOrder
    import_status?: SortOrder
    error_details?: SortOrder
    source_ip?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ImportHistorySumOrderByAggregateInput = {
    file_size?: SortOrder
    total_records?: SortOrder
    imported_records?: SortOrder
    failed_records?: SortOrder
    duplicate_records?: SortOrder
    success_rate?: SortOrder
    processing_time_ms?: SortOrder
  }

  export type EnumImportHistoryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportHistoryStatus | EnumImportHistoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportHistoryStatus[] | ListEnumImportHistoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportHistoryStatus[] | ListEnumImportHistoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportHistoryStatusWithAggregatesFilter<$PrismaModel> | $Enums.ImportHistoryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImportHistoryStatusFilter<$PrismaModel>
    _max?: NestedEnumImportHistoryStatusFilter<$PrismaModel>
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type EnumInvoiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeFilter<$PrismaModel> | $Enums.InvoiceType
  }

  export type InvoiceItemListRelationFilter = {
    every?: InvoiceItemWhereInput
    some?: InvoiceItemWhereInput
    none?: InvoiceItemWhereInput
  }

  export type InvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoice_number?: SortOrder
    customer_name?: SortOrder
    customer_email?: SortOrder
    customer_phone?: SortOrder
    issue_date?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    type?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    notes?: SortOrder
    payment_method?: SortOrder
    payment_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoice_number?: SortOrder
    customer_name?: SortOrder
    customer_email?: SortOrder
    customer_phone?: SortOrder
    issue_date?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    type?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    notes?: SortOrder
    payment_method?: SortOrder
    payment_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoice_number?: SortOrder
    customer_name?: SortOrder
    customer_email?: SortOrder
    customer_phone?: SortOrder
    issue_date?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    type?: SortOrder
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
    notes?: SortOrder
    payment_method?: SortOrder
    payment_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    created_by?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    subtotal?: SortOrder
    tax?: SortOrder
    discount?: SortOrder
    total?: SortOrder
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type EnumInvoiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceTypeFilter<$PrismaModel>
    _max?: NestedEnumInvoiceTypeFilter<$PrismaModel>
  }

  export type InvoiceRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type InvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    product_name?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type InvoiceItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unit_price?: SortOrder
    total?: SortOrder
  }

  export type InvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    product_name?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type InvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    product_name?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type InvoiceItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unit_price?: SortOrder
    total?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type AffiliateProductSaleListRelationFilter = {
    every?: AffiliateProductSaleWhereInput
    some?: AffiliateProductSaleWhereInput
    none?: AffiliateProductSaleWhereInput
  }

  export type AffiliateProductSaleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AffiliateEndorsementCountOrderByAggregateInput = {
    id?: SortOrder
    campaign_name?: SortOrder
    affiliate_name?: SortOrder
    affiliate_type?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    endorse_fee?: SortOrder
    target_sales?: SortOrder
    actual_sales?: SortOrder
    total_commission?: SortOrder
    payment_method?: SortOrder
    platform?: SortOrder
    content_type?: SortOrder
    followers?: SortOrder
    engagement?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    roi?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AffiliateEndorsementAvgOrderByAggregateInput = {
    endorse_fee?: SortOrder
    target_sales?: SortOrder
    actual_sales?: SortOrder
    total_commission?: SortOrder
    followers?: SortOrder
    engagement?: SortOrder
    roi?: SortOrder
  }

  export type AffiliateEndorsementMaxOrderByAggregateInput = {
    id?: SortOrder
    campaign_name?: SortOrder
    affiliate_name?: SortOrder
    affiliate_type?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    endorse_fee?: SortOrder
    target_sales?: SortOrder
    actual_sales?: SortOrder
    total_commission?: SortOrder
    payment_method?: SortOrder
    content_type?: SortOrder
    followers?: SortOrder
    engagement?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    roi?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AffiliateEndorsementMinOrderByAggregateInput = {
    id?: SortOrder
    campaign_name?: SortOrder
    affiliate_name?: SortOrder
    affiliate_type?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    endorse_fee?: SortOrder
    target_sales?: SortOrder
    actual_sales?: SortOrder
    total_commission?: SortOrder
    payment_method?: SortOrder
    content_type?: SortOrder
    followers?: SortOrder
    engagement?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    roi?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AffiliateEndorsementSumOrderByAggregateInput = {
    endorse_fee?: SortOrder
    target_sales?: SortOrder
    actual_sales?: SortOrder
    total_commission?: SortOrder
    followers?: SortOrder
    engagement?: SortOrder
    roi?: SortOrder
  }

  export type AffiliateEndorsementRelationFilter = {
    is?: AffiliateEndorsementWhereInput
    isNot?: AffiliateEndorsementWhereInput
  }

  export type AffiliateProductSaleEndorsement_idProduct_nameCompoundUniqueInput = {
    endorsement_id: string
    product_name: string
  }

  export type AffiliateProductSaleCountOrderByAggregateInput = {
    id?: SortOrder
    endorsement_id?: SortOrder
    product_name?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total_sales?: SortOrder
    commission?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AffiliateProductSaleAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unit_price?: SortOrder
    total_sales?: SortOrder
    commission?: SortOrder
  }

  export type AffiliateProductSaleMaxOrderByAggregateInput = {
    id?: SortOrder
    endorsement_id?: SortOrder
    product_name?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total_sales?: SortOrder
    commission?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AffiliateProductSaleMinOrderByAggregateInput = {
    id?: SortOrder
    endorsement_id?: SortOrder
    product_name?: SortOrder
    quantity?: SortOrder
    unit_price?: SortOrder
    total_sales?: SortOrder
    commission?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AffiliateProductSaleSumOrderByAggregateInput = {
    quantity?: SortOrder
    unit_price?: SortOrder
    total_sales?: SortOrder
    commission?: SortOrder
  }

  export type ActivityLogsCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    user_id?: SortOrder
    related_id?: SortOrder
    related_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ActivityLogsMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    user_id?: SortOrder
    related_id?: SortOrder
    related_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ActivityLogsMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    user_id?: SortOrder
    related_id?: SortOrder
    related_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type DuplicateCheckLogsCountOrderByAggregateInput = {
    id?: SortOrder
    file_name?: SortOrder
    file_size?: SortOrder
    file_hash?: SortOrder
    import_type?: SortOrder
    check_result?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DuplicateCheckLogsAvgOrderByAggregateInput = {
    file_size?: SortOrder
  }

  export type DuplicateCheckLogsMaxOrderByAggregateInput = {
    id?: SortOrder
    file_name?: SortOrder
    file_size?: SortOrder
    file_hash?: SortOrder
    import_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DuplicateCheckLogsMinOrderByAggregateInput = {
    id?: SortOrder
    file_name?: SortOrder
    file_size?: SortOrder
    file_hash?: SortOrder
    import_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DuplicateCheckLogsSumOrderByAggregateInput = {
    file_size?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ImportHistoryRelationFilter = {
    is?: ImportHistoryWhereInput
    isNot?: ImportHistoryWhereInput
  }

  export type ImportMetadataCountOrderByAggregateInput = {
    id?: SortOrder
    import_history_id?: SortOrder
    metadata_type?: SortOrder
    metadata?: SortOrder
    created_at?: SortOrder
  }

  export type ImportMetadataMaxOrderByAggregateInput = {
    id?: SortOrder
    import_history_id?: SortOrder
    metadata_type?: SortOrder
    created_at?: SortOrder
  }

  export type ImportMetadataMinOrderByAggregateInput = {
    id?: SortOrder
    import_history_id?: SortOrder
    metadata_type?: SortOrder
    created_at?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumTailorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TailorStatus | EnumTailorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TailorStatus[] | ListEnumTailorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TailorStatus[] | ListEnumTailorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTailorStatusFilter<$PrismaModel> | $Enums.TailorStatus
  }

  export type TailorProductionListRelationFilter = {
    every?: TailorProductionWhereInput
    some?: TailorProductionWhereInput
    none?: TailorProductionWhereInput
  }

  export type TailorProductionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TailorCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    contact_person?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    specialization?: SortOrder
    rating?: SortOrder
    status?: SortOrder
    payment_terms?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TailorAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type TailorMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    contact_person?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    specialization?: SortOrder
    rating?: SortOrder
    status?: SortOrder
    payment_terms?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TailorMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    contact_person?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    specialization?: SortOrder
    rating?: SortOrder
    status?: SortOrder
    payment_terms?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TailorSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type EnumTailorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TailorStatus | EnumTailorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TailorStatus[] | ListEnumTailorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TailorStatus[] | ListEnumTailorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTailorStatusWithAggregatesFilter<$PrismaModel> | $Enums.TailorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTailorStatusFilter<$PrismaModel>
    _max?: NestedEnumTailorStatusFilter<$PrismaModel>
  }

  export type EnumTailorProductionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TailorProductionStatus | EnumTailorProductionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TailorProductionStatus[] | ListEnumTailorProductionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TailorProductionStatus[] | ListEnumTailorProductionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTailorProductionStatusFilter<$PrismaModel> | $Enums.TailorProductionStatus
  }

  export type TailorRelationFilter = {
    is?: TailorWhereInput
    isNot?: TailorWhereInput
  }

  export type TailorProductionCountOrderByAggregateInput = {
    id?: SortOrder
    tailor_id?: SortOrder
    product_name?: SortOrder
    color?: SortOrder
    size?: SortOrder
    finished_stock?: SortOrder
    meters_needed?: SortOrder
    cost_per_piece?: SortOrder
    defective_stock?: SortOrder
    additional_costs?: SortOrder
    additional_cost_description?: SortOrder
    delivery_date?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TailorProductionAvgOrderByAggregateInput = {
    finished_stock?: SortOrder
    meters_needed?: SortOrder
    cost_per_piece?: SortOrder
    defective_stock?: SortOrder
    additional_costs?: SortOrder
  }

  export type TailorProductionMaxOrderByAggregateInput = {
    id?: SortOrder
    tailor_id?: SortOrder
    product_name?: SortOrder
    color?: SortOrder
    size?: SortOrder
    finished_stock?: SortOrder
    meters_needed?: SortOrder
    cost_per_piece?: SortOrder
    defective_stock?: SortOrder
    additional_costs?: SortOrder
    additional_cost_description?: SortOrder
    delivery_date?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TailorProductionMinOrderByAggregateInput = {
    id?: SortOrder
    tailor_id?: SortOrder
    product_name?: SortOrder
    color?: SortOrder
    size?: SortOrder
    finished_stock?: SortOrder
    meters_needed?: SortOrder
    cost_per_piece?: SortOrder
    defective_stock?: SortOrder
    additional_costs?: SortOrder
    additional_cost_description?: SortOrder
    delivery_date?: SortOrder
    notes?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TailorProductionSumOrderByAggregateInput = {
    finished_stock?: SortOrder
    meters_needed?: SortOrder
    cost_per_piece?: SortOrder
    defective_stock?: SortOrder
    additional_costs?: SortOrder
  }

  export type EnumTailorProductionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TailorProductionStatus | EnumTailorProductionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TailorProductionStatus[] | ListEnumTailorProductionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TailorProductionStatus[] | ListEnumTailorProductionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTailorProductionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TailorProductionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTailorProductionStatusFilter<$PrismaModel>
    _max?: NestedEnumTailorProductionStatusFilter<$PrismaModel>
  }

  export type ProductHPPNama_produkSizeCompoundUniqueInput = {
    nama_produk: string
    size: string
  }

  export type ProductHPPCountOrderByAggregateInput = {
    id?: SortOrder
    nama_produk?: SortOrder
    size?: SortOrder
    hpp?: SortOrder
    kategori?: SortOrder
    deskripsi?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductHPPAvgOrderByAggregateInput = {
    hpp?: SortOrder
  }

  export type ProductHPPMaxOrderByAggregateInput = {
    id?: SortOrder
    nama_produk?: SortOrder
    size?: SortOrder
    hpp?: SortOrder
    kategori?: SortOrder
    deskripsi?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductHPPMinOrderByAggregateInput = {
    id?: SortOrder
    nama_produk?: SortOrder
    size?: SortOrder
    hpp?: SortOrder
    kategori?: SortOrder
    deskripsi?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProductHPPSumOrderByAggregateInput = {
    hpp?: SortOrder
  }

  export type ImportBatchCreateNestedOneWithoutSales_dataInput = {
    create?: XOR<ImportBatchCreateWithoutSales_dataInput, ImportBatchUncheckedCreateWithoutSales_dataInput>
    connectOrCreate?: ImportBatchCreateOrConnectWithoutSales_dataInput
    connect?: ImportBatchWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ImportBatchUpdateOneWithoutSales_dataNestedInput = {
    create?: XOR<ImportBatchCreateWithoutSales_dataInput, ImportBatchUncheckedCreateWithoutSales_dataInput>
    connectOrCreate?: ImportBatchCreateOrConnectWithoutSales_dataInput
    upsert?: ImportBatchUpsertWithoutSales_dataInput
    disconnect?: ImportBatchWhereInput | boolean
    delete?: ImportBatchWhereInput | boolean
    connect?: ImportBatchWhereUniqueInput
    update?: XOR<XOR<ImportBatchUpdateToOneWithWhereWithoutSales_dataInput, ImportBatchUpdateWithoutSales_dataInput>, ImportBatchUncheckedUpdateWithoutSales_dataInput>
  }

  export type StockDataCreateNestedManyWithoutProductInput = {
    create?: XOR<StockDataCreateWithoutProductInput, StockDataUncheckedCreateWithoutProductInput> | StockDataCreateWithoutProductInput[] | StockDataUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockDataCreateOrConnectWithoutProductInput | StockDataCreateOrConnectWithoutProductInput[]
    createMany?: StockDataCreateManyProductInputEnvelope
    connect?: StockDataWhereUniqueInput | StockDataWhereUniqueInput[]
  }

  export type ImportBatchCreateNestedOneWithoutProduct_dataInput = {
    create?: XOR<ImportBatchCreateWithoutProduct_dataInput, ImportBatchUncheckedCreateWithoutProduct_dataInput>
    connectOrCreate?: ImportBatchCreateOrConnectWithoutProduct_dataInput
    connect?: ImportBatchWhereUniqueInput
  }

  export type StockDataUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<StockDataCreateWithoutProductInput, StockDataUncheckedCreateWithoutProductInput> | StockDataCreateWithoutProductInput[] | StockDataUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockDataCreateOrConnectWithoutProductInput | StockDataCreateOrConnectWithoutProductInput[]
    createMany?: StockDataCreateManyProductInputEnvelope
    connect?: StockDataWhereUniqueInput | StockDataWhereUniqueInput[]
  }

  export type StockDataUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockDataCreateWithoutProductInput, StockDataUncheckedCreateWithoutProductInput> | StockDataCreateWithoutProductInput[] | StockDataUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockDataCreateOrConnectWithoutProductInput | StockDataCreateOrConnectWithoutProductInput[]
    upsert?: StockDataUpsertWithWhereUniqueWithoutProductInput | StockDataUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockDataCreateManyProductInputEnvelope
    set?: StockDataWhereUniqueInput | StockDataWhereUniqueInput[]
    disconnect?: StockDataWhereUniqueInput | StockDataWhereUniqueInput[]
    delete?: StockDataWhereUniqueInput | StockDataWhereUniqueInput[]
    connect?: StockDataWhereUniqueInput | StockDataWhereUniqueInput[]
    update?: StockDataUpdateWithWhereUniqueWithoutProductInput | StockDataUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockDataUpdateManyWithWhereWithoutProductInput | StockDataUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockDataScalarWhereInput | StockDataScalarWhereInput[]
  }

  export type ImportBatchUpdateOneWithoutProduct_dataNestedInput = {
    create?: XOR<ImportBatchCreateWithoutProduct_dataInput, ImportBatchUncheckedCreateWithoutProduct_dataInput>
    connectOrCreate?: ImportBatchCreateOrConnectWithoutProduct_dataInput
    upsert?: ImportBatchUpsertWithoutProduct_dataInput
    disconnect?: ImportBatchWhereInput | boolean
    delete?: ImportBatchWhereInput | boolean
    connect?: ImportBatchWhereUniqueInput
    update?: XOR<XOR<ImportBatchUpdateToOneWithWhereWithoutProduct_dataInput, ImportBatchUpdateWithoutProduct_dataInput>, ImportBatchUncheckedUpdateWithoutProduct_dataInput>
  }

  export type StockDataUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<StockDataCreateWithoutProductInput, StockDataUncheckedCreateWithoutProductInput> | StockDataCreateWithoutProductInput[] | StockDataUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StockDataCreateOrConnectWithoutProductInput | StockDataCreateOrConnectWithoutProductInput[]
    upsert?: StockDataUpsertWithWhereUniqueWithoutProductInput | StockDataUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StockDataCreateManyProductInputEnvelope
    set?: StockDataWhereUniqueInput | StockDataWhereUniqueInput[]
    disconnect?: StockDataWhereUniqueInput | StockDataWhereUniqueInput[]
    delete?: StockDataWhereUniqueInput | StockDataWhereUniqueInput[]
    connect?: StockDataWhereUniqueInput | StockDataWhereUniqueInput[]
    update?: StockDataUpdateWithWhereUniqueWithoutProductInput | StockDataUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StockDataUpdateManyWithWhereWithoutProductInput | StockDataUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StockDataScalarWhereInput | StockDataScalarWhereInput[]
  }

  export type ProductDataCreateNestedOneWithoutStock_movementsInput = {
    create?: XOR<ProductDataCreateWithoutStock_movementsInput, ProductDataUncheckedCreateWithoutStock_movementsInput>
    connectOrCreate?: ProductDataCreateOrConnectWithoutStock_movementsInput
    connect?: ProductDataWhereUniqueInput
  }

  export type ImportBatchCreateNestedOneWithoutStock_dataInput = {
    create?: XOR<ImportBatchCreateWithoutStock_dataInput, ImportBatchUncheckedCreateWithoutStock_dataInput>
    connectOrCreate?: ImportBatchCreateOrConnectWithoutStock_dataInput
    connect?: ImportBatchWhereUniqueInput
  }

  export type EnumStockMovementTypeFieldUpdateOperationsInput = {
    set?: $Enums.StockMovementType
  }

  export type ProductDataUpdateOneWithoutStock_movementsNestedInput = {
    create?: XOR<ProductDataCreateWithoutStock_movementsInput, ProductDataUncheckedCreateWithoutStock_movementsInput>
    connectOrCreate?: ProductDataCreateOrConnectWithoutStock_movementsInput
    upsert?: ProductDataUpsertWithoutStock_movementsInput
    disconnect?: ProductDataWhereInput | boolean
    delete?: ProductDataWhereInput | boolean
    connect?: ProductDataWhereUniqueInput
    update?: XOR<XOR<ProductDataUpdateToOneWithWhereWithoutStock_movementsInput, ProductDataUpdateWithoutStock_movementsInput>, ProductDataUncheckedUpdateWithoutStock_movementsInput>
  }

  export type ImportBatchUpdateOneWithoutStock_dataNestedInput = {
    create?: XOR<ImportBatchCreateWithoutStock_dataInput, ImportBatchUncheckedCreateWithoutStock_dataInput>
    connectOrCreate?: ImportBatchCreateOrConnectWithoutStock_dataInput
    upsert?: ImportBatchUpsertWithoutStock_dataInput
    disconnect?: ImportBatchWhereInput | boolean
    delete?: ImportBatchWhereInput | boolean
    connect?: ImportBatchWhereUniqueInput
    update?: XOR<XOR<ImportBatchUpdateToOneWithWhereWithoutStock_dataInput, ImportBatchUpdateWithoutStock_dataInput>, ImportBatchUncheckedUpdateWithoutStock_dataInput>
  }

  export type SalesDataCreateNestedManyWithoutImport_batchInput = {
    create?: XOR<SalesDataCreateWithoutImport_batchInput, SalesDataUncheckedCreateWithoutImport_batchInput> | SalesDataCreateWithoutImport_batchInput[] | SalesDataUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: SalesDataCreateOrConnectWithoutImport_batchInput | SalesDataCreateOrConnectWithoutImport_batchInput[]
    createMany?: SalesDataCreateManyImport_batchInputEnvelope
    connect?: SalesDataWhereUniqueInput | SalesDataWhereUniqueInput[]
  }

  export type ProductDataCreateNestedManyWithoutImport_batchInput = {
    create?: XOR<ProductDataCreateWithoutImport_batchInput, ProductDataUncheckedCreateWithoutImport_batchInput> | ProductDataCreateWithoutImport_batchInput[] | ProductDataUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: ProductDataCreateOrConnectWithoutImport_batchInput | ProductDataCreateOrConnectWithoutImport_batchInput[]
    createMany?: ProductDataCreateManyImport_batchInputEnvelope
    connect?: ProductDataWhereUniqueInput | ProductDataWhereUniqueInput[]
  }

  export type StockDataCreateNestedManyWithoutImport_batchInput = {
    create?: XOR<StockDataCreateWithoutImport_batchInput, StockDataUncheckedCreateWithoutImport_batchInput> | StockDataCreateWithoutImport_batchInput[] | StockDataUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: StockDataCreateOrConnectWithoutImport_batchInput | StockDataCreateOrConnectWithoutImport_batchInput[]
    createMany?: StockDataCreateManyImport_batchInputEnvelope
    connect?: StockDataWhereUniqueInput | StockDataWhereUniqueInput[]
  }

  export type AdvertisingDataCreateNestedManyWithoutImport_batchInput = {
    create?: XOR<AdvertisingDataCreateWithoutImport_batchInput, AdvertisingDataUncheckedCreateWithoutImport_batchInput> | AdvertisingDataCreateWithoutImport_batchInput[] | AdvertisingDataUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: AdvertisingDataCreateOrConnectWithoutImport_batchInput | AdvertisingDataCreateOrConnectWithoutImport_batchInput[]
    createMany?: AdvertisingDataCreateManyImport_batchInputEnvelope
    connect?: AdvertisingDataWhereUniqueInput | AdvertisingDataWhereUniqueInput[]
  }

  export type AdvertisingSettlementCreateNestedManyWithoutImport_batchInput = {
    create?: XOR<AdvertisingSettlementCreateWithoutImport_batchInput, AdvertisingSettlementUncheckedCreateWithoutImport_batchInput> | AdvertisingSettlementCreateWithoutImport_batchInput[] | AdvertisingSettlementUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: AdvertisingSettlementCreateOrConnectWithoutImport_batchInput | AdvertisingSettlementCreateOrConnectWithoutImport_batchInput[]
    createMany?: AdvertisingSettlementCreateManyImport_batchInputEnvelope
    connect?: AdvertisingSettlementWhereUniqueInput | AdvertisingSettlementWhereUniqueInput[]
  }

  export type ReturnsAndCancellationsCreateNestedManyWithoutImport_batchInput = {
    create?: XOR<ReturnsAndCancellationsCreateWithoutImport_batchInput, ReturnsAndCancellationsUncheckedCreateWithoutImport_batchInput> | ReturnsAndCancellationsCreateWithoutImport_batchInput[] | ReturnsAndCancellationsUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: ReturnsAndCancellationsCreateOrConnectWithoutImport_batchInput | ReturnsAndCancellationsCreateOrConnectWithoutImport_batchInput[]
    createMany?: ReturnsAndCancellationsCreateManyImport_batchInputEnvelope
    connect?: ReturnsAndCancellationsWhereUniqueInput | ReturnsAndCancellationsWhereUniqueInput[]
  }

  export type MarketplaceReimbursementCreateNestedManyWithoutImport_batchInput = {
    create?: XOR<MarketplaceReimbursementCreateWithoutImport_batchInput, MarketplaceReimbursementUncheckedCreateWithoutImport_batchInput> | MarketplaceReimbursementCreateWithoutImport_batchInput[] | MarketplaceReimbursementUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: MarketplaceReimbursementCreateOrConnectWithoutImport_batchInput | MarketplaceReimbursementCreateOrConnectWithoutImport_batchInput[]
    createMany?: MarketplaceReimbursementCreateManyImport_batchInputEnvelope
    connect?: MarketplaceReimbursementWhereUniqueInput | MarketplaceReimbursementWhereUniqueInput[]
  }

  export type CommissionAdjustmentsCreateNestedManyWithoutImport_batchInput = {
    create?: XOR<CommissionAdjustmentsCreateWithoutImport_batchInput, CommissionAdjustmentsUncheckedCreateWithoutImport_batchInput> | CommissionAdjustmentsCreateWithoutImport_batchInput[] | CommissionAdjustmentsUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: CommissionAdjustmentsCreateOrConnectWithoutImport_batchInput | CommissionAdjustmentsCreateOrConnectWithoutImport_batchInput[]
    createMany?: CommissionAdjustmentsCreateManyImport_batchInputEnvelope
    connect?: CommissionAdjustmentsWhereUniqueInput | CommissionAdjustmentsWhereUniqueInput[]
  }

  export type AffiliateSamplesCreateNestedManyWithoutImport_batchInput = {
    create?: XOR<AffiliateSamplesCreateWithoutImport_batchInput, AffiliateSamplesUncheckedCreateWithoutImport_batchInput> | AffiliateSamplesCreateWithoutImport_batchInput[] | AffiliateSamplesUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: AffiliateSamplesCreateOrConnectWithoutImport_batchInput | AffiliateSamplesCreateOrConnectWithoutImport_batchInput[]
    createMany?: AffiliateSamplesCreateManyImport_batchInputEnvelope
    connect?: AffiliateSamplesWhereUniqueInput | AffiliateSamplesWhereUniqueInput[]
  }

  export type SalesDataUncheckedCreateNestedManyWithoutImport_batchInput = {
    create?: XOR<SalesDataCreateWithoutImport_batchInput, SalesDataUncheckedCreateWithoutImport_batchInput> | SalesDataCreateWithoutImport_batchInput[] | SalesDataUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: SalesDataCreateOrConnectWithoutImport_batchInput | SalesDataCreateOrConnectWithoutImport_batchInput[]
    createMany?: SalesDataCreateManyImport_batchInputEnvelope
    connect?: SalesDataWhereUniqueInput | SalesDataWhereUniqueInput[]
  }

  export type ProductDataUncheckedCreateNestedManyWithoutImport_batchInput = {
    create?: XOR<ProductDataCreateWithoutImport_batchInput, ProductDataUncheckedCreateWithoutImport_batchInput> | ProductDataCreateWithoutImport_batchInput[] | ProductDataUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: ProductDataCreateOrConnectWithoutImport_batchInput | ProductDataCreateOrConnectWithoutImport_batchInput[]
    createMany?: ProductDataCreateManyImport_batchInputEnvelope
    connect?: ProductDataWhereUniqueInput | ProductDataWhereUniqueInput[]
  }

  export type StockDataUncheckedCreateNestedManyWithoutImport_batchInput = {
    create?: XOR<StockDataCreateWithoutImport_batchInput, StockDataUncheckedCreateWithoutImport_batchInput> | StockDataCreateWithoutImport_batchInput[] | StockDataUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: StockDataCreateOrConnectWithoutImport_batchInput | StockDataCreateOrConnectWithoutImport_batchInput[]
    createMany?: StockDataCreateManyImport_batchInputEnvelope
    connect?: StockDataWhereUniqueInput | StockDataWhereUniqueInput[]
  }

  export type AdvertisingDataUncheckedCreateNestedManyWithoutImport_batchInput = {
    create?: XOR<AdvertisingDataCreateWithoutImport_batchInput, AdvertisingDataUncheckedCreateWithoutImport_batchInput> | AdvertisingDataCreateWithoutImport_batchInput[] | AdvertisingDataUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: AdvertisingDataCreateOrConnectWithoutImport_batchInput | AdvertisingDataCreateOrConnectWithoutImport_batchInput[]
    createMany?: AdvertisingDataCreateManyImport_batchInputEnvelope
    connect?: AdvertisingDataWhereUniqueInput | AdvertisingDataWhereUniqueInput[]
  }

  export type AdvertisingSettlementUncheckedCreateNestedManyWithoutImport_batchInput = {
    create?: XOR<AdvertisingSettlementCreateWithoutImport_batchInput, AdvertisingSettlementUncheckedCreateWithoutImport_batchInput> | AdvertisingSettlementCreateWithoutImport_batchInput[] | AdvertisingSettlementUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: AdvertisingSettlementCreateOrConnectWithoutImport_batchInput | AdvertisingSettlementCreateOrConnectWithoutImport_batchInput[]
    createMany?: AdvertisingSettlementCreateManyImport_batchInputEnvelope
    connect?: AdvertisingSettlementWhereUniqueInput | AdvertisingSettlementWhereUniqueInput[]
  }

  export type ReturnsAndCancellationsUncheckedCreateNestedManyWithoutImport_batchInput = {
    create?: XOR<ReturnsAndCancellationsCreateWithoutImport_batchInput, ReturnsAndCancellationsUncheckedCreateWithoutImport_batchInput> | ReturnsAndCancellationsCreateWithoutImport_batchInput[] | ReturnsAndCancellationsUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: ReturnsAndCancellationsCreateOrConnectWithoutImport_batchInput | ReturnsAndCancellationsCreateOrConnectWithoutImport_batchInput[]
    createMany?: ReturnsAndCancellationsCreateManyImport_batchInputEnvelope
    connect?: ReturnsAndCancellationsWhereUniqueInput | ReturnsAndCancellationsWhereUniqueInput[]
  }

  export type MarketplaceReimbursementUncheckedCreateNestedManyWithoutImport_batchInput = {
    create?: XOR<MarketplaceReimbursementCreateWithoutImport_batchInput, MarketplaceReimbursementUncheckedCreateWithoutImport_batchInput> | MarketplaceReimbursementCreateWithoutImport_batchInput[] | MarketplaceReimbursementUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: MarketplaceReimbursementCreateOrConnectWithoutImport_batchInput | MarketplaceReimbursementCreateOrConnectWithoutImport_batchInput[]
    createMany?: MarketplaceReimbursementCreateManyImport_batchInputEnvelope
    connect?: MarketplaceReimbursementWhereUniqueInput | MarketplaceReimbursementWhereUniqueInput[]
  }

  export type CommissionAdjustmentsUncheckedCreateNestedManyWithoutImport_batchInput = {
    create?: XOR<CommissionAdjustmentsCreateWithoutImport_batchInput, CommissionAdjustmentsUncheckedCreateWithoutImport_batchInput> | CommissionAdjustmentsCreateWithoutImport_batchInput[] | CommissionAdjustmentsUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: CommissionAdjustmentsCreateOrConnectWithoutImport_batchInput | CommissionAdjustmentsCreateOrConnectWithoutImport_batchInput[]
    createMany?: CommissionAdjustmentsCreateManyImport_batchInputEnvelope
    connect?: CommissionAdjustmentsWhereUniqueInput | CommissionAdjustmentsWhereUniqueInput[]
  }

  export type AffiliateSamplesUncheckedCreateNestedManyWithoutImport_batchInput = {
    create?: XOR<AffiliateSamplesCreateWithoutImport_batchInput, AffiliateSamplesUncheckedCreateWithoutImport_batchInput> | AffiliateSamplesCreateWithoutImport_batchInput[] | AffiliateSamplesUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: AffiliateSamplesCreateOrConnectWithoutImport_batchInput | AffiliateSamplesCreateOrConnectWithoutImport_batchInput[]
    createMany?: AffiliateSamplesCreateManyImport_batchInputEnvelope
    connect?: AffiliateSamplesWhereUniqueInput | AffiliateSamplesWhereUniqueInput[]
  }

  export type EnumImportTypeFieldUpdateOperationsInput = {
    set?: $Enums.ImportType
  }

  export type EnumImportStatusFieldUpdateOperationsInput = {
    set?: $Enums.ImportStatus
  }

  export type SalesDataUpdateManyWithoutImport_batchNestedInput = {
    create?: XOR<SalesDataCreateWithoutImport_batchInput, SalesDataUncheckedCreateWithoutImport_batchInput> | SalesDataCreateWithoutImport_batchInput[] | SalesDataUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: SalesDataCreateOrConnectWithoutImport_batchInput | SalesDataCreateOrConnectWithoutImport_batchInput[]
    upsert?: SalesDataUpsertWithWhereUniqueWithoutImport_batchInput | SalesDataUpsertWithWhereUniqueWithoutImport_batchInput[]
    createMany?: SalesDataCreateManyImport_batchInputEnvelope
    set?: SalesDataWhereUniqueInput | SalesDataWhereUniqueInput[]
    disconnect?: SalesDataWhereUniqueInput | SalesDataWhereUniqueInput[]
    delete?: SalesDataWhereUniqueInput | SalesDataWhereUniqueInput[]
    connect?: SalesDataWhereUniqueInput | SalesDataWhereUniqueInput[]
    update?: SalesDataUpdateWithWhereUniqueWithoutImport_batchInput | SalesDataUpdateWithWhereUniqueWithoutImport_batchInput[]
    updateMany?: SalesDataUpdateManyWithWhereWithoutImport_batchInput | SalesDataUpdateManyWithWhereWithoutImport_batchInput[]
    deleteMany?: SalesDataScalarWhereInput | SalesDataScalarWhereInput[]
  }

  export type ProductDataUpdateManyWithoutImport_batchNestedInput = {
    create?: XOR<ProductDataCreateWithoutImport_batchInput, ProductDataUncheckedCreateWithoutImport_batchInput> | ProductDataCreateWithoutImport_batchInput[] | ProductDataUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: ProductDataCreateOrConnectWithoutImport_batchInput | ProductDataCreateOrConnectWithoutImport_batchInput[]
    upsert?: ProductDataUpsertWithWhereUniqueWithoutImport_batchInput | ProductDataUpsertWithWhereUniqueWithoutImport_batchInput[]
    createMany?: ProductDataCreateManyImport_batchInputEnvelope
    set?: ProductDataWhereUniqueInput | ProductDataWhereUniqueInput[]
    disconnect?: ProductDataWhereUniqueInput | ProductDataWhereUniqueInput[]
    delete?: ProductDataWhereUniqueInput | ProductDataWhereUniqueInput[]
    connect?: ProductDataWhereUniqueInput | ProductDataWhereUniqueInput[]
    update?: ProductDataUpdateWithWhereUniqueWithoutImport_batchInput | ProductDataUpdateWithWhereUniqueWithoutImport_batchInput[]
    updateMany?: ProductDataUpdateManyWithWhereWithoutImport_batchInput | ProductDataUpdateManyWithWhereWithoutImport_batchInput[]
    deleteMany?: ProductDataScalarWhereInput | ProductDataScalarWhereInput[]
  }

  export type StockDataUpdateManyWithoutImport_batchNestedInput = {
    create?: XOR<StockDataCreateWithoutImport_batchInput, StockDataUncheckedCreateWithoutImport_batchInput> | StockDataCreateWithoutImport_batchInput[] | StockDataUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: StockDataCreateOrConnectWithoutImport_batchInput | StockDataCreateOrConnectWithoutImport_batchInput[]
    upsert?: StockDataUpsertWithWhereUniqueWithoutImport_batchInput | StockDataUpsertWithWhereUniqueWithoutImport_batchInput[]
    createMany?: StockDataCreateManyImport_batchInputEnvelope
    set?: StockDataWhereUniqueInput | StockDataWhereUniqueInput[]
    disconnect?: StockDataWhereUniqueInput | StockDataWhereUniqueInput[]
    delete?: StockDataWhereUniqueInput | StockDataWhereUniqueInput[]
    connect?: StockDataWhereUniqueInput | StockDataWhereUniqueInput[]
    update?: StockDataUpdateWithWhereUniqueWithoutImport_batchInput | StockDataUpdateWithWhereUniqueWithoutImport_batchInput[]
    updateMany?: StockDataUpdateManyWithWhereWithoutImport_batchInput | StockDataUpdateManyWithWhereWithoutImport_batchInput[]
    deleteMany?: StockDataScalarWhereInput | StockDataScalarWhereInput[]
  }

  export type AdvertisingDataUpdateManyWithoutImport_batchNestedInput = {
    create?: XOR<AdvertisingDataCreateWithoutImport_batchInput, AdvertisingDataUncheckedCreateWithoutImport_batchInput> | AdvertisingDataCreateWithoutImport_batchInput[] | AdvertisingDataUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: AdvertisingDataCreateOrConnectWithoutImport_batchInput | AdvertisingDataCreateOrConnectWithoutImport_batchInput[]
    upsert?: AdvertisingDataUpsertWithWhereUniqueWithoutImport_batchInput | AdvertisingDataUpsertWithWhereUniqueWithoutImport_batchInput[]
    createMany?: AdvertisingDataCreateManyImport_batchInputEnvelope
    set?: AdvertisingDataWhereUniqueInput | AdvertisingDataWhereUniqueInput[]
    disconnect?: AdvertisingDataWhereUniqueInput | AdvertisingDataWhereUniqueInput[]
    delete?: AdvertisingDataWhereUniqueInput | AdvertisingDataWhereUniqueInput[]
    connect?: AdvertisingDataWhereUniqueInput | AdvertisingDataWhereUniqueInput[]
    update?: AdvertisingDataUpdateWithWhereUniqueWithoutImport_batchInput | AdvertisingDataUpdateWithWhereUniqueWithoutImport_batchInput[]
    updateMany?: AdvertisingDataUpdateManyWithWhereWithoutImport_batchInput | AdvertisingDataUpdateManyWithWhereWithoutImport_batchInput[]
    deleteMany?: AdvertisingDataScalarWhereInput | AdvertisingDataScalarWhereInput[]
  }

  export type AdvertisingSettlementUpdateManyWithoutImport_batchNestedInput = {
    create?: XOR<AdvertisingSettlementCreateWithoutImport_batchInput, AdvertisingSettlementUncheckedCreateWithoutImport_batchInput> | AdvertisingSettlementCreateWithoutImport_batchInput[] | AdvertisingSettlementUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: AdvertisingSettlementCreateOrConnectWithoutImport_batchInput | AdvertisingSettlementCreateOrConnectWithoutImport_batchInput[]
    upsert?: AdvertisingSettlementUpsertWithWhereUniqueWithoutImport_batchInput | AdvertisingSettlementUpsertWithWhereUniqueWithoutImport_batchInput[]
    createMany?: AdvertisingSettlementCreateManyImport_batchInputEnvelope
    set?: AdvertisingSettlementWhereUniqueInput | AdvertisingSettlementWhereUniqueInput[]
    disconnect?: AdvertisingSettlementWhereUniqueInput | AdvertisingSettlementWhereUniqueInput[]
    delete?: AdvertisingSettlementWhereUniqueInput | AdvertisingSettlementWhereUniqueInput[]
    connect?: AdvertisingSettlementWhereUniqueInput | AdvertisingSettlementWhereUniqueInput[]
    update?: AdvertisingSettlementUpdateWithWhereUniqueWithoutImport_batchInput | AdvertisingSettlementUpdateWithWhereUniqueWithoutImport_batchInput[]
    updateMany?: AdvertisingSettlementUpdateManyWithWhereWithoutImport_batchInput | AdvertisingSettlementUpdateManyWithWhereWithoutImport_batchInput[]
    deleteMany?: AdvertisingSettlementScalarWhereInput | AdvertisingSettlementScalarWhereInput[]
  }

  export type ReturnsAndCancellationsUpdateManyWithoutImport_batchNestedInput = {
    create?: XOR<ReturnsAndCancellationsCreateWithoutImport_batchInput, ReturnsAndCancellationsUncheckedCreateWithoutImport_batchInput> | ReturnsAndCancellationsCreateWithoutImport_batchInput[] | ReturnsAndCancellationsUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: ReturnsAndCancellationsCreateOrConnectWithoutImport_batchInput | ReturnsAndCancellationsCreateOrConnectWithoutImport_batchInput[]
    upsert?: ReturnsAndCancellationsUpsertWithWhereUniqueWithoutImport_batchInput | ReturnsAndCancellationsUpsertWithWhereUniqueWithoutImport_batchInput[]
    createMany?: ReturnsAndCancellationsCreateManyImport_batchInputEnvelope
    set?: ReturnsAndCancellationsWhereUniqueInput | ReturnsAndCancellationsWhereUniqueInput[]
    disconnect?: ReturnsAndCancellationsWhereUniqueInput | ReturnsAndCancellationsWhereUniqueInput[]
    delete?: ReturnsAndCancellationsWhereUniqueInput | ReturnsAndCancellationsWhereUniqueInput[]
    connect?: ReturnsAndCancellationsWhereUniqueInput | ReturnsAndCancellationsWhereUniqueInput[]
    update?: ReturnsAndCancellationsUpdateWithWhereUniqueWithoutImport_batchInput | ReturnsAndCancellationsUpdateWithWhereUniqueWithoutImport_batchInput[]
    updateMany?: ReturnsAndCancellationsUpdateManyWithWhereWithoutImport_batchInput | ReturnsAndCancellationsUpdateManyWithWhereWithoutImport_batchInput[]
    deleteMany?: ReturnsAndCancellationsScalarWhereInput | ReturnsAndCancellationsScalarWhereInput[]
  }

  export type MarketplaceReimbursementUpdateManyWithoutImport_batchNestedInput = {
    create?: XOR<MarketplaceReimbursementCreateWithoutImport_batchInput, MarketplaceReimbursementUncheckedCreateWithoutImport_batchInput> | MarketplaceReimbursementCreateWithoutImport_batchInput[] | MarketplaceReimbursementUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: MarketplaceReimbursementCreateOrConnectWithoutImport_batchInput | MarketplaceReimbursementCreateOrConnectWithoutImport_batchInput[]
    upsert?: MarketplaceReimbursementUpsertWithWhereUniqueWithoutImport_batchInput | MarketplaceReimbursementUpsertWithWhereUniqueWithoutImport_batchInput[]
    createMany?: MarketplaceReimbursementCreateManyImport_batchInputEnvelope
    set?: MarketplaceReimbursementWhereUniqueInput | MarketplaceReimbursementWhereUniqueInput[]
    disconnect?: MarketplaceReimbursementWhereUniqueInput | MarketplaceReimbursementWhereUniqueInput[]
    delete?: MarketplaceReimbursementWhereUniqueInput | MarketplaceReimbursementWhereUniqueInput[]
    connect?: MarketplaceReimbursementWhereUniqueInput | MarketplaceReimbursementWhereUniqueInput[]
    update?: MarketplaceReimbursementUpdateWithWhereUniqueWithoutImport_batchInput | MarketplaceReimbursementUpdateWithWhereUniqueWithoutImport_batchInput[]
    updateMany?: MarketplaceReimbursementUpdateManyWithWhereWithoutImport_batchInput | MarketplaceReimbursementUpdateManyWithWhereWithoutImport_batchInput[]
    deleteMany?: MarketplaceReimbursementScalarWhereInput | MarketplaceReimbursementScalarWhereInput[]
  }

  export type CommissionAdjustmentsUpdateManyWithoutImport_batchNestedInput = {
    create?: XOR<CommissionAdjustmentsCreateWithoutImport_batchInput, CommissionAdjustmentsUncheckedCreateWithoutImport_batchInput> | CommissionAdjustmentsCreateWithoutImport_batchInput[] | CommissionAdjustmentsUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: CommissionAdjustmentsCreateOrConnectWithoutImport_batchInput | CommissionAdjustmentsCreateOrConnectWithoutImport_batchInput[]
    upsert?: CommissionAdjustmentsUpsertWithWhereUniqueWithoutImport_batchInput | CommissionAdjustmentsUpsertWithWhereUniqueWithoutImport_batchInput[]
    createMany?: CommissionAdjustmentsCreateManyImport_batchInputEnvelope
    set?: CommissionAdjustmentsWhereUniqueInput | CommissionAdjustmentsWhereUniqueInput[]
    disconnect?: CommissionAdjustmentsWhereUniqueInput | CommissionAdjustmentsWhereUniqueInput[]
    delete?: CommissionAdjustmentsWhereUniqueInput | CommissionAdjustmentsWhereUniqueInput[]
    connect?: CommissionAdjustmentsWhereUniqueInput | CommissionAdjustmentsWhereUniqueInput[]
    update?: CommissionAdjustmentsUpdateWithWhereUniqueWithoutImport_batchInput | CommissionAdjustmentsUpdateWithWhereUniqueWithoutImport_batchInput[]
    updateMany?: CommissionAdjustmentsUpdateManyWithWhereWithoutImport_batchInput | CommissionAdjustmentsUpdateManyWithWhereWithoutImport_batchInput[]
    deleteMany?: CommissionAdjustmentsScalarWhereInput | CommissionAdjustmentsScalarWhereInput[]
  }

  export type AffiliateSamplesUpdateManyWithoutImport_batchNestedInput = {
    create?: XOR<AffiliateSamplesCreateWithoutImport_batchInput, AffiliateSamplesUncheckedCreateWithoutImport_batchInput> | AffiliateSamplesCreateWithoutImport_batchInput[] | AffiliateSamplesUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: AffiliateSamplesCreateOrConnectWithoutImport_batchInput | AffiliateSamplesCreateOrConnectWithoutImport_batchInput[]
    upsert?: AffiliateSamplesUpsertWithWhereUniqueWithoutImport_batchInput | AffiliateSamplesUpsertWithWhereUniqueWithoutImport_batchInput[]
    createMany?: AffiliateSamplesCreateManyImport_batchInputEnvelope
    set?: AffiliateSamplesWhereUniqueInput | AffiliateSamplesWhereUniqueInput[]
    disconnect?: AffiliateSamplesWhereUniqueInput | AffiliateSamplesWhereUniqueInput[]
    delete?: AffiliateSamplesWhereUniqueInput | AffiliateSamplesWhereUniqueInput[]
    connect?: AffiliateSamplesWhereUniqueInput | AffiliateSamplesWhereUniqueInput[]
    update?: AffiliateSamplesUpdateWithWhereUniqueWithoutImport_batchInput | AffiliateSamplesUpdateWithWhereUniqueWithoutImport_batchInput[]
    updateMany?: AffiliateSamplesUpdateManyWithWhereWithoutImport_batchInput | AffiliateSamplesUpdateManyWithWhereWithoutImport_batchInput[]
    deleteMany?: AffiliateSamplesScalarWhereInput | AffiliateSamplesScalarWhereInput[]
  }

  export type SalesDataUncheckedUpdateManyWithoutImport_batchNestedInput = {
    create?: XOR<SalesDataCreateWithoutImport_batchInput, SalesDataUncheckedCreateWithoutImport_batchInput> | SalesDataCreateWithoutImport_batchInput[] | SalesDataUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: SalesDataCreateOrConnectWithoutImport_batchInput | SalesDataCreateOrConnectWithoutImport_batchInput[]
    upsert?: SalesDataUpsertWithWhereUniqueWithoutImport_batchInput | SalesDataUpsertWithWhereUniqueWithoutImport_batchInput[]
    createMany?: SalesDataCreateManyImport_batchInputEnvelope
    set?: SalesDataWhereUniqueInput | SalesDataWhereUniqueInput[]
    disconnect?: SalesDataWhereUniqueInput | SalesDataWhereUniqueInput[]
    delete?: SalesDataWhereUniqueInput | SalesDataWhereUniqueInput[]
    connect?: SalesDataWhereUniqueInput | SalesDataWhereUniqueInput[]
    update?: SalesDataUpdateWithWhereUniqueWithoutImport_batchInput | SalesDataUpdateWithWhereUniqueWithoutImport_batchInput[]
    updateMany?: SalesDataUpdateManyWithWhereWithoutImport_batchInput | SalesDataUpdateManyWithWhereWithoutImport_batchInput[]
    deleteMany?: SalesDataScalarWhereInput | SalesDataScalarWhereInput[]
  }

  export type ProductDataUncheckedUpdateManyWithoutImport_batchNestedInput = {
    create?: XOR<ProductDataCreateWithoutImport_batchInput, ProductDataUncheckedCreateWithoutImport_batchInput> | ProductDataCreateWithoutImport_batchInput[] | ProductDataUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: ProductDataCreateOrConnectWithoutImport_batchInput | ProductDataCreateOrConnectWithoutImport_batchInput[]
    upsert?: ProductDataUpsertWithWhereUniqueWithoutImport_batchInput | ProductDataUpsertWithWhereUniqueWithoutImport_batchInput[]
    createMany?: ProductDataCreateManyImport_batchInputEnvelope
    set?: ProductDataWhereUniqueInput | ProductDataWhereUniqueInput[]
    disconnect?: ProductDataWhereUniqueInput | ProductDataWhereUniqueInput[]
    delete?: ProductDataWhereUniqueInput | ProductDataWhereUniqueInput[]
    connect?: ProductDataWhereUniqueInput | ProductDataWhereUniqueInput[]
    update?: ProductDataUpdateWithWhereUniqueWithoutImport_batchInput | ProductDataUpdateWithWhereUniqueWithoutImport_batchInput[]
    updateMany?: ProductDataUpdateManyWithWhereWithoutImport_batchInput | ProductDataUpdateManyWithWhereWithoutImport_batchInput[]
    deleteMany?: ProductDataScalarWhereInput | ProductDataScalarWhereInput[]
  }

  export type StockDataUncheckedUpdateManyWithoutImport_batchNestedInput = {
    create?: XOR<StockDataCreateWithoutImport_batchInput, StockDataUncheckedCreateWithoutImport_batchInput> | StockDataCreateWithoutImport_batchInput[] | StockDataUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: StockDataCreateOrConnectWithoutImport_batchInput | StockDataCreateOrConnectWithoutImport_batchInput[]
    upsert?: StockDataUpsertWithWhereUniqueWithoutImport_batchInput | StockDataUpsertWithWhereUniqueWithoutImport_batchInput[]
    createMany?: StockDataCreateManyImport_batchInputEnvelope
    set?: StockDataWhereUniqueInput | StockDataWhereUniqueInput[]
    disconnect?: StockDataWhereUniqueInput | StockDataWhereUniqueInput[]
    delete?: StockDataWhereUniqueInput | StockDataWhereUniqueInput[]
    connect?: StockDataWhereUniqueInput | StockDataWhereUniqueInput[]
    update?: StockDataUpdateWithWhereUniqueWithoutImport_batchInput | StockDataUpdateWithWhereUniqueWithoutImport_batchInput[]
    updateMany?: StockDataUpdateManyWithWhereWithoutImport_batchInput | StockDataUpdateManyWithWhereWithoutImport_batchInput[]
    deleteMany?: StockDataScalarWhereInput | StockDataScalarWhereInput[]
  }

  export type AdvertisingDataUncheckedUpdateManyWithoutImport_batchNestedInput = {
    create?: XOR<AdvertisingDataCreateWithoutImport_batchInput, AdvertisingDataUncheckedCreateWithoutImport_batchInput> | AdvertisingDataCreateWithoutImport_batchInput[] | AdvertisingDataUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: AdvertisingDataCreateOrConnectWithoutImport_batchInput | AdvertisingDataCreateOrConnectWithoutImport_batchInput[]
    upsert?: AdvertisingDataUpsertWithWhereUniqueWithoutImport_batchInput | AdvertisingDataUpsertWithWhereUniqueWithoutImport_batchInput[]
    createMany?: AdvertisingDataCreateManyImport_batchInputEnvelope
    set?: AdvertisingDataWhereUniqueInput | AdvertisingDataWhereUniqueInput[]
    disconnect?: AdvertisingDataWhereUniqueInput | AdvertisingDataWhereUniqueInput[]
    delete?: AdvertisingDataWhereUniqueInput | AdvertisingDataWhereUniqueInput[]
    connect?: AdvertisingDataWhereUniqueInput | AdvertisingDataWhereUniqueInput[]
    update?: AdvertisingDataUpdateWithWhereUniqueWithoutImport_batchInput | AdvertisingDataUpdateWithWhereUniqueWithoutImport_batchInput[]
    updateMany?: AdvertisingDataUpdateManyWithWhereWithoutImport_batchInput | AdvertisingDataUpdateManyWithWhereWithoutImport_batchInput[]
    deleteMany?: AdvertisingDataScalarWhereInput | AdvertisingDataScalarWhereInput[]
  }

  export type AdvertisingSettlementUncheckedUpdateManyWithoutImport_batchNestedInput = {
    create?: XOR<AdvertisingSettlementCreateWithoutImport_batchInput, AdvertisingSettlementUncheckedCreateWithoutImport_batchInput> | AdvertisingSettlementCreateWithoutImport_batchInput[] | AdvertisingSettlementUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: AdvertisingSettlementCreateOrConnectWithoutImport_batchInput | AdvertisingSettlementCreateOrConnectWithoutImport_batchInput[]
    upsert?: AdvertisingSettlementUpsertWithWhereUniqueWithoutImport_batchInput | AdvertisingSettlementUpsertWithWhereUniqueWithoutImport_batchInput[]
    createMany?: AdvertisingSettlementCreateManyImport_batchInputEnvelope
    set?: AdvertisingSettlementWhereUniqueInput | AdvertisingSettlementWhereUniqueInput[]
    disconnect?: AdvertisingSettlementWhereUniqueInput | AdvertisingSettlementWhereUniqueInput[]
    delete?: AdvertisingSettlementWhereUniqueInput | AdvertisingSettlementWhereUniqueInput[]
    connect?: AdvertisingSettlementWhereUniqueInput | AdvertisingSettlementWhereUniqueInput[]
    update?: AdvertisingSettlementUpdateWithWhereUniqueWithoutImport_batchInput | AdvertisingSettlementUpdateWithWhereUniqueWithoutImport_batchInput[]
    updateMany?: AdvertisingSettlementUpdateManyWithWhereWithoutImport_batchInput | AdvertisingSettlementUpdateManyWithWhereWithoutImport_batchInput[]
    deleteMany?: AdvertisingSettlementScalarWhereInput | AdvertisingSettlementScalarWhereInput[]
  }

  export type ReturnsAndCancellationsUncheckedUpdateManyWithoutImport_batchNestedInput = {
    create?: XOR<ReturnsAndCancellationsCreateWithoutImport_batchInput, ReturnsAndCancellationsUncheckedCreateWithoutImport_batchInput> | ReturnsAndCancellationsCreateWithoutImport_batchInput[] | ReturnsAndCancellationsUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: ReturnsAndCancellationsCreateOrConnectWithoutImport_batchInput | ReturnsAndCancellationsCreateOrConnectWithoutImport_batchInput[]
    upsert?: ReturnsAndCancellationsUpsertWithWhereUniqueWithoutImport_batchInput | ReturnsAndCancellationsUpsertWithWhereUniqueWithoutImport_batchInput[]
    createMany?: ReturnsAndCancellationsCreateManyImport_batchInputEnvelope
    set?: ReturnsAndCancellationsWhereUniqueInput | ReturnsAndCancellationsWhereUniqueInput[]
    disconnect?: ReturnsAndCancellationsWhereUniqueInput | ReturnsAndCancellationsWhereUniqueInput[]
    delete?: ReturnsAndCancellationsWhereUniqueInput | ReturnsAndCancellationsWhereUniqueInput[]
    connect?: ReturnsAndCancellationsWhereUniqueInput | ReturnsAndCancellationsWhereUniqueInput[]
    update?: ReturnsAndCancellationsUpdateWithWhereUniqueWithoutImport_batchInput | ReturnsAndCancellationsUpdateWithWhereUniqueWithoutImport_batchInput[]
    updateMany?: ReturnsAndCancellationsUpdateManyWithWhereWithoutImport_batchInput | ReturnsAndCancellationsUpdateManyWithWhereWithoutImport_batchInput[]
    deleteMany?: ReturnsAndCancellationsScalarWhereInput | ReturnsAndCancellationsScalarWhereInput[]
  }

  export type MarketplaceReimbursementUncheckedUpdateManyWithoutImport_batchNestedInput = {
    create?: XOR<MarketplaceReimbursementCreateWithoutImport_batchInput, MarketplaceReimbursementUncheckedCreateWithoutImport_batchInput> | MarketplaceReimbursementCreateWithoutImport_batchInput[] | MarketplaceReimbursementUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: MarketplaceReimbursementCreateOrConnectWithoutImport_batchInput | MarketplaceReimbursementCreateOrConnectWithoutImport_batchInput[]
    upsert?: MarketplaceReimbursementUpsertWithWhereUniqueWithoutImport_batchInput | MarketplaceReimbursementUpsertWithWhereUniqueWithoutImport_batchInput[]
    createMany?: MarketplaceReimbursementCreateManyImport_batchInputEnvelope
    set?: MarketplaceReimbursementWhereUniqueInput | MarketplaceReimbursementWhereUniqueInput[]
    disconnect?: MarketplaceReimbursementWhereUniqueInput | MarketplaceReimbursementWhereUniqueInput[]
    delete?: MarketplaceReimbursementWhereUniqueInput | MarketplaceReimbursementWhereUniqueInput[]
    connect?: MarketplaceReimbursementWhereUniqueInput | MarketplaceReimbursementWhereUniqueInput[]
    update?: MarketplaceReimbursementUpdateWithWhereUniqueWithoutImport_batchInput | MarketplaceReimbursementUpdateWithWhereUniqueWithoutImport_batchInput[]
    updateMany?: MarketplaceReimbursementUpdateManyWithWhereWithoutImport_batchInput | MarketplaceReimbursementUpdateManyWithWhereWithoutImport_batchInput[]
    deleteMany?: MarketplaceReimbursementScalarWhereInput | MarketplaceReimbursementScalarWhereInput[]
  }

  export type CommissionAdjustmentsUncheckedUpdateManyWithoutImport_batchNestedInput = {
    create?: XOR<CommissionAdjustmentsCreateWithoutImport_batchInput, CommissionAdjustmentsUncheckedCreateWithoutImport_batchInput> | CommissionAdjustmentsCreateWithoutImport_batchInput[] | CommissionAdjustmentsUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: CommissionAdjustmentsCreateOrConnectWithoutImport_batchInput | CommissionAdjustmentsCreateOrConnectWithoutImport_batchInput[]
    upsert?: CommissionAdjustmentsUpsertWithWhereUniqueWithoutImport_batchInput | CommissionAdjustmentsUpsertWithWhereUniqueWithoutImport_batchInput[]
    createMany?: CommissionAdjustmentsCreateManyImport_batchInputEnvelope
    set?: CommissionAdjustmentsWhereUniqueInput | CommissionAdjustmentsWhereUniqueInput[]
    disconnect?: CommissionAdjustmentsWhereUniqueInput | CommissionAdjustmentsWhereUniqueInput[]
    delete?: CommissionAdjustmentsWhereUniqueInput | CommissionAdjustmentsWhereUniqueInput[]
    connect?: CommissionAdjustmentsWhereUniqueInput | CommissionAdjustmentsWhereUniqueInput[]
    update?: CommissionAdjustmentsUpdateWithWhereUniqueWithoutImport_batchInput | CommissionAdjustmentsUpdateWithWhereUniqueWithoutImport_batchInput[]
    updateMany?: CommissionAdjustmentsUpdateManyWithWhereWithoutImport_batchInput | CommissionAdjustmentsUpdateManyWithWhereWithoutImport_batchInput[]
    deleteMany?: CommissionAdjustmentsScalarWhereInput | CommissionAdjustmentsScalarWhereInput[]
  }

  export type AffiliateSamplesUncheckedUpdateManyWithoutImport_batchNestedInput = {
    create?: XOR<AffiliateSamplesCreateWithoutImport_batchInput, AffiliateSamplesUncheckedCreateWithoutImport_batchInput> | AffiliateSamplesCreateWithoutImport_batchInput[] | AffiliateSamplesUncheckedCreateWithoutImport_batchInput[]
    connectOrCreate?: AffiliateSamplesCreateOrConnectWithoutImport_batchInput | AffiliateSamplesCreateOrConnectWithoutImport_batchInput[]
    upsert?: AffiliateSamplesUpsertWithWhereUniqueWithoutImport_batchInput | AffiliateSamplesUpsertWithWhereUniqueWithoutImport_batchInput[]
    createMany?: AffiliateSamplesCreateManyImport_batchInputEnvelope
    set?: AffiliateSamplesWhereUniqueInput | AffiliateSamplesWhereUniqueInput[]
    disconnect?: AffiliateSamplesWhereUniqueInput | AffiliateSamplesWhereUniqueInput[]
    delete?: AffiliateSamplesWhereUniqueInput | AffiliateSamplesWhereUniqueInput[]
    connect?: AffiliateSamplesWhereUniqueInput | AffiliateSamplesWhereUniqueInput[]
    update?: AffiliateSamplesUpdateWithWhereUniqueWithoutImport_batchInput | AffiliateSamplesUpdateWithWhereUniqueWithoutImport_batchInput[]
    updateMany?: AffiliateSamplesUpdateManyWithWhereWithoutImport_batchInput | AffiliateSamplesUpdateManyWithWhereWithoutImport_batchInput[]
    deleteMany?: AffiliateSamplesScalarWhereInput | AffiliateSamplesScalarWhereInput[]
  }

  export type ImportBatchCreateNestedOneWithoutAdvertising_dataInput = {
    create?: XOR<ImportBatchCreateWithoutAdvertising_dataInput, ImportBatchUncheckedCreateWithoutAdvertising_dataInput>
    connectOrCreate?: ImportBatchCreateOrConnectWithoutAdvertising_dataInput
    connect?: ImportBatchWhereUniqueInput
  }

  export type ImportBatchUpdateOneWithoutAdvertising_dataNestedInput = {
    create?: XOR<ImportBatchCreateWithoutAdvertising_dataInput, ImportBatchUncheckedCreateWithoutAdvertising_dataInput>
    connectOrCreate?: ImportBatchCreateOrConnectWithoutAdvertising_dataInput
    upsert?: ImportBatchUpsertWithoutAdvertising_dataInput
    disconnect?: ImportBatchWhereInput | boolean
    delete?: ImportBatchWhereInput | boolean
    connect?: ImportBatchWhereUniqueInput
    update?: XOR<XOR<ImportBatchUpdateToOneWithWhereWithoutAdvertising_dataInput, ImportBatchUpdateWithoutAdvertising_dataInput>, ImportBatchUncheckedUpdateWithoutAdvertising_dataInput>
  }

  export type ImportBatchCreateNestedOneWithoutAdvertising_settlementInput = {
    create?: XOR<ImportBatchCreateWithoutAdvertising_settlementInput, ImportBatchUncheckedCreateWithoutAdvertising_settlementInput>
    connectOrCreate?: ImportBatchCreateOrConnectWithoutAdvertising_settlementInput
    connect?: ImportBatchWhereUniqueInput
  }

  export type ImportBatchUpdateOneWithoutAdvertising_settlementNestedInput = {
    create?: XOR<ImportBatchCreateWithoutAdvertising_settlementInput, ImportBatchUncheckedCreateWithoutAdvertising_settlementInput>
    connectOrCreate?: ImportBatchCreateOrConnectWithoutAdvertising_settlementInput
    upsert?: ImportBatchUpsertWithoutAdvertising_settlementInput
    disconnect?: ImportBatchWhereInput | boolean
    delete?: ImportBatchWhereInput | boolean
    connect?: ImportBatchWhereUniqueInput
    update?: XOR<XOR<ImportBatchUpdateToOneWithWhereWithoutAdvertising_settlementInput, ImportBatchUpdateWithoutAdvertising_settlementInput>, ImportBatchUncheckedUpdateWithoutAdvertising_settlementInput>
  }

  export type ImportBatchCreateNestedOneWithoutReturns_and_cancellationsInput = {
    create?: XOR<ImportBatchCreateWithoutReturns_and_cancellationsInput, ImportBatchUncheckedCreateWithoutReturns_and_cancellationsInput>
    connectOrCreate?: ImportBatchCreateOrConnectWithoutReturns_and_cancellationsInput
    connect?: ImportBatchWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ImportBatchUpdateOneWithoutReturns_and_cancellationsNestedInput = {
    create?: XOR<ImportBatchCreateWithoutReturns_and_cancellationsInput, ImportBatchUncheckedCreateWithoutReturns_and_cancellationsInput>
    connectOrCreate?: ImportBatchCreateOrConnectWithoutReturns_and_cancellationsInput
    upsert?: ImportBatchUpsertWithoutReturns_and_cancellationsInput
    disconnect?: ImportBatchWhereInput | boolean
    delete?: ImportBatchWhereInput | boolean
    connect?: ImportBatchWhereUniqueInput
    update?: XOR<XOR<ImportBatchUpdateToOneWithWhereWithoutReturns_and_cancellationsInput, ImportBatchUpdateWithoutReturns_and_cancellationsInput>, ImportBatchUncheckedUpdateWithoutReturns_and_cancellationsInput>
  }

  export type ImportBatchCreateNestedOneWithoutMarketplace_reimbursementsInput = {
    create?: XOR<ImportBatchCreateWithoutMarketplace_reimbursementsInput, ImportBatchUncheckedCreateWithoutMarketplace_reimbursementsInput>
    connectOrCreate?: ImportBatchCreateOrConnectWithoutMarketplace_reimbursementsInput
    connect?: ImportBatchWhereUniqueInput
  }

  export type ImportBatchUpdateOneWithoutMarketplace_reimbursementsNestedInput = {
    create?: XOR<ImportBatchCreateWithoutMarketplace_reimbursementsInput, ImportBatchUncheckedCreateWithoutMarketplace_reimbursementsInput>
    connectOrCreate?: ImportBatchCreateOrConnectWithoutMarketplace_reimbursementsInput
    upsert?: ImportBatchUpsertWithoutMarketplace_reimbursementsInput
    disconnect?: ImportBatchWhereInput | boolean
    delete?: ImportBatchWhereInput | boolean
    connect?: ImportBatchWhereUniqueInput
    update?: XOR<XOR<ImportBatchUpdateToOneWithWhereWithoutMarketplace_reimbursementsInput, ImportBatchUpdateWithoutMarketplace_reimbursementsInput>, ImportBatchUncheckedUpdateWithoutMarketplace_reimbursementsInput>
  }

  export type ImportBatchCreateNestedOneWithoutCommission_adjustmentsInput = {
    create?: XOR<ImportBatchCreateWithoutCommission_adjustmentsInput, ImportBatchUncheckedCreateWithoutCommission_adjustmentsInput>
    connectOrCreate?: ImportBatchCreateOrConnectWithoutCommission_adjustmentsInput
    connect?: ImportBatchWhereUniqueInput
  }

  export type ImportBatchUpdateOneWithoutCommission_adjustmentsNestedInput = {
    create?: XOR<ImportBatchCreateWithoutCommission_adjustmentsInput, ImportBatchUncheckedCreateWithoutCommission_adjustmentsInput>
    connectOrCreate?: ImportBatchCreateOrConnectWithoutCommission_adjustmentsInput
    upsert?: ImportBatchUpsertWithoutCommission_adjustmentsInput
    disconnect?: ImportBatchWhereInput | boolean
    delete?: ImportBatchWhereInput | boolean
    connect?: ImportBatchWhereUniqueInput
    update?: XOR<XOR<ImportBatchUpdateToOneWithWhereWithoutCommission_adjustmentsInput, ImportBatchUpdateWithoutCommission_adjustmentsInput>, ImportBatchUncheckedUpdateWithoutCommission_adjustmentsInput>
  }

  export type ImportBatchCreateNestedOneWithoutAffiliate_samplesInput = {
    create?: XOR<ImportBatchCreateWithoutAffiliate_samplesInput, ImportBatchUncheckedCreateWithoutAffiliate_samplesInput>
    connectOrCreate?: ImportBatchCreateOrConnectWithoutAffiliate_samplesInput
    connect?: ImportBatchWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ImportBatchUpdateOneWithoutAffiliate_samplesNestedInput = {
    create?: XOR<ImportBatchCreateWithoutAffiliate_samplesInput, ImportBatchUncheckedCreateWithoutAffiliate_samplesInput>
    connectOrCreate?: ImportBatchCreateOrConnectWithoutAffiliate_samplesInput
    upsert?: ImportBatchUpsertWithoutAffiliate_samplesInput
    disconnect?: ImportBatchWhereInput | boolean
    delete?: ImportBatchWhereInput | boolean
    connect?: ImportBatchWhereUniqueInput
    update?: XOR<XOR<ImportBatchUpdateToOneWithWhereWithoutAffiliate_samplesInput, ImportBatchUpdateWithoutAffiliate_samplesInput>, ImportBatchUncheckedUpdateWithoutAffiliate_samplesInput>
  }

  export type PurchaseOrderCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type EnumSupplierStatusFieldUpdateOperationsInput = {
    set?: $Enums.SupplierStatus
  }

  export type PurchaseOrderUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutSupplierInput | PurchaseOrderUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutSupplierInput | PurchaseOrderUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type SupplierCreateNestedOneWithoutPurchase_ordersInput = {
    create?: XOR<SupplierCreateWithoutPurchase_ordersInput, SupplierUncheckedCreateWithoutPurchase_ordersInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchase_ordersInput
    connect?: SupplierWhereUniqueInput
  }

  export type PurchaseOrderItemCreateNestedManyWithoutPurchase_orderInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchase_orderInput, PurchaseOrderItemUncheckedCreateWithoutPurchase_orderInput> | PurchaseOrderItemCreateWithoutPurchase_orderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchase_orderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchase_orderInput | PurchaseOrderItemCreateOrConnectWithoutPurchase_orderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchase_orderInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchase_orderInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchase_orderInput, PurchaseOrderItemUncheckedCreateWithoutPurchase_orderInput> | PurchaseOrderItemCreateWithoutPurchase_orderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchase_orderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchase_orderInput | PurchaseOrderItemCreateOrConnectWithoutPurchase_orderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchase_orderInputEnvelope
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
  }

  export type EnumPOStatusFieldUpdateOperationsInput = {
    set?: $Enums.POStatus
  }

  export type SupplierUpdateOneRequiredWithoutPurchase_ordersNestedInput = {
    create?: XOR<SupplierCreateWithoutPurchase_ordersInput, SupplierUncheckedCreateWithoutPurchase_ordersInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchase_ordersInput
    upsert?: SupplierUpsertWithoutPurchase_ordersInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutPurchase_ordersInput, SupplierUpdateWithoutPurchase_ordersInput>, SupplierUncheckedUpdateWithoutPurchase_ordersInput>
  }

  export type PurchaseOrderItemUpdateManyWithoutPurchase_orderNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchase_orderInput, PurchaseOrderItemUncheckedCreateWithoutPurchase_orderInput> | PurchaseOrderItemCreateWithoutPurchase_orderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchase_orderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchase_orderInput | PurchaseOrderItemCreateOrConnectWithoutPurchase_orderInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchase_orderInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchase_orderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchase_orderInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchase_orderInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchase_orderInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutPurchase_orderInput | PurchaseOrderItemUpdateManyWithWhereWithoutPurchase_orderInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutPurchase_orderNestedInput = {
    create?: XOR<PurchaseOrderItemCreateWithoutPurchase_orderInput, PurchaseOrderItemUncheckedCreateWithoutPurchase_orderInput> | PurchaseOrderItemCreateWithoutPurchase_orderInput[] | PurchaseOrderItemUncheckedCreateWithoutPurchase_orderInput[]
    connectOrCreate?: PurchaseOrderItemCreateOrConnectWithoutPurchase_orderInput | PurchaseOrderItemCreateOrConnectWithoutPurchase_orderInput[]
    upsert?: PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchase_orderInput | PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchase_orderInput[]
    createMany?: PurchaseOrderItemCreateManyPurchase_orderInputEnvelope
    set?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    disconnect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    delete?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    connect?: PurchaseOrderItemWhereUniqueInput | PurchaseOrderItemWhereUniqueInput[]
    update?: PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchase_orderInput | PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchase_orderInput[]
    updateMany?: PurchaseOrderItemUpdateManyWithWhereWithoutPurchase_orderInput | PurchaseOrderItemUpdateManyWithWhereWithoutPurchase_orderInput[]
    deleteMany?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
  }

  export type PurchaseOrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutItemsInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type PurchaseOrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutItemsInput
    upsert?: PurchaseOrderUpsertWithoutItemsInput
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderUpdateToOneWithWhereWithoutItemsInput, PurchaseOrderUpdateWithoutItemsInput>, PurchaseOrderUncheckedUpdateWithoutItemsInput>
  }

  export type EnumCashFlowTypeFieldUpdateOperationsInput = {
    set?: $Enums.CashFlowType
  }

  export type ImportMetadataCreateNestedManyWithoutImport_historyInput = {
    create?: XOR<ImportMetadataCreateWithoutImport_historyInput, ImportMetadataUncheckedCreateWithoutImport_historyInput> | ImportMetadataCreateWithoutImport_historyInput[] | ImportMetadataUncheckedCreateWithoutImport_historyInput[]
    connectOrCreate?: ImportMetadataCreateOrConnectWithoutImport_historyInput | ImportMetadataCreateOrConnectWithoutImport_historyInput[]
    createMany?: ImportMetadataCreateManyImport_historyInputEnvelope
    connect?: ImportMetadataWhereUniqueInput | ImportMetadataWhereUniqueInput[]
  }

  export type ImportMetadataUncheckedCreateNestedManyWithoutImport_historyInput = {
    create?: XOR<ImportMetadataCreateWithoutImport_historyInput, ImportMetadataUncheckedCreateWithoutImport_historyInput> | ImportMetadataCreateWithoutImport_historyInput[] | ImportMetadataUncheckedCreateWithoutImport_historyInput[]
    connectOrCreate?: ImportMetadataCreateOrConnectWithoutImport_historyInput | ImportMetadataCreateOrConnectWithoutImport_historyInput[]
    createMany?: ImportMetadataCreateManyImport_historyInputEnvelope
    connect?: ImportMetadataWhereUniqueInput | ImportMetadataWhereUniqueInput[]
  }

  export type EnumImportHistoryStatusFieldUpdateOperationsInput = {
    set?: $Enums.ImportHistoryStatus
  }

  export type ImportMetadataUpdateManyWithoutImport_historyNestedInput = {
    create?: XOR<ImportMetadataCreateWithoutImport_historyInput, ImportMetadataUncheckedCreateWithoutImport_historyInput> | ImportMetadataCreateWithoutImport_historyInput[] | ImportMetadataUncheckedCreateWithoutImport_historyInput[]
    connectOrCreate?: ImportMetadataCreateOrConnectWithoutImport_historyInput | ImportMetadataCreateOrConnectWithoutImport_historyInput[]
    upsert?: ImportMetadataUpsertWithWhereUniqueWithoutImport_historyInput | ImportMetadataUpsertWithWhereUniqueWithoutImport_historyInput[]
    createMany?: ImportMetadataCreateManyImport_historyInputEnvelope
    set?: ImportMetadataWhereUniqueInput | ImportMetadataWhereUniqueInput[]
    disconnect?: ImportMetadataWhereUniqueInput | ImportMetadataWhereUniqueInput[]
    delete?: ImportMetadataWhereUniqueInput | ImportMetadataWhereUniqueInput[]
    connect?: ImportMetadataWhereUniqueInput | ImportMetadataWhereUniqueInput[]
    update?: ImportMetadataUpdateWithWhereUniqueWithoutImport_historyInput | ImportMetadataUpdateWithWhereUniqueWithoutImport_historyInput[]
    updateMany?: ImportMetadataUpdateManyWithWhereWithoutImport_historyInput | ImportMetadataUpdateManyWithWhereWithoutImport_historyInput[]
    deleteMany?: ImportMetadataScalarWhereInput | ImportMetadataScalarWhereInput[]
  }

  export type ImportMetadataUncheckedUpdateManyWithoutImport_historyNestedInput = {
    create?: XOR<ImportMetadataCreateWithoutImport_historyInput, ImportMetadataUncheckedCreateWithoutImport_historyInput> | ImportMetadataCreateWithoutImport_historyInput[] | ImportMetadataUncheckedCreateWithoutImport_historyInput[]
    connectOrCreate?: ImportMetadataCreateOrConnectWithoutImport_historyInput | ImportMetadataCreateOrConnectWithoutImport_historyInput[]
    upsert?: ImportMetadataUpsertWithWhereUniqueWithoutImport_historyInput | ImportMetadataUpsertWithWhereUniqueWithoutImport_historyInput[]
    createMany?: ImportMetadataCreateManyImport_historyInputEnvelope
    set?: ImportMetadataWhereUniqueInput | ImportMetadataWhereUniqueInput[]
    disconnect?: ImportMetadataWhereUniqueInput | ImportMetadataWhereUniqueInput[]
    delete?: ImportMetadataWhereUniqueInput | ImportMetadataWhereUniqueInput[]
    connect?: ImportMetadataWhereUniqueInput | ImportMetadataWhereUniqueInput[]
    update?: ImportMetadataUpdateWithWhereUniqueWithoutImport_historyInput | ImportMetadataUpdateWithWhereUniqueWithoutImport_historyInput[]
    updateMany?: ImportMetadataUpdateManyWithWhereWithoutImport_historyInput | ImportMetadataUpdateManyWithWhereWithoutImport_historyInput[]
    deleteMany?: ImportMetadataScalarWhereInput | ImportMetadataScalarWhereInput[]
  }

  export type InvoiceItemCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type EnumInvoiceTypeFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceType
  }

  export type InvoiceItemUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    upsert?: InvoiceUpsertWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutItemsInput, InvoiceUpdateWithoutItemsInput>, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type AffiliateEndorsementCreateplatformInput = {
    set: string[]
  }

  export type AffiliateProductSaleCreateNestedManyWithoutEndorsementInput = {
    create?: XOR<AffiliateProductSaleCreateWithoutEndorsementInput, AffiliateProductSaleUncheckedCreateWithoutEndorsementInput> | AffiliateProductSaleCreateWithoutEndorsementInput[] | AffiliateProductSaleUncheckedCreateWithoutEndorsementInput[]
    connectOrCreate?: AffiliateProductSaleCreateOrConnectWithoutEndorsementInput | AffiliateProductSaleCreateOrConnectWithoutEndorsementInput[]
    createMany?: AffiliateProductSaleCreateManyEndorsementInputEnvelope
    connect?: AffiliateProductSaleWhereUniqueInput | AffiliateProductSaleWhereUniqueInput[]
  }

  export type AffiliateProductSaleUncheckedCreateNestedManyWithoutEndorsementInput = {
    create?: XOR<AffiliateProductSaleCreateWithoutEndorsementInput, AffiliateProductSaleUncheckedCreateWithoutEndorsementInput> | AffiliateProductSaleCreateWithoutEndorsementInput[] | AffiliateProductSaleUncheckedCreateWithoutEndorsementInput[]
    connectOrCreate?: AffiliateProductSaleCreateOrConnectWithoutEndorsementInput | AffiliateProductSaleCreateOrConnectWithoutEndorsementInput[]
    createMany?: AffiliateProductSaleCreateManyEndorsementInputEnvelope
    connect?: AffiliateProductSaleWhereUniqueInput | AffiliateProductSaleWhereUniqueInput[]
  }

  export type AffiliateEndorsementUpdateplatformInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AffiliateProductSaleUpdateManyWithoutEndorsementNestedInput = {
    create?: XOR<AffiliateProductSaleCreateWithoutEndorsementInput, AffiliateProductSaleUncheckedCreateWithoutEndorsementInput> | AffiliateProductSaleCreateWithoutEndorsementInput[] | AffiliateProductSaleUncheckedCreateWithoutEndorsementInput[]
    connectOrCreate?: AffiliateProductSaleCreateOrConnectWithoutEndorsementInput | AffiliateProductSaleCreateOrConnectWithoutEndorsementInput[]
    upsert?: AffiliateProductSaleUpsertWithWhereUniqueWithoutEndorsementInput | AffiliateProductSaleUpsertWithWhereUniqueWithoutEndorsementInput[]
    createMany?: AffiliateProductSaleCreateManyEndorsementInputEnvelope
    set?: AffiliateProductSaleWhereUniqueInput | AffiliateProductSaleWhereUniqueInput[]
    disconnect?: AffiliateProductSaleWhereUniqueInput | AffiliateProductSaleWhereUniqueInput[]
    delete?: AffiliateProductSaleWhereUniqueInput | AffiliateProductSaleWhereUniqueInput[]
    connect?: AffiliateProductSaleWhereUniqueInput | AffiliateProductSaleWhereUniqueInput[]
    update?: AffiliateProductSaleUpdateWithWhereUniqueWithoutEndorsementInput | AffiliateProductSaleUpdateWithWhereUniqueWithoutEndorsementInput[]
    updateMany?: AffiliateProductSaleUpdateManyWithWhereWithoutEndorsementInput | AffiliateProductSaleUpdateManyWithWhereWithoutEndorsementInput[]
    deleteMany?: AffiliateProductSaleScalarWhereInput | AffiliateProductSaleScalarWhereInput[]
  }

  export type AffiliateProductSaleUncheckedUpdateManyWithoutEndorsementNestedInput = {
    create?: XOR<AffiliateProductSaleCreateWithoutEndorsementInput, AffiliateProductSaleUncheckedCreateWithoutEndorsementInput> | AffiliateProductSaleCreateWithoutEndorsementInput[] | AffiliateProductSaleUncheckedCreateWithoutEndorsementInput[]
    connectOrCreate?: AffiliateProductSaleCreateOrConnectWithoutEndorsementInput | AffiliateProductSaleCreateOrConnectWithoutEndorsementInput[]
    upsert?: AffiliateProductSaleUpsertWithWhereUniqueWithoutEndorsementInput | AffiliateProductSaleUpsertWithWhereUniqueWithoutEndorsementInput[]
    createMany?: AffiliateProductSaleCreateManyEndorsementInputEnvelope
    set?: AffiliateProductSaleWhereUniqueInput | AffiliateProductSaleWhereUniqueInput[]
    disconnect?: AffiliateProductSaleWhereUniqueInput | AffiliateProductSaleWhereUniqueInput[]
    delete?: AffiliateProductSaleWhereUniqueInput | AffiliateProductSaleWhereUniqueInput[]
    connect?: AffiliateProductSaleWhereUniqueInput | AffiliateProductSaleWhereUniqueInput[]
    update?: AffiliateProductSaleUpdateWithWhereUniqueWithoutEndorsementInput | AffiliateProductSaleUpdateWithWhereUniqueWithoutEndorsementInput[]
    updateMany?: AffiliateProductSaleUpdateManyWithWhereWithoutEndorsementInput | AffiliateProductSaleUpdateManyWithWhereWithoutEndorsementInput[]
    deleteMany?: AffiliateProductSaleScalarWhereInput | AffiliateProductSaleScalarWhereInput[]
  }

  export type AffiliateEndorsementCreateNestedOneWithoutProduct_salesInput = {
    create?: XOR<AffiliateEndorsementCreateWithoutProduct_salesInput, AffiliateEndorsementUncheckedCreateWithoutProduct_salesInput>
    connectOrCreate?: AffiliateEndorsementCreateOrConnectWithoutProduct_salesInput
    connect?: AffiliateEndorsementWhereUniqueInput
  }

  export type AffiliateEndorsementUpdateOneRequiredWithoutProduct_salesNestedInput = {
    create?: XOR<AffiliateEndorsementCreateWithoutProduct_salesInput, AffiliateEndorsementUncheckedCreateWithoutProduct_salesInput>
    connectOrCreate?: AffiliateEndorsementCreateOrConnectWithoutProduct_salesInput
    upsert?: AffiliateEndorsementUpsertWithoutProduct_salesInput
    connect?: AffiliateEndorsementWhereUniqueInput
    update?: XOR<XOR<AffiliateEndorsementUpdateToOneWithWhereWithoutProduct_salesInput, AffiliateEndorsementUpdateWithoutProduct_salesInput>, AffiliateEndorsementUncheckedUpdateWithoutProduct_salesInput>
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type ImportHistoryCreateNestedOneWithoutImportMetadataInput = {
    create?: XOR<ImportHistoryCreateWithoutImportMetadataInput, ImportHistoryUncheckedCreateWithoutImportMetadataInput>
    connectOrCreate?: ImportHistoryCreateOrConnectWithoutImportMetadataInput
    connect?: ImportHistoryWhereUniqueInput
  }

  export type ImportHistoryUpdateOneRequiredWithoutImportMetadataNestedInput = {
    create?: XOR<ImportHistoryCreateWithoutImportMetadataInput, ImportHistoryUncheckedCreateWithoutImportMetadataInput>
    connectOrCreate?: ImportHistoryCreateOrConnectWithoutImportMetadataInput
    upsert?: ImportHistoryUpsertWithoutImportMetadataInput
    connect?: ImportHistoryWhereUniqueInput
    update?: XOR<XOR<ImportHistoryUpdateToOneWithWhereWithoutImportMetadataInput, ImportHistoryUpdateWithoutImportMetadataInput>, ImportHistoryUncheckedUpdateWithoutImportMetadataInput>
  }

  export type TailorProductionCreateNestedManyWithoutTailorInput = {
    create?: XOR<TailorProductionCreateWithoutTailorInput, TailorProductionUncheckedCreateWithoutTailorInput> | TailorProductionCreateWithoutTailorInput[] | TailorProductionUncheckedCreateWithoutTailorInput[]
    connectOrCreate?: TailorProductionCreateOrConnectWithoutTailorInput | TailorProductionCreateOrConnectWithoutTailorInput[]
    createMany?: TailorProductionCreateManyTailorInputEnvelope
    connect?: TailorProductionWhereUniqueInput | TailorProductionWhereUniqueInput[]
  }

  export type TailorProductionUncheckedCreateNestedManyWithoutTailorInput = {
    create?: XOR<TailorProductionCreateWithoutTailorInput, TailorProductionUncheckedCreateWithoutTailorInput> | TailorProductionCreateWithoutTailorInput[] | TailorProductionUncheckedCreateWithoutTailorInput[]
    connectOrCreate?: TailorProductionCreateOrConnectWithoutTailorInput | TailorProductionCreateOrConnectWithoutTailorInput[]
    createMany?: TailorProductionCreateManyTailorInputEnvelope
    connect?: TailorProductionWhereUniqueInput | TailorProductionWhereUniqueInput[]
  }

  export type EnumTailorStatusFieldUpdateOperationsInput = {
    set?: $Enums.TailorStatus
  }

  export type TailorProductionUpdateManyWithoutTailorNestedInput = {
    create?: XOR<TailorProductionCreateWithoutTailorInput, TailorProductionUncheckedCreateWithoutTailorInput> | TailorProductionCreateWithoutTailorInput[] | TailorProductionUncheckedCreateWithoutTailorInput[]
    connectOrCreate?: TailorProductionCreateOrConnectWithoutTailorInput | TailorProductionCreateOrConnectWithoutTailorInput[]
    upsert?: TailorProductionUpsertWithWhereUniqueWithoutTailorInput | TailorProductionUpsertWithWhereUniqueWithoutTailorInput[]
    createMany?: TailorProductionCreateManyTailorInputEnvelope
    set?: TailorProductionWhereUniqueInput | TailorProductionWhereUniqueInput[]
    disconnect?: TailorProductionWhereUniqueInput | TailorProductionWhereUniqueInput[]
    delete?: TailorProductionWhereUniqueInput | TailorProductionWhereUniqueInput[]
    connect?: TailorProductionWhereUniqueInput | TailorProductionWhereUniqueInput[]
    update?: TailorProductionUpdateWithWhereUniqueWithoutTailorInput | TailorProductionUpdateWithWhereUniqueWithoutTailorInput[]
    updateMany?: TailorProductionUpdateManyWithWhereWithoutTailorInput | TailorProductionUpdateManyWithWhereWithoutTailorInput[]
    deleteMany?: TailorProductionScalarWhereInput | TailorProductionScalarWhereInput[]
  }

  export type TailorProductionUncheckedUpdateManyWithoutTailorNestedInput = {
    create?: XOR<TailorProductionCreateWithoutTailorInput, TailorProductionUncheckedCreateWithoutTailorInput> | TailorProductionCreateWithoutTailorInput[] | TailorProductionUncheckedCreateWithoutTailorInput[]
    connectOrCreate?: TailorProductionCreateOrConnectWithoutTailorInput | TailorProductionCreateOrConnectWithoutTailorInput[]
    upsert?: TailorProductionUpsertWithWhereUniqueWithoutTailorInput | TailorProductionUpsertWithWhereUniqueWithoutTailorInput[]
    createMany?: TailorProductionCreateManyTailorInputEnvelope
    set?: TailorProductionWhereUniqueInput | TailorProductionWhereUniqueInput[]
    disconnect?: TailorProductionWhereUniqueInput | TailorProductionWhereUniqueInput[]
    delete?: TailorProductionWhereUniqueInput | TailorProductionWhereUniqueInput[]
    connect?: TailorProductionWhereUniqueInput | TailorProductionWhereUniqueInput[]
    update?: TailorProductionUpdateWithWhereUniqueWithoutTailorInput | TailorProductionUpdateWithWhereUniqueWithoutTailorInput[]
    updateMany?: TailorProductionUpdateManyWithWhereWithoutTailorInput | TailorProductionUpdateManyWithWhereWithoutTailorInput[]
    deleteMany?: TailorProductionScalarWhereInput | TailorProductionScalarWhereInput[]
  }

  export type TailorCreateNestedOneWithoutProductionsInput = {
    create?: XOR<TailorCreateWithoutProductionsInput, TailorUncheckedCreateWithoutProductionsInput>
    connectOrCreate?: TailorCreateOrConnectWithoutProductionsInput
    connect?: TailorWhereUniqueInput
  }

  export type EnumTailorProductionStatusFieldUpdateOperationsInput = {
    set?: $Enums.TailorProductionStatus
  }

  export type TailorUpdateOneRequiredWithoutProductionsNestedInput = {
    create?: XOR<TailorCreateWithoutProductionsInput, TailorUncheckedCreateWithoutProductionsInput>
    connectOrCreate?: TailorCreateOrConnectWithoutProductionsInput
    upsert?: TailorUpsertWithoutProductionsInput
    connect?: TailorWhereUniqueInput
    update?: XOR<XOR<TailorUpdateToOneWithWhereWithoutProductionsInput, TailorUpdateWithoutProductionsInput>, TailorUncheckedUpdateWithoutProductionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumStockMovementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StockMovementType | EnumStockMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StockMovementType[] | ListEnumStockMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StockMovementType[] | ListEnumStockMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStockMovementTypeFilter<$PrismaModel> | $Enums.StockMovementType
  }

  export type NestedEnumStockMovementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StockMovementType | EnumStockMovementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StockMovementType[] | ListEnumStockMovementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StockMovementType[] | ListEnumStockMovementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStockMovementTypeWithAggregatesFilter<$PrismaModel> | $Enums.StockMovementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStockMovementTypeFilter<$PrismaModel>
    _max?: NestedEnumStockMovementTypeFilter<$PrismaModel>
  }

  export type NestedEnumImportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportType | EnumImportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImportType[] | ListEnumImportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportType[] | ListEnumImportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImportTypeFilter<$PrismaModel> | $Enums.ImportType
  }

  export type NestedEnumImportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportStatus | EnumImportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportStatusFilter<$PrismaModel> | $Enums.ImportStatus
  }

  export type NestedEnumImportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportType | EnumImportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ImportType[] | ListEnumImportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportType[] | ListEnumImportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumImportTypeWithAggregatesFilter<$PrismaModel> | $Enums.ImportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImportTypeFilter<$PrismaModel>
    _max?: NestedEnumImportTypeFilter<$PrismaModel>
  }

  export type NestedEnumImportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportStatus | EnumImportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportStatus[] | ListEnumImportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ImportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImportStatusFilter<$PrismaModel>
    _max?: NestedEnumImportStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumSupplierStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SupplierStatus | EnumSupplierStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SupplierStatus[] | ListEnumSupplierStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupplierStatus[] | ListEnumSupplierStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSupplierStatusFilter<$PrismaModel> | $Enums.SupplierStatus
  }

  export type NestedEnumSupplierStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SupplierStatus | EnumSupplierStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SupplierStatus[] | ListEnumSupplierStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupplierStatus[] | ListEnumSupplierStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSupplierStatusWithAggregatesFilter<$PrismaModel> | $Enums.SupplierStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSupplierStatusFilter<$PrismaModel>
    _max?: NestedEnumSupplierStatusFilter<$PrismaModel>
  }

  export type NestedEnumPOStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.POStatus | EnumPOStatusFieldRefInput<$PrismaModel>
    in?: $Enums.POStatus[] | ListEnumPOStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.POStatus[] | ListEnumPOStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPOStatusFilter<$PrismaModel> | $Enums.POStatus
  }

  export type NestedEnumPOStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.POStatus | EnumPOStatusFieldRefInput<$PrismaModel>
    in?: $Enums.POStatus[] | ListEnumPOStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.POStatus[] | ListEnumPOStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPOStatusWithAggregatesFilter<$PrismaModel> | $Enums.POStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPOStatusFilter<$PrismaModel>
    _max?: NestedEnumPOStatusFilter<$PrismaModel>
  }

  export type NestedEnumCashFlowTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CashFlowType | EnumCashFlowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CashFlowType[] | ListEnumCashFlowTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CashFlowType[] | ListEnumCashFlowTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCashFlowTypeFilter<$PrismaModel> | $Enums.CashFlowType
  }

  export type NestedEnumCashFlowTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CashFlowType | EnumCashFlowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CashFlowType[] | ListEnumCashFlowTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CashFlowType[] | ListEnumCashFlowTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCashFlowTypeWithAggregatesFilter<$PrismaModel> | $Enums.CashFlowType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCashFlowTypeFilter<$PrismaModel>
    _max?: NestedEnumCashFlowTypeFilter<$PrismaModel>
  }

  export type NestedEnumImportHistoryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportHistoryStatus | EnumImportHistoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportHistoryStatus[] | ListEnumImportHistoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportHistoryStatus[] | ListEnumImportHistoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportHistoryStatusFilter<$PrismaModel> | $Enums.ImportHistoryStatus
  }

  export type NestedEnumImportHistoryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportHistoryStatus | EnumImportHistoryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportHistoryStatus[] | ListEnumImportHistoryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ImportHistoryStatus[] | ListEnumImportHistoryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumImportHistoryStatusWithAggregatesFilter<$PrismaModel> | $Enums.ImportHistoryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImportHistoryStatusFilter<$PrismaModel>
    _max?: NestedEnumImportHistoryStatusFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedEnumInvoiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeFilter<$PrismaModel> | $Enums.InvoiceType
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceType | EnumInvoiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceType[] | ListEnumInvoiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceTypeFilter<$PrismaModel>
    _max?: NestedEnumInvoiceTypeFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumTailorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TailorStatus | EnumTailorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TailorStatus[] | ListEnumTailorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TailorStatus[] | ListEnumTailorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTailorStatusFilter<$PrismaModel> | $Enums.TailorStatus
  }

  export type NestedEnumTailorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TailorStatus | EnumTailorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TailorStatus[] | ListEnumTailorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TailorStatus[] | ListEnumTailorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTailorStatusWithAggregatesFilter<$PrismaModel> | $Enums.TailorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTailorStatusFilter<$PrismaModel>
    _max?: NestedEnumTailorStatusFilter<$PrismaModel>
  }

  export type NestedEnumTailorProductionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TailorProductionStatus | EnumTailorProductionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TailorProductionStatus[] | ListEnumTailorProductionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TailorProductionStatus[] | ListEnumTailorProductionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTailorProductionStatusFilter<$PrismaModel> | $Enums.TailorProductionStatus
  }

  export type NestedEnumTailorProductionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TailorProductionStatus | EnumTailorProductionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TailorProductionStatus[] | ListEnumTailorProductionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TailorProductionStatus[] | ListEnumTailorProductionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTailorProductionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TailorProductionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTailorProductionStatusFilter<$PrismaModel>
    _max?: NestedEnumTailorProductionStatusFilter<$PrismaModel>
  }

  export type ImportBatchCreateWithoutSales_dataInput = {
    id?: string
    batch_name: string
    import_type: $Enums.ImportType
    file_name: string
    file_type: string
    total_records: number
    valid_records: number
    invalid_records: number
    imported_records: number
    status: $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    product_data?: ProductDataCreateNestedManyWithoutImport_batchInput
    stock_data?: StockDataCreateNestedManyWithoutImport_batchInput
    advertising_data?: AdvertisingDataCreateNestedManyWithoutImport_batchInput
    advertising_settlement?: AdvertisingSettlementCreateNestedManyWithoutImport_batchInput
    returns_and_cancellations?: ReturnsAndCancellationsCreateNestedManyWithoutImport_batchInput
    marketplace_reimbursements?: MarketplaceReimbursementCreateNestedManyWithoutImport_batchInput
    commission_adjustments?: CommissionAdjustmentsCreateNestedManyWithoutImport_batchInput
    affiliate_samples?: AffiliateSamplesCreateNestedManyWithoutImport_batchInput
  }

  export type ImportBatchUncheckedCreateWithoutSales_dataInput = {
    id?: string
    batch_name: string
    import_type: $Enums.ImportType
    file_name: string
    file_type: string
    total_records: number
    valid_records: number
    invalid_records: number
    imported_records: number
    status: $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    product_data?: ProductDataUncheckedCreateNestedManyWithoutImport_batchInput
    stock_data?: StockDataUncheckedCreateNestedManyWithoutImport_batchInput
    advertising_data?: AdvertisingDataUncheckedCreateNestedManyWithoutImport_batchInput
    advertising_settlement?: AdvertisingSettlementUncheckedCreateNestedManyWithoutImport_batchInput
    returns_and_cancellations?: ReturnsAndCancellationsUncheckedCreateNestedManyWithoutImport_batchInput
    marketplace_reimbursements?: MarketplaceReimbursementUncheckedCreateNestedManyWithoutImport_batchInput
    commission_adjustments?: CommissionAdjustmentsUncheckedCreateNestedManyWithoutImport_batchInput
    affiliate_samples?: AffiliateSamplesUncheckedCreateNestedManyWithoutImport_batchInput
  }

  export type ImportBatchCreateOrConnectWithoutSales_dataInput = {
    where: ImportBatchWhereUniqueInput
    create: XOR<ImportBatchCreateWithoutSales_dataInput, ImportBatchUncheckedCreateWithoutSales_dataInput>
  }

  export type ImportBatchUpsertWithoutSales_dataInput = {
    update: XOR<ImportBatchUpdateWithoutSales_dataInput, ImportBatchUncheckedUpdateWithoutSales_dataInput>
    create: XOR<ImportBatchCreateWithoutSales_dataInput, ImportBatchUncheckedCreateWithoutSales_dataInput>
    where?: ImportBatchWhereInput
  }

  export type ImportBatchUpdateToOneWithWhereWithoutSales_dataInput = {
    where?: ImportBatchWhereInput
    data: XOR<ImportBatchUpdateWithoutSales_dataInput, ImportBatchUncheckedUpdateWithoutSales_dataInput>
  }

  export type ImportBatchUpdateWithoutSales_dataInput = {
    id?: StringFieldUpdateOperationsInput | string
    batch_name?: StringFieldUpdateOperationsInput | string
    import_type?: EnumImportTypeFieldUpdateOperationsInput | $Enums.ImportType
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    total_records?: IntFieldUpdateOperationsInput | number
    valid_records?: IntFieldUpdateOperationsInput | number
    invalid_records?: IntFieldUpdateOperationsInput | number
    imported_records?: IntFieldUpdateOperationsInput | number
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product_data?: ProductDataUpdateManyWithoutImport_batchNestedInput
    stock_data?: StockDataUpdateManyWithoutImport_batchNestedInput
    advertising_data?: AdvertisingDataUpdateManyWithoutImport_batchNestedInput
    advertising_settlement?: AdvertisingSettlementUpdateManyWithoutImport_batchNestedInput
    returns_and_cancellations?: ReturnsAndCancellationsUpdateManyWithoutImport_batchNestedInput
    marketplace_reimbursements?: MarketplaceReimbursementUpdateManyWithoutImport_batchNestedInput
    commission_adjustments?: CommissionAdjustmentsUpdateManyWithoutImport_batchNestedInput
    affiliate_samples?: AffiliateSamplesUpdateManyWithoutImport_batchNestedInput
  }

  export type ImportBatchUncheckedUpdateWithoutSales_dataInput = {
    id?: StringFieldUpdateOperationsInput | string
    batch_name?: StringFieldUpdateOperationsInput | string
    import_type?: EnumImportTypeFieldUpdateOperationsInput | $Enums.ImportType
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    total_records?: IntFieldUpdateOperationsInput | number
    valid_records?: IntFieldUpdateOperationsInput | number
    invalid_records?: IntFieldUpdateOperationsInput | number
    imported_records?: IntFieldUpdateOperationsInput | number
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product_data?: ProductDataUncheckedUpdateManyWithoutImport_batchNestedInput
    stock_data?: StockDataUncheckedUpdateManyWithoutImport_batchNestedInput
    advertising_data?: AdvertisingDataUncheckedUpdateManyWithoutImport_batchNestedInput
    advertising_settlement?: AdvertisingSettlementUncheckedUpdateManyWithoutImport_batchNestedInput
    returns_and_cancellations?: ReturnsAndCancellationsUncheckedUpdateManyWithoutImport_batchNestedInput
    marketplace_reimbursements?: MarketplaceReimbursementUncheckedUpdateManyWithoutImport_batchNestedInput
    commission_adjustments?: CommissionAdjustmentsUncheckedUpdateManyWithoutImport_batchNestedInput
    affiliate_samples?: AffiliateSamplesUncheckedUpdateManyWithoutImport_batchNestedInput
  }

  export type StockDataCreateWithoutProductInput = {
    id?: string
    movement_type: $Enums.StockMovementType
    quantity: number
    reference_number?: string | null
    notes?: string | null
    movement_date: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    import_batch?: ImportBatchCreateNestedOneWithoutStock_dataInput
  }

  export type StockDataUncheckedCreateWithoutProductInput = {
    id?: string
    movement_type: $Enums.StockMovementType
    quantity: number
    reference_number?: string | null
    notes?: string | null
    movement_date: Date | string
    import_batch_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StockDataCreateOrConnectWithoutProductInput = {
    where: StockDataWhereUniqueInput
    create: XOR<StockDataCreateWithoutProductInput, StockDataUncheckedCreateWithoutProductInput>
  }

  export type StockDataCreateManyProductInputEnvelope = {
    data: StockDataCreateManyProductInput | StockDataCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ImportBatchCreateWithoutProduct_dataInput = {
    id?: string
    batch_name: string
    import_type: $Enums.ImportType
    file_name: string
    file_type: string
    total_records: number
    valid_records: number
    invalid_records: number
    imported_records: number
    status: $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    sales_data?: SalesDataCreateNestedManyWithoutImport_batchInput
    stock_data?: StockDataCreateNestedManyWithoutImport_batchInput
    advertising_data?: AdvertisingDataCreateNestedManyWithoutImport_batchInput
    advertising_settlement?: AdvertisingSettlementCreateNestedManyWithoutImport_batchInput
    returns_and_cancellations?: ReturnsAndCancellationsCreateNestedManyWithoutImport_batchInput
    marketplace_reimbursements?: MarketplaceReimbursementCreateNestedManyWithoutImport_batchInput
    commission_adjustments?: CommissionAdjustmentsCreateNestedManyWithoutImport_batchInput
    affiliate_samples?: AffiliateSamplesCreateNestedManyWithoutImport_batchInput
  }

  export type ImportBatchUncheckedCreateWithoutProduct_dataInput = {
    id?: string
    batch_name: string
    import_type: $Enums.ImportType
    file_name: string
    file_type: string
    total_records: number
    valid_records: number
    invalid_records: number
    imported_records: number
    status: $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    sales_data?: SalesDataUncheckedCreateNestedManyWithoutImport_batchInput
    stock_data?: StockDataUncheckedCreateNestedManyWithoutImport_batchInput
    advertising_data?: AdvertisingDataUncheckedCreateNestedManyWithoutImport_batchInput
    advertising_settlement?: AdvertisingSettlementUncheckedCreateNestedManyWithoutImport_batchInput
    returns_and_cancellations?: ReturnsAndCancellationsUncheckedCreateNestedManyWithoutImport_batchInput
    marketplace_reimbursements?: MarketplaceReimbursementUncheckedCreateNestedManyWithoutImport_batchInput
    commission_adjustments?: CommissionAdjustmentsUncheckedCreateNestedManyWithoutImport_batchInput
    affiliate_samples?: AffiliateSamplesUncheckedCreateNestedManyWithoutImport_batchInput
  }

  export type ImportBatchCreateOrConnectWithoutProduct_dataInput = {
    where: ImportBatchWhereUniqueInput
    create: XOR<ImportBatchCreateWithoutProduct_dataInput, ImportBatchUncheckedCreateWithoutProduct_dataInput>
  }

  export type StockDataUpsertWithWhereUniqueWithoutProductInput = {
    where: StockDataWhereUniqueInput
    update: XOR<StockDataUpdateWithoutProductInput, StockDataUncheckedUpdateWithoutProductInput>
    create: XOR<StockDataCreateWithoutProductInput, StockDataUncheckedCreateWithoutProductInput>
  }

  export type StockDataUpdateWithWhereUniqueWithoutProductInput = {
    where: StockDataWhereUniqueInput
    data: XOR<StockDataUpdateWithoutProductInput, StockDataUncheckedUpdateWithoutProductInput>
  }

  export type StockDataUpdateManyWithWhereWithoutProductInput = {
    where: StockDataScalarWhereInput
    data: XOR<StockDataUpdateManyMutationInput, StockDataUncheckedUpdateManyWithoutProductInput>
  }

  export type StockDataScalarWhereInput = {
    AND?: StockDataScalarWhereInput | StockDataScalarWhereInput[]
    OR?: StockDataScalarWhereInput[]
    NOT?: StockDataScalarWhereInput | StockDataScalarWhereInput[]
    id?: StringFilter<"StockData"> | string
    product_code?: StringFilter<"StockData"> | string
    movement_type?: EnumStockMovementTypeFilter<"StockData"> | $Enums.StockMovementType
    quantity?: IntFilter<"StockData"> | number
    reference_number?: StringNullableFilter<"StockData"> | string | null
    notes?: StringNullableFilter<"StockData"> | string | null
    movement_date?: DateTimeFilter<"StockData"> | Date | string
    import_batch_id?: StringNullableFilter<"StockData"> | string | null
    created_at?: DateTimeFilter<"StockData"> | Date | string
    updated_at?: DateTimeFilter<"StockData"> | Date | string
  }

  export type ImportBatchUpsertWithoutProduct_dataInput = {
    update: XOR<ImportBatchUpdateWithoutProduct_dataInput, ImportBatchUncheckedUpdateWithoutProduct_dataInput>
    create: XOR<ImportBatchCreateWithoutProduct_dataInput, ImportBatchUncheckedCreateWithoutProduct_dataInput>
    where?: ImportBatchWhereInput
  }

  export type ImportBatchUpdateToOneWithWhereWithoutProduct_dataInput = {
    where?: ImportBatchWhereInput
    data: XOR<ImportBatchUpdateWithoutProduct_dataInput, ImportBatchUncheckedUpdateWithoutProduct_dataInput>
  }

  export type ImportBatchUpdateWithoutProduct_dataInput = {
    id?: StringFieldUpdateOperationsInput | string
    batch_name?: StringFieldUpdateOperationsInput | string
    import_type?: EnumImportTypeFieldUpdateOperationsInput | $Enums.ImportType
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    total_records?: IntFieldUpdateOperationsInput | number
    valid_records?: IntFieldUpdateOperationsInput | number
    invalid_records?: IntFieldUpdateOperationsInput | number
    imported_records?: IntFieldUpdateOperationsInput | number
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_data?: SalesDataUpdateManyWithoutImport_batchNestedInput
    stock_data?: StockDataUpdateManyWithoutImport_batchNestedInput
    advertising_data?: AdvertisingDataUpdateManyWithoutImport_batchNestedInput
    advertising_settlement?: AdvertisingSettlementUpdateManyWithoutImport_batchNestedInput
    returns_and_cancellations?: ReturnsAndCancellationsUpdateManyWithoutImport_batchNestedInput
    marketplace_reimbursements?: MarketplaceReimbursementUpdateManyWithoutImport_batchNestedInput
    commission_adjustments?: CommissionAdjustmentsUpdateManyWithoutImport_batchNestedInput
    affiliate_samples?: AffiliateSamplesUpdateManyWithoutImport_batchNestedInput
  }

  export type ImportBatchUncheckedUpdateWithoutProduct_dataInput = {
    id?: StringFieldUpdateOperationsInput | string
    batch_name?: StringFieldUpdateOperationsInput | string
    import_type?: EnumImportTypeFieldUpdateOperationsInput | $Enums.ImportType
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    total_records?: IntFieldUpdateOperationsInput | number
    valid_records?: IntFieldUpdateOperationsInput | number
    invalid_records?: IntFieldUpdateOperationsInput | number
    imported_records?: IntFieldUpdateOperationsInput | number
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_data?: SalesDataUncheckedUpdateManyWithoutImport_batchNestedInput
    stock_data?: StockDataUncheckedUpdateManyWithoutImport_batchNestedInput
    advertising_data?: AdvertisingDataUncheckedUpdateManyWithoutImport_batchNestedInput
    advertising_settlement?: AdvertisingSettlementUncheckedUpdateManyWithoutImport_batchNestedInput
    returns_and_cancellations?: ReturnsAndCancellationsUncheckedUpdateManyWithoutImport_batchNestedInput
    marketplace_reimbursements?: MarketplaceReimbursementUncheckedUpdateManyWithoutImport_batchNestedInput
    commission_adjustments?: CommissionAdjustmentsUncheckedUpdateManyWithoutImport_batchNestedInput
    affiliate_samples?: AffiliateSamplesUncheckedUpdateManyWithoutImport_batchNestedInput
  }

  export type ProductDataCreateWithoutStock_movementsInput = {
    id?: string
    product_code: string
    product_name: string
    category: string
    brand: string
    size: string
    color: string
    price: number
    cost: number
    stock_quantity: number
    min_stock: number
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    import_batch?: ImportBatchCreateNestedOneWithoutProduct_dataInput
  }

  export type ProductDataUncheckedCreateWithoutStock_movementsInput = {
    id?: string
    product_code: string
    product_name: string
    category: string
    brand: string
    size: string
    color: string
    price: number
    cost: number
    stock_quantity: number
    min_stock: number
    description?: string | null
    import_batch_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductDataCreateOrConnectWithoutStock_movementsInput = {
    where: ProductDataWhereUniqueInput
    create: XOR<ProductDataCreateWithoutStock_movementsInput, ProductDataUncheckedCreateWithoutStock_movementsInput>
  }

  export type ImportBatchCreateWithoutStock_dataInput = {
    id?: string
    batch_name: string
    import_type: $Enums.ImportType
    file_name: string
    file_type: string
    total_records: number
    valid_records: number
    invalid_records: number
    imported_records: number
    status: $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    sales_data?: SalesDataCreateNestedManyWithoutImport_batchInput
    product_data?: ProductDataCreateNestedManyWithoutImport_batchInput
    advertising_data?: AdvertisingDataCreateNestedManyWithoutImport_batchInput
    advertising_settlement?: AdvertisingSettlementCreateNestedManyWithoutImport_batchInput
    returns_and_cancellations?: ReturnsAndCancellationsCreateNestedManyWithoutImport_batchInput
    marketplace_reimbursements?: MarketplaceReimbursementCreateNestedManyWithoutImport_batchInput
    commission_adjustments?: CommissionAdjustmentsCreateNestedManyWithoutImport_batchInput
    affiliate_samples?: AffiliateSamplesCreateNestedManyWithoutImport_batchInput
  }

  export type ImportBatchUncheckedCreateWithoutStock_dataInput = {
    id?: string
    batch_name: string
    import_type: $Enums.ImportType
    file_name: string
    file_type: string
    total_records: number
    valid_records: number
    invalid_records: number
    imported_records: number
    status: $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    sales_data?: SalesDataUncheckedCreateNestedManyWithoutImport_batchInput
    product_data?: ProductDataUncheckedCreateNestedManyWithoutImport_batchInput
    advertising_data?: AdvertisingDataUncheckedCreateNestedManyWithoutImport_batchInput
    advertising_settlement?: AdvertisingSettlementUncheckedCreateNestedManyWithoutImport_batchInput
    returns_and_cancellations?: ReturnsAndCancellationsUncheckedCreateNestedManyWithoutImport_batchInput
    marketplace_reimbursements?: MarketplaceReimbursementUncheckedCreateNestedManyWithoutImport_batchInput
    commission_adjustments?: CommissionAdjustmentsUncheckedCreateNestedManyWithoutImport_batchInput
    affiliate_samples?: AffiliateSamplesUncheckedCreateNestedManyWithoutImport_batchInput
  }

  export type ImportBatchCreateOrConnectWithoutStock_dataInput = {
    where: ImportBatchWhereUniqueInput
    create: XOR<ImportBatchCreateWithoutStock_dataInput, ImportBatchUncheckedCreateWithoutStock_dataInput>
  }

  export type ProductDataUpsertWithoutStock_movementsInput = {
    update: XOR<ProductDataUpdateWithoutStock_movementsInput, ProductDataUncheckedUpdateWithoutStock_movementsInput>
    create: XOR<ProductDataCreateWithoutStock_movementsInput, ProductDataUncheckedCreateWithoutStock_movementsInput>
    where?: ProductDataWhereInput
  }

  export type ProductDataUpdateToOneWithWhereWithoutStock_movementsInput = {
    where?: ProductDataWhereInput
    data: XOR<ProductDataUpdateWithoutStock_movementsInput, ProductDataUncheckedUpdateWithoutStock_movementsInput>
  }

  export type ProductDataUpdateWithoutStock_movementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_code?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    stock_quantity?: IntFieldUpdateOperationsInput | number
    min_stock?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    import_batch?: ImportBatchUpdateOneWithoutProduct_dataNestedInput
  }

  export type ProductDataUncheckedUpdateWithoutStock_movementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_code?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    stock_quantity?: IntFieldUpdateOperationsInput | number
    min_stock?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    import_batch_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportBatchUpsertWithoutStock_dataInput = {
    update: XOR<ImportBatchUpdateWithoutStock_dataInput, ImportBatchUncheckedUpdateWithoutStock_dataInput>
    create: XOR<ImportBatchCreateWithoutStock_dataInput, ImportBatchUncheckedCreateWithoutStock_dataInput>
    where?: ImportBatchWhereInput
  }

  export type ImportBatchUpdateToOneWithWhereWithoutStock_dataInput = {
    where?: ImportBatchWhereInput
    data: XOR<ImportBatchUpdateWithoutStock_dataInput, ImportBatchUncheckedUpdateWithoutStock_dataInput>
  }

  export type ImportBatchUpdateWithoutStock_dataInput = {
    id?: StringFieldUpdateOperationsInput | string
    batch_name?: StringFieldUpdateOperationsInput | string
    import_type?: EnumImportTypeFieldUpdateOperationsInput | $Enums.ImportType
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    total_records?: IntFieldUpdateOperationsInput | number
    valid_records?: IntFieldUpdateOperationsInput | number
    invalid_records?: IntFieldUpdateOperationsInput | number
    imported_records?: IntFieldUpdateOperationsInput | number
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_data?: SalesDataUpdateManyWithoutImport_batchNestedInput
    product_data?: ProductDataUpdateManyWithoutImport_batchNestedInput
    advertising_data?: AdvertisingDataUpdateManyWithoutImport_batchNestedInput
    advertising_settlement?: AdvertisingSettlementUpdateManyWithoutImport_batchNestedInput
    returns_and_cancellations?: ReturnsAndCancellationsUpdateManyWithoutImport_batchNestedInput
    marketplace_reimbursements?: MarketplaceReimbursementUpdateManyWithoutImport_batchNestedInput
    commission_adjustments?: CommissionAdjustmentsUpdateManyWithoutImport_batchNestedInput
    affiliate_samples?: AffiliateSamplesUpdateManyWithoutImport_batchNestedInput
  }

  export type ImportBatchUncheckedUpdateWithoutStock_dataInput = {
    id?: StringFieldUpdateOperationsInput | string
    batch_name?: StringFieldUpdateOperationsInput | string
    import_type?: EnumImportTypeFieldUpdateOperationsInput | $Enums.ImportType
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    total_records?: IntFieldUpdateOperationsInput | number
    valid_records?: IntFieldUpdateOperationsInput | number
    invalid_records?: IntFieldUpdateOperationsInput | number
    imported_records?: IntFieldUpdateOperationsInput | number
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_data?: SalesDataUncheckedUpdateManyWithoutImport_batchNestedInput
    product_data?: ProductDataUncheckedUpdateManyWithoutImport_batchNestedInput
    advertising_data?: AdvertisingDataUncheckedUpdateManyWithoutImport_batchNestedInput
    advertising_settlement?: AdvertisingSettlementUncheckedUpdateManyWithoutImport_batchNestedInput
    returns_and_cancellations?: ReturnsAndCancellationsUncheckedUpdateManyWithoutImport_batchNestedInput
    marketplace_reimbursements?: MarketplaceReimbursementUncheckedUpdateManyWithoutImport_batchNestedInput
    commission_adjustments?: CommissionAdjustmentsUncheckedUpdateManyWithoutImport_batchNestedInput
    affiliate_samples?: AffiliateSamplesUncheckedUpdateManyWithoutImport_batchNestedInput
  }

  export type SalesDataCreateWithoutImport_batchInput = {
    id?: string
    order_id: string
    seller_sku: string
    product_name: string
    color: string
    size: string
    quantity: number
    order_amount: number
    created_time: Date | string
    delivered_time?: Date | string | null
    settlement_amount?: number | null
    total_revenue?: number | null
    hpp?: number | null
    total?: number | null
    marketplace?: string | null
    customer?: string | null
    province?: string | null
    regency_city?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SalesDataUncheckedCreateWithoutImport_batchInput = {
    id?: string
    order_id: string
    seller_sku: string
    product_name: string
    color: string
    size: string
    quantity: number
    order_amount: number
    created_time: Date | string
    delivered_time?: Date | string | null
    settlement_amount?: number | null
    total_revenue?: number | null
    hpp?: number | null
    total?: number | null
    marketplace?: string | null
    customer?: string | null
    province?: string | null
    regency_city?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SalesDataCreateOrConnectWithoutImport_batchInput = {
    where: SalesDataWhereUniqueInput
    create: XOR<SalesDataCreateWithoutImport_batchInput, SalesDataUncheckedCreateWithoutImport_batchInput>
  }

  export type SalesDataCreateManyImport_batchInputEnvelope = {
    data: SalesDataCreateManyImport_batchInput | SalesDataCreateManyImport_batchInput[]
    skipDuplicates?: boolean
  }

  export type ProductDataCreateWithoutImport_batchInput = {
    id?: string
    product_code: string
    product_name: string
    category: string
    brand: string
    size: string
    color: string
    price: number
    cost: number
    stock_quantity: number
    min_stock: number
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stock_movements?: StockDataCreateNestedManyWithoutProductInput
  }

  export type ProductDataUncheckedCreateWithoutImport_batchInput = {
    id?: string
    product_code: string
    product_name: string
    category: string
    brand: string
    size: string
    color: string
    price: number
    cost: number
    stock_quantity: number
    min_stock: number
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stock_movements?: StockDataUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductDataCreateOrConnectWithoutImport_batchInput = {
    where: ProductDataWhereUniqueInput
    create: XOR<ProductDataCreateWithoutImport_batchInput, ProductDataUncheckedCreateWithoutImport_batchInput>
  }

  export type ProductDataCreateManyImport_batchInputEnvelope = {
    data: ProductDataCreateManyImport_batchInput | ProductDataCreateManyImport_batchInput[]
    skipDuplicates?: boolean
  }

  export type StockDataCreateWithoutImport_batchInput = {
    id?: string
    movement_type: $Enums.StockMovementType
    quantity: number
    reference_number?: string | null
    notes?: string | null
    movement_date: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    product?: ProductDataCreateNestedOneWithoutStock_movementsInput
  }

  export type StockDataUncheckedCreateWithoutImport_batchInput = {
    id?: string
    product_code: string
    movement_type: $Enums.StockMovementType
    quantity: number
    reference_number?: string | null
    notes?: string | null
    movement_date: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StockDataCreateOrConnectWithoutImport_batchInput = {
    where: StockDataWhereUniqueInput
    create: XOR<StockDataCreateWithoutImport_batchInput, StockDataUncheckedCreateWithoutImport_batchInput>
  }

  export type StockDataCreateManyImport_batchInputEnvelope = {
    data: StockDataCreateManyImport_batchInput | StockDataCreateManyImport_batchInput[]
    skipDuplicates?: boolean
  }

  export type AdvertisingDataCreateWithoutImport_batchInput = {
    id?: string
    campaign_name: string
    ad_creative_type?: string | null
    ad_creative?: string | null
    account_name?: string | null
    cost?: number
    conversions?: number
    cpa?: number | null
    revenue?: number
    roi?: number | null
    impressions?: number
    clicks?: number
    ctr?: number | null
    conversion_rate?: number | null
    date_start: Date | string
    date_end: Date | string
    marketplace?: string | null
    nama_produk?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AdvertisingDataUncheckedCreateWithoutImport_batchInput = {
    id?: string
    campaign_name: string
    ad_creative_type?: string | null
    ad_creative?: string | null
    account_name?: string | null
    cost?: number
    conversions?: number
    cpa?: number | null
    revenue?: number
    roi?: number | null
    impressions?: number
    clicks?: number
    ctr?: number | null
    conversion_rate?: number | null
    date_start: Date | string
    date_end: Date | string
    marketplace?: string | null
    nama_produk?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AdvertisingDataCreateOrConnectWithoutImport_batchInput = {
    where: AdvertisingDataWhereUniqueInput
    create: XOR<AdvertisingDataCreateWithoutImport_batchInput, AdvertisingDataUncheckedCreateWithoutImport_batchInput>
  }

  export type AdvertisingDataCreateManyImport_batchInputEnvelope = {
    data: AdvertisingDataCreateManyImport_batchInput | AdvertisingDataCreateManyImport_batchInput[]
    skipDuplicates?: boolean
  }

  export type AdvertisingSettlementCreateWithoutImport_batchInput = {
    order_id: string
    type?: string | null
    order_created_time: Date | string
    order_settled_time: Date | string
    settlement_amount?: number
    settlement_period?: string | null
    account_name?: string | null
    marketplace?: string | null
    currency?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AdvertisingSettlementUncheckedCreateWithoutImport_batchInput = {
    order_id: string
    type?: string | null
    order_created_time: Date | string
    order_settled_time: Date | string
    settlement_amount?: number
    settlement_period?: string | null
    account_name?: string | null
    marketplace?: string | null
    currency?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AdvertisingSettlementCreateOrConnectWithoutImport_batchInput = {
    where: AdvertisingSettlementWhereUniqueInput
    create: XOR<AdvertisingSettlementCreateWithoutImport_batchInput, AdvertisingSettlementUncheckedCreateWithoutImport_batchInput>
  }

  export type AdvertisingSettlementCreateManyImport_batchInputEnvelope = {
    data: AdvertisingSettlementCreateManyImport_batchInput | AdvertisingSettlementCreateManyImport_batchInput[]
    skipDuplicates?: boolean
  }

  export type ReturnsAndCancellationsCreateWithoutImport_batchInput = {
    id?: string
    original_order_id?: string | null
    original_sales_id?: string | null
    type: string
    reason?: string | null
    return_date: Date | string
    returned_amount?: number
    refund_amount?: number
    restocking_fee?: number
    shipping_cost_loss?: number
    product_name: string
    quantity_returned?: number
    original_price?: number
    marketplace?: string | null
    product_condition?: string | null
    resellable?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ReturnsAndCancellationsUncheckedCreateWithoutImport_batchInput = {
    id?: string
    original_order_id?: string | null
    original_sales_id?: string | null
    type: string
    reason?: string | null
    return_date: Date | string
    returned_amount?: number
    refund_amount?: number
    restocking_fee?: number
    shipping_cost_loss?: number
    product_name: string
    quantity_returned?: number
    original_price?: number
    marketplace?: string | null
    product_condition?: string | null
    resellable?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ReturnsAndCancellationsCreateOrConnectWithoutImport_batchInput = {
    where: ReturnsAndCancellationsWhereUniqueInput
    create: XOR<ReturnsAndCancellationsCreateWithoutImport_batchInput, ReturnsAndCancellationsUncheckedCreateWithoutImport_batchInput>
  }

  export type ReturnsAndCancellationsCreateManyImport_batchInputEnvelope = {
    data: ReturnsAndCancellationsCreateManyImport_batchInput | ReturnsAndCancellationsCreateManyImport_batchInput[]
    skipDuplicates?: boolean
  }

  export type MarketplaceReimbursementCreateWithoutImport_batchInput = {
    id?: string
    claim_id?: string | null
    reimbursement_type: string
    claim_amount?: number
    approved_amount?: number
    received_amount?: number
    processing_fee?: number
    incident_date: Date | string
    claim_date: Date | string
    approval_date?: Date | string | null
    received_date?: Date | string | null
    affected_order_id?: string | null
    product_name?: string | null
    marketplace: string
    status?: string
    notes?: string | null
    evidence_provided?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MarketplaceReimbursementUncheckedCreateWithoutImport_batchInput = {
    id?: string
    claim_id?: string | null
    reimbursement_type: string
    claim_amount?: number
    approved_amount?: number
    received_amount?: number
    processing_fee?: number
    incident_date: Date | string
    claim_date: Date | string
    approval_date?: Date | string | null
    received_date?: Date | string | null
    affected_order_id?: string | null
    product_name?: string | null
    marketplace: string
    status?: string
    notes?: string | null
    evidence_provided?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MarketplaceReimbursementCreateOrConnectWithoutImport_batchInput = {
    where: MarketplaceReimbursementWhereUniqueInput
    create: XOR<MarketplaceReimbursementCreateWithoutImport_batchInput, MarketplaceReimbursementUncheckedCreateWithoutImport_batchInput>
  }

  export type MarketplaceReimbursementCreateManyImport_batchInputEnvelope = {
    data: MarketplaceReimbursementCreateManyImport_batchInput | MarketplaceReimbursementCreateManyImport_batchInput[]
    skipDuplicates?: boolean
  }

  export type CommissionAdjustmentsCreateWithoutImport_batchInput = {
    id?: string
    original_order_id?: string | null
    original_sales_id?: string | null
    adjustment_type: string
    reason?: string | null
    original_commission?: number
    adjustment_amount?: number
    final_commission?: number
    marketplace: string
    commission_rate?: number | null
    dynamic_rate_applied?: boolean
    transaction_date: Date | string
    adjustment_date: Date | string
    product_name?: string | null
    quantity?: number
    product_price?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CommissionAdjustmentsUncheckedCreateWithoutImport_batchInput = {
    id?: string
    original_order_id?: string | null
    original_sales_id?: string | null
    adjustment_type: string
    reason?: string | null
    original_commission?: number
    adjustment_amount?: number
    final_commission?: number
    marketplace: string
    commission_rate?: number | null
    dynamic_rate_applied?: boolean
    transaction_date: Date | string
    adjustment_date: Date | string
    product_name?: string | null
    quantity?: number
    product_price?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CommissionAdjustmentsCreateOrConnectWithoutImport_batchInput = {
    where: CommissionAdjustmentsWhereUniqueInput
    create: XOR<CommissionAdjustmentsCreateWithoutImport_batchInput, CommissionAdjustmentsUncheckedCreateWithoutImport_batchInput>
  }

  export type CommissionAdjustmentsCreateManyImport_batchInputEnvelope = {
    data: CommissionAdjustmentsCreateManyImport_batchInput | CommissionAdjustmentsCreateManyImport_batchInput[]
    skipDuplicates?: boolean
  }

  export type AffiliateSamplesCreateWithoutImport_batchInput = {
    id?: string
    affiliate_name: string
    affiliate_platform?: string | null
    affiliate_contact?: string | null
    product_name: string
    product_sku?: string | null
    quantity_given?: number
    product_cost?: number
    total_cost?: number
    shipping_cost?: number
    packaging_cost?: number
    campaign_name?: string | null
    expected_reach?: number | null
    content_type?: string | null
    given_date: Date | string
    expected_content_date?: Date | string | null
    actual_content_date?: Date | string | null
    content_delivered?: boolean
    performance_notes?: string | null
    roi_estimate?: number | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AffiliateSamplesUncheckedCreateWithoutImport_batchInput = {
    id?: string
    affiliate_name: string
    affiliate_platform?: string | null
    affiliate_contact?: string | null
    product_name: string
    product_sku?: string | null
    quantity_given?: number
    product_cost?: number
    total_cost?: number
    shipping_cost?: number
    packaging_cost?: number
    campaign_name?: string | null
    expected_reach?: number | null
    content_type?: string | null
    given_date: Date | string
    expected_content_date?: Date | string | null
    actual_content_date?: Date | string | null
    content_delivered?: boolean
    performance_notes?: string | null
    roi_estimate?: number | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AffiliateSamplesCreateOrConnectWithoutImport_batchInput = {
    where: AffiliateSamplesWhereUniqueInput
    create: XOR<AffiliateSamplesCreateWithoutImport_batchInput, AffiliateSamplesUncheckedCreateWithoutImport_batchInput>
  }

  export type AffiliateSamplesCreateManyImport_batchInputEnvelope = {
    data: AffiliateSamplesCreateManyImport_batchInput | AffiliateSamplesCreateManyImport_batchInput[]
    skipDuplicates?: boolean
  }

  export type SalesDataUpsertWithWhereUniqueWithoutImport_batchInput = {
    where: SalesDataWhereUniqueInput
    update: XOR<SalesDataUpdateWithoutImport_batchInput, SalesDataUncheckedUpdateWithoutImport_batchInput>
    create: XOR<SalesDataCreateWithoutImport_batchInput, SalesDataUncheckedCreateWithoutImport_batchInput>
  }

  export type SalesDataUpdateWithWhereUniqueWithoutImport_batchInput = {
    where: SalesDataWhereUniqueInput
    data: XOR<SalesDataUpdateWithoutImport_batchInput, SalesDataUncheckedUpdateWithoutImport_batchInput>
  }

  export type SalesDataUpdateManyWithWhereWithoutImport_batchInput = {
    where: SalesDataScalarWhereInput
    data: XOR<SalesDataUpdateManyMutationInput, SalesDataUncheckedUpdateManyWithoutImport_batchInput>
  }

  export type SalesDataScalarWhereInput = {
    AND?: SalesDataScalarWhereInput | SalesDataScalarWhereInput[]
    OR?: SalesDataScalarWhereInput[]
    NOT?: SalesDataScalarWhereInput | SalesDataScalarWhereInput[]
    id?: StringFilter<"SalesData"> | string
    order_id?: StringFilter<"SalesData"> | string
    seller_sku?: StringFilter<"SalesData"> | string
    product_name?: StringFilter<"SalesData"> | string
    color?: StringFilter<"SalesData"> | string
    size?: StringFilter<"SalesData"> | string
    quantity?: IntFilter<"SalesData"> | number
    order_amount?: FloatFilter<"SalesData"> | number
    created_time?: DateTimeFilter<"SalesData"> | Date | string
    delivered_time?: DateTimeNullableFilter<"SalesData"> | Date | string | null
    settlement_amount?: FloatNullableFilter<"SalesData"> | number | null
    total_revenue?: FloatNullableFilter<"SalesData"> | number | null
    hpp?: FloatNullableFilter<"SalesData"> | number | null
    total?: FloatNullableFilter<"SalesData"> | number | null
    marketplace?: StringNullableFilter<"SalesData"> | string | null
    customer?: StringNullableFilter<"SalesData"> | string | null
    province?: StringNullableFilter<"SalesData"> | string | null
    regency_city?: StringNullableFilter<"SalesData"> | string | null
    import_batch_id?: StringNullableFilter<"SalesData"> | string | null
    created_at?: DateTimeFilter<"SalesData"> | Date | string
    updated_at?: DateTimeFilter<"SalesData"> | Date | string
  }

  export type ProductDataUpsertWithWhereUniqueWithoutImport_batchInput = {
    where: ProductDataWhereUniqueInput
    update: XOR<ProductDataUpdateWithoutImport_batchInput, ProductDataUncheckedUpdateWithoutImport_batchInput>
    create: XOR<ProductDataCreateWithoutImport_batchInput, ProductDataUncheckedCreateWithoutImport_batchInput>
  }

  export type ProductDataUpdateWithWhereUniqueWithoutImport_batchInput = {
    where: ProductDataWhereUniqueInput
    data: XOR<ProductDataUpdateWithoutImport_batchInput, ProductDataUncheckedUpdateWithoutImport_batchInput>
  }

  export type ProductDataUpdateManyWithWhereWithoutImport_batchInput = {
    where: ProductDataScalarWhereInput
    data: XOR<ProductDataUpdateManyMutationInput, ProductDataUncheckedUpdateManyWithoutImport_batchInput>
  }

  export type ProductDataScalarWhereInput = {
    AND?: ProductDataScalarWhereInput | ProductDataScalarWhereInput[]
    OR?: ProductDataScalarWhereInput[]
    NOT?: ProductDataScalarWhereInput | ProductDataScalarWhereInput[]
    id?: StringFilter<"ProductData"> | string
    product_code?: StringFilter<"ProductData"> | string
    product_name?: StringFilter<"ProductData"> | string
    category?: StringFilter<"ProductData"> | string
    brand?: StringFilter<"ProductData"> | string
    size?: StringFilter<"ProductData"> | string
    color?: StringFilter<"ProductData"> | string
    price?: FloatFilter<"ProductData"> | number
    cost?: FloatFilter<"ProductData"> | number
    stock_quantity?: IntFilter<"ProductData"> | number
    min_stock?: IntFilter<"ProductData"> | number
    description?: StringNullableFilter<"ProductData"> | string | null
    import_batch_id?: StringNullableFilter<"ProductData"> | string | null
    created_at?: DateTimeFilter<"ProductData"> | Date | string
    updated_at?: DateTimeFilter<"ProductData"> | Date | string
  }

  export type StockDataUpsertWithWhereUniqueWithoutImport_batchInput = {
    where: StockDataWhereUniqueInput
    update: XOR<StockDataUpdateWithoutImport_batchInput, StockDataUncheckedUpdateWithoutImport_batchInput>
    create: XOR<StockDataCreateWithoutImport_batchInput, StockDataUncheckedCreateWithoutImport_batchInput>
  }

  export type StockDataUpdateWithWhereUniqueWithoutImport_batchInput = {
    where: StockDataWhereUniqueInput
    data: XOR<StockDataUpdateWithoutImport_batchInput, StockDataUncheckedUpdateWithoutImport_batchInput>
  }

  export type StockDataUpdateManyWithWhereWithoutImport_batchInput = {
    where: StockDataScalarWhereInput
    data: XOR<StockDataUpdateManyMutationInput, StockDataUncheckedUpdateManyWithoutImport_batchInput>
  }

  export type AdvertisingDataUpsertWithWhereUniqueWithoutImport_batchInput = {
    where: AdvertisingDataWhereUniqueInput
    update: XOR<AdvertisingDataUpdateWithoutImport_batchInput, AdvertisingDataUncheckedUpdateWithoutImport_batchInput>
    create: XOR<AdvertisingDataCreateWithoutImport_batchInput, AdvertisingDataUncheckedCreateWithoutImport_batchInput>
  }

  export type AdvertisingDataUpdateWithWhereUniqueWithoutImport_batchInput = {
    where: AdvertisingDataWhereUniqueInput
    data: XOR<AdvertisingDataUpdateWithoutImport_batchInput, AdvertisingDataUncheckedUpdateWithoutImport_batchInput>
  }

  export type AdvertisingDataUpdateManyWithWhereWithoutImport_batchInput = {
    where: AdvertisingDataScalarWhereInput
    data: XOR<AdvertisingDataUpdateManyMutationInput, AdvertisingDataUncheckedUpdateManyWithoutImport_batchInput>
  }

  export type AdvertisingDataScalarWhereInput = {
    AND?: AdvertisingDataScalarWhereInput | AdvertisingDataScalarWhereInput[]
    OR?: AdvertisingDataScalarWhereInput[]
    NOT?: AdvertisingDataScalarWhereInput | AdvertisingDataScalarWhereInput[]
    id?: StringFilter<"AdvertisingData"> | string
    campaign_name?: StringFilter<"AdvertisingData"> | string
    ad_creative_type?: StringNullableFilter<"AdvertisingData"> | string | null
    ad_creative?: StringNullableFilter<"AdvertisingData"> | string | null
    account_name?: StringNullableFilter<"AdvertisingData"> | string | null
    cost?: FloatFilter<"AdvertisingData"> | number
    conversions?: IntFilter<"AdvertisingData"> | number
    cpa?: FloatNullableFilter<"AdvertisingData"> | number | null
    revenue?: FloatFilter<"AdvertisingData"> | number
    roi?: FloatNullableFilter<"AdvertisingData"> | number | null
    impressions?: IntFilter<"AdvertisingData"> | number
    clicks?: IntFilter<"AdvertisingData"> | number
    ctr?: FloatNullableFilter<"AdvertisingData"> | number | null
    conversion_rate?: FloatNullableFilter<"AdvertisingData"> | number | null
    date_start?: DateTimeFilter<"AdvertisingData"> | Date | string
    date_end?: DateTimeFilter<"AdvertisingData"> | Date | string
    marketplace?: StringNullableFilter<"AdvertisingData"> | string | null
    nama_produk?: StringNullableFilter<"AdvertisingData"> | string | null
    import_batch_id?: StringNullableFilter<"AdvertisingData"> | string | null
    created_at?: DateTimeFilter<"AdvertisingData"> | Date | string
    updated_at?: DateTimeFilter<"AdvertisingData"> | Date | string
  }

  export type AdvertisingSettlementUpsertWithWhereUniqueWithoutImport_batchInput = {
    where: AdvertisingSettlementWhereUniqueInput
    update: XOR<AdvertisingSettlementUpdateWithoutImport_batchInput, AdvertisingSettlementUncheckedUpdateWithoutImport_batchInput>
    create: XOR<AdvertisingSettlementCreateWithoutImport_batchInput, AdvertisingSettlementUncheckedCreateWithoutImport_batchInput>
  }

  export type AdvertisingSettlementUpdateWithWhereUniqueWithoutImport_batchInput = {
    where: AdvertisingSettlementWhereUniqueInput
    data: XOR<AdvertisingSettlementUpdateWithoutImport_batchInput, AdvertisingSettlementUncheckedUpdateWithoutImport_batchInput>
  }

  export type AdvertisingSettlementUpdateManyWithWhereWithoutImport_batchInput = {
    where: AdvertisingSettlementScalarWhereInput
    data: XOR<AdvertisingSettlementUpdateManyMutationInput, AdvertisingSettlementUncheckedUpdateManyWithoutImport_batchInput>
  }

  export type AdvertisingSettlementScalarWhereInput = {
    AND?: AdvertisingSettlementScalarWhereInput | AdvertisingSettlementScalarWhereInput[]
    OR?: AdvertisingSettlementScalarWhereInput[]
    NOT?: AdvertisingSettlementScalarWhereInput | AdvertisingSettlementScalarWhereInput[]
    order_id?: StringFilter<"AdvertisingSettlement"> | string
    type?: StringNullableFilter<"AdvertisingSettlement"> | string | null
    order_created_time?: DateTimeFilter<"AdvertisingSettlement"> | Date | string
    order_settled_time?: DateTimeFilter<"AdvertisingSettlement"> | Date | string
    settlement_amount?: FloatFilter<"AdvertisingSettlement"> | number
    settlement_period?: StringNullableFilter<"AdvertisingSettlement"> | string | null
    account_name?: StringNullableFilter<"AdvertisingSettlement"> | string | null
    marketplace?: StringNullableFilter<"AdvertisingSettlement"> | string | null
    currency?: StringNullableFilter<"AdvertisingSettlement"> | string | null
    import_batch_id?: StringNullableFilter<"AdvertisingSettlement"> | string | null
    created_at?: DateTimeFilter<"AdvertisingSettlement"> | Date | string
    updated_at?: DateTimeFilter<"AdvertisingSettlement"> | Date | string
  }

  export type ReturnsAndCancellationsUpsertWithWhereUniqueWithoutImport_batchInput = {
    where: ReturnsAndCancellationsWhereUniqueInput
    update: XOR<ReturnsAndCancellationsUpdateWithoutImport_batchInput, ReturnsAndCancellationsUncheckedUpdateWithoutImport_batchInput>
    create: XOR<ReturnsAndCancellationsCreateWithoutImport_batchInput, ReturnsAndCancellationsUncheckedCreateWithoutImport_batchInput>
  }

  export type ReturnsAndCancellationsUpdateWithWhereUniqueWithoutImport_batchInput = {
    where: ReturnsAndCancellationsWhereUniqueInput
    data: XOR<ReturnsAndCancellationsUpdateWithoutImport_batchInput, ReturnsAndCancellationsUncheckedUpdateWithoutImport_batchInput>
  }

  export type ReturnsAndCancellationsUpdateManyWithWhereWithoutImport_batchInput = {
    where: ReturnsAndCancellationsScalarWhereInput
    data: XOR<ReturnsAndCancellationsUpdateManyMutationInput, ReturnsAndCancellationsUncheckedUpdateManyWithoutImport_batchInput>
  }

  export type ReturnsAndCancellationsScalarWhereInput = {
    AND?: ReturnsAndCancellationsScalarWhereInput | ReturnsAndCancellationsScalarWhereInput[]
    OR?: ReturnsAndCancellationsScalarWhereInput[]
    NOT?: ReturnsAndCancellationsScalarWhereInput | ReturnsAndCancellationsScalarWhereInput[]
    id?: StringFilter<"ReturnsAndCancellations"> | string
    original_order_id?: StringNullableFilter<"ReturnsAndCancellations"> | string | null
    original_sales_id?: StringNullableFilter<"ReturnsAndCancellations"> | string | null
    type?: StringFilter<"ReturnsAndCancellations"> | string
    reason?: StringNullableFilter<"ReturnsAndCancellations"> | string | null
    return_date?: DateTimeFilter<"ReturnsAndCancellations"> | Date | string
    returned_amount?: FloatFilter<"ReturnsAndCancellations"> | number
    refund_amount?: FloatFilter<"ReturnsAndCancellations"> | number
    restocking_fee?: FloatFilter<"ReturnsAndCancellations"> | number
    shipping_cost_loss?: FloatFilter<"ReturnsAndCancellations"> | number
    product_name?: StringFilter<"ReturnsAndCancellations"> | string
    quantity_returned?: IntFilter<"ReturnsAndCancellations"> | number
    original_price?: FloatFilter<"ReturnsAndCancellations"> | number
    marketplace?: StringNullableFilter<"ReturnsAndCancellations"> | string | null
    product_condition?: StringNullableFilter<"ReturnsAndCancellations"> | string | null
    resellable?: BoolFilter<"ReturnsAndCancellations"> | boolean
    import_batch_id?: StringNullableFilter<"ReturnsAndCancellations"> | string | null
    created_at?: DateTimeFilter<"ReturnsAndCancellations"> | Date | string
    updated_at?: DateTimeFilter<"ReturnsAndCancellations"> | Date | string
  }

  export type MarketplaceReimbursementUpsertWithWhereUniqueWithoutImport_batchInput = {
    where: MarketplaceReimbursementWhereUniqueInput
    update: XOR<MarketplaceReimbursementUpdateWithoutImport_batchInput, MarketplaceReimbursementUncheckedUpdateWithoutImport_batchInput>
    create: XOR<MarketplaceReimbursementCreateWithoutImport_batchInput, MarketplaceReimbursementUncheckedCreateWithoutImport_batchInput>
  }

  export type MarketplaceReimbursementUpdateWithWhereUniqueWithoutImport_batchInput = {
    where: MarketplaceReimbursementWhereUniqueInput
    data: XOR<MarketplaceReimbursementUpdateWithoutImport_batchInput, MarketplaceReimbursementUncheckedUpdateWithoutImport_batchInput>
  }

  export type MarketplaceReimbursementUpdateManyWithWhereWithoutImport_batchInput = {
    where: MarketplaceReimbursementScalarWhereInput
    data: XOR<MarketplaceReimbursementUpdateManyMutationInput, MarketplaceReimbursementUncheckedUpdateManyWithoutImport_batchInput>
  }

  export type MarketplaceReimbursementScalarWhereInput = {
    AND?: MarketplaceReimbursementScalarWhereInput | MarketplaceReimbursementScalarWhereInput[]
    OR?: MarketplaceReimbursementScalarWhereInput[]
    NOT?: MarketplaceReimbursementScalarWhereInput | MarketplaceReimbursementScalarWhereInput[]
    id?: StringFilter<"MarketplaceReimbursement"> | string
    claim_id?: StringNullableFilter<"MarketplaceReimbursement"> | string | null
    reimbursement_type?: StringFilter<"MarketplaceReimbursement"> | string
    claim_amount?: FloatFilter<"MarketplaceReimbursement"> | number
    approved_amount?: FloatFilter<"MarketplaceReimbursement"> | number
    received_amount?: FloatFilter<"MarketplaceReimbursement"> | number
    processing_fee?: FloatFilter<"MarketplaceReimbursement"> | number
    incident_date?: DateTimeFilter<"MarketplaceReimbursement"> | Date | string
    claim_date?: DateTimeFilter<"MarketplaceReimbursement"> | Date | string
    approval_date?: DateTimeNullableFilter<"MarketplaceReimbursement"> | Date | string | null
    received_date?: DateTimeNullableFilter<"MarketplaceReimbursement"> | Date | string | null
    affected_order_id?: StringNullableFilter<"MarketplaceReimbursement"> | string | null
    product_name?: StringNullableFilter<"MarketplaceReimbursement"> | string | null
    marketplace?: StringFilter<"MarketplaceReimbursement"> | string
    status?: StringFilter<"MarketplaceReimbursement"> | string
    notes?: StringNullableFilter<"MarketplaceReimbursement"> | string | null
    evidence_provided?: StringNullableFilter<"MarketplaceReimbursement"> | string | null
    import_batch_id?: StringNullableFilter<"MarketplaceReimbursement"> | string | null
    created_at?: DateTimeFilter<"MarketplaceReimbursement"> | Date | string
    updated_at?: DateTimeFilter<"MarketplaceReimbursement"> | Date | string
  }

  export type CommissionAdjustmentsUpsertWithWhereUniqueWithoutImport_batchInput = {
    where: CommissionAdjustmentsWhereUniqueInput
    update: XOR<CommissionAdjustmentsUpdateWithoutImport_batchInput, CommissionAdjustmentsUncheckedUpdateWithoutImport_batchInput>
    create: XOR<CommissionAdjustmentsCreateWithoutImport_batchInput, CommissionAdjustmentsUncheckedCreateWithoutImport_batchInput>
  }

  export type CommissionAdjustmentsUpdateWithWhereUniqueWithoutImport_batchInput = {
    where: CommissionAdjustmentsWhereUniqueInput
    data: XOR<CommissionAdjustmentsUpdateWithoutImport_batchInput, CommissionAdjustmentsUncheckedUpdateWithoutImport_batchInput>
  }

  export type CommissionAdjustmentsUpdateManyWithWhereWithoutImport_batchInput = {
    where: CommissionAdjustmentsScalarWhereInput
    data: XOR<CommissionAdjustmentsUpdateManyMutationInput, CommissionAdjustmentsUncheckedUpdateManyWithoutImport_batchInput>
  }

  export type CommissionAdjustmentsScalarWhereInput = {
    AND?: CommissionAdjustmentsScalarWhereInput | CommissionAdjustmentsScalarWhereInput[]
    OR?: CommissionAdjustmentsScalarWhereInput[]
    NOT?: CommissionAdjustmentsScalarWhereInput | CommissionAdjustmentsScalarWhereInput[]
    id?: StringFilter<"CommissionAdjustments"> | string
    original_order_id?: StringNullableFilter<"CommissionAdjustments"> | string | null
    original_sales_id?: StringNullableFilter<"CommissionAdjustments"> | string | null
    adjustment_type?: StringFilter<"CommissionAdjustments"> | string
    reason?: StringNullableFilter<"CommissionAdjustments"> | string | null
    original_commission?: FloatFilter<"CommissionAdjustments"> | number
    adjustment_amount?: FloatFilter<"CommissionAdjustments"> | number
    final_commission?: FloatFilter<"CommissionAdjustments"> | number
    marketplace?: StringFilter<"CommissionAdjustments"> | string
    commission_rate?: FloatNullableFilter<"CommissionAdjustments"> | number | null
    dynamic_rate_applied?: BoolFilter<"CommissionAdjustments"> | boolean
    transaction_date?: DateTimeFilter<"CommissionAdjustments"> | Date | string
    adjustment_date?: DateTimeFilter<"CommissionAdjustments"> | Date | string
    product_name?: StringNullableFilter<"CommissionAdjustments"> | string | null
    quantity?: IntFilter<"CommissionAdjustments"> | number
    product_price?: FloatFilter<"CommissionAdjustments"> | number
    import_batch_id?: StringNullableFilter<"CommissionAdjustments"> | string | null
    created_at?: DateTimeFilter<"CommissionAdjustments"> | Date | string
    updated_at?: DateTimeFilter<"CommissionAdjustments"> | Date | string
  }

  export type AffiliateSamplesUpsertWithWhereUniqueWithoutImport_batchInput = {
    where: AffiliateSamplesWhereUniqueInput
    update: XOR<AffiliateSamplesUpdateWithoutImport_batchInput, AffiliateSamplesUncheckedUpdateWithoutImport_batchInput>
    create: XOR<AffiliateSamplesCreateWithoutImport_batchInput, AffiliateSamplesUncheckedCreateWithoutImport_batchInput>
  }

  export type AffiliateSamplesUpdateWithWhereUniqueWithoutImport_batchInput = {
    where: AffiliateSamplesWhereUniqueInput
    data: XOR<AffiliateSamplesUpdateWithoutImport_batchInput, AffiliateSamplesUncheckedUpdateWithoutImport_batchInput>
  }

  export type AffiliateSamplesUpdateManyWithWhereWithoutImport_batchInput = {
    where: AffiliateSamplesScalarWhereInput
    data: XOR<AffiliateSamplesUpdateManyMutationInput, AffiliateSamplesUncheckedUpdateManyWithoutImport_batchInput>
  }

  export type AffiliateSamplesScalarWhereInput = {
    AND?: AffiliateSamplesScalarWhereInput | AffiliateSamplesScalarWhereInput[]
    OR?: AffiliateSamplesScalarWhereInput[]
    NOT?: AffiliateSamplesScalarWhereInput | AffiliateSamplesScalarWhereInput[]
    id?: StringFilter<"AffiliateSamples"> | string
    affiliate_name?: StringFilter<"AffiliateSamples"> | string
    affiliate_platform?: StringNullableFilter<"AffiliateSamples"> | string | null
    affiliate_contact?: StringNullableFilter<"AffiliateSamples"> | string | null
    product_name?: StringFilter<"AffiliateSamples"> | string
    product_sku?: StringNullableFilter<"AffiliateSamples"> | string | null
    quantity_given?: IntFilter<"AffiliateSamples"> | number
    product_cost?: FloatFilter<"AffiliateSamples"> | number
    total_cost?: FloatFilter<"AffiliateSamples"> | number
    shipping_cost?: FloatFilter<"AffiliateSamples"> | number
    packaging_cost?: FloatFilter<"AffiliateSamples"> | number
    campaign_name?: StringNullableFilter<"AffiliateSamples"> | string | null
    expected_reach?: IntNullableFilter<"AffiliateSamples"> | number | null
    content_type?: StringNullableFilter<"AffiliateSamples"> | string | null
    given_date?: DateTimeFilter<"AffiliateSamples"> | Date | string
    expected_content_date?: DateTimeNullableFilter<"AffiliateSamples"> | Date | string | null
    actual_content_date?: DateTimeNullableFilter<"AffiliateSamples"> | Date | string | null
    content_delivered?: BoolFilter<"AffiliateSamples"> | boolean
    performance_notes?: StringNullableFilter<"AffiliateSamples"> | string | null
    roi_estimate?: FloatNullableFilter<"AffiliateSamples"> | number | null
    status?: StringFilter<"AffiliateSamples"> | string
    import_batch_id?: StringNullableFilter<"AffiliateSamples"> | string | null
    created_at?: DateTimeFilter<"AffiliateSamples"> | Date | string
    updated_at?: DateTimeFilter<"AffiliateSamples"> | Date | string
  }

  export type ImportBatchCreateWithoutAdvertising_dataInput = {
    id?: string
    batch_name: string
    import_type: $Enums.ImportType
    file_name: string
    file_type: string
    total_records: number
    valid_records: number
    invalid_records: number
    imported_records: number
    status: $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    sales_data?: SalesDataCreateNestedManyWithoutImport_batchInput
    product_data?: ProductDataCreateNestedManyWithoutImport_batchInput
    stock_data?: StockDataCreateNestedManyWithoutImport_batchInput
    advertising_settlement?: AdvertisingSettlementCreateNestedManyWithoutImport_batchInput
    returns_and_cancellations?: ReturnsAndCancellationsCreateNestedManyWithoutImport_batchInput
    marketplace_reimbursements?: MarketplaceReimbursementCreateNestedManyWithoutImport_batchInput
    commission_adjustments?: CommissionAdjustmentsCreateNestedManyWithoutImport_batchInput
    affiliate_samples?: AffiliateSamplesCreateNestedManyWithoutImport_batchInput
  }

  export type ImportBatchUncheckedCreateWithoutAdvertising_dataInput = {
    id?: string
    batch_name: string
    import_type: $Enums.ImportType
    file_name: string
    file_type: string
    total_records: number
    valid_records: number
    invalid_records: number
    imported_records: number
    status: $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    sales_data?: SalesDataUncheckedCreateNestedManyWithoutImport_batchInput
    product_data?: ProductDataUncheckedCreateNestedManyWithoutImport_batchInput
    stock_data?: StockDataUncheckedCreateNestedManyWithoutImport_batchInput
    advertising_settlement?: AdvertisingSettlementUncheckedCreateNestedManyWithoutImport_batchInput
    returns_and_cancellations?: ReturnsAndCancellationsUncheckedCreateNestedManyWithoutImport_batchInput
    marketplace_reimbursements?: MarketplaceReimbursementUncheckedCreateNestedManyWithoutImport_batchInput
    commission_adjustments?: CommissionAdjustmentsUncheckedCreateNestedManyWithoutImport_batchInput
    affiliate_samples?: AffiliateSamplesUncheckedCreateNestedManyWithoutImport_batchInput
  }

  export type ImportBatchCreateOrConnectWithoutAdvertising_dataInput = {
    where: ImportBatchWhereUniqueInput
    create: XOR<ImportBatchCreateWithoutAdvertising_dataInput, ImportBatchUncheckedCreateWithoutAdvertising_dataInput>
  }

  export type ImportBatchUpsertWithoutAdvertising_dataInput = {
    update: XOR<ImportBatchUpdateWithoutAdvertising_dataInput, ImportBatchUncheckedUpdateWithoutAdvertising_dataInput>
    create: XOR<ImportBatchCreateWithoutAdvertising_dataInput, ImportBatchUncheckedCreateWithoutAdvertising_dataInput>
    where?: ImportBatchWhereInput
  }

  export type ImportBatchUpdateToOneWithWhereWithoutAdvertising_dataInput = {
    where?: ImportBatchWhereInput
    data: XOR<ImportBatchUpdateWithoutAdvertising_dataInput, ImportBatchUncheckedUpdateWithoutAdvertising_dataInput>
  }

  export type ImportBatchUpdateWithoutAdvertising_dataInput = {
    id?: StringFieldUpdateOperationsInput | string
    batch_name?: StringFieldUpdateOperationsInput | string
    import_type?: EnumImportTypeFieldUpdateOperationsInput | $Enums.ImportType
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    total_records?: IntFieldUpdateOperationsInput | number
    valid_records?: IntFieldUpdateOperationsInput | number
    invalid_records?: IntFieldUpdateOperationsInput | number
    imported_records?: IntFieldUpdateOperationsInput | number
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_data?: SalesDataUpdateManyWithoutImport_batchNestedInput
    product_data?: ProductDataUpdateManyWithoutImport_batchNestedInput
    stock_data?: StockDataUpdateManyWithoutImport_batchNestedInput
    advertising_settlement?: AdvertisingSettlementUpdateManyWithoutImport_batchNestedInput
    returns_and_cancellations?: ReturnsAndCancellationsUpdateManyWithoutImport_batchNestedInput
    marketplace_reimbursements?: MarketplaceReimbursementUpdateManyWithoutImport_batchNestedInput
    commission_adjustments?: CommissionAdjustmentsUpdateManyWithoutImport_batchNestedInput
    affiliate_samples?: AffiliateSamplesUpdateManyWithoutImport_batchNestedInput
  }

  export type ImportBatchUncheckedUpdateWithoutAdvertising_dataInput = {
    id?: StringFieldUpdateOperationsInput | string
    batch_name?: StringFieldUpdateOperationsInput | string
    import_type?: EnumImportTypeFieldUpdateOperationsInput | $Enums.ImportType
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    total_records?: IntFieldUpdateOperationsInput | number
    valid_records?: IntFieldUpdateOperationsInput | number
    invalid_records?: IntFieldUpdateOperationsInput | number
    imported_records?: IntFieldUpdateOperationsInput | number
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_data?: SalesDataUncheckedUpdateManyWithoutImport_batchNestedInput
    product_data?: ProductDataUncheckedUpdateManyWithoutImport_batchNestedInput
    stock_data?: StockDataUncheckedUpdateManyWithoutImport_batchNestedInput
    advertising_settlement?: AdvertisingSettlementUncheckedUpdateManyWithoutImport_batchNestedInput
    returns_and_cancellations?: ReturnsAndCancellationsUncheckedUpdateManyWithoutImport_batchNestedInput
    marketplace_reimbursements?: MarketplaceReimbursementUncheckedUpdateManyWithoutImport_batchNestedInput
    commission_adjustments?: CommissionAdjustmentsUncheckedUpdateManyWithoutImport_batchNestedInput
    affiliate_samples?: AffiliateSamplesUncheckedUpdateManyWithoutImport_batchNestedInput
  }

  export type ImportBatchCreateWithoutAdvertising_settlementInput = {
    id?: string
    batch_name: string
    import_type: $Enums.ImportType
    file_name: string
    file_type: string
    total_records: number
    valid_records: number
    invalid_records: number
    imported_records: number
    status: $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    sales_data?: SalesDataCreateNestedManyWithoutImport_batchInput
    product_data?: ProductDataCreateNestedManyWithoutImport_batchInput
    stock_data?: StockDataCreateNestedManyWithoutImport_batchInput
    advertising_data?: AdvertisingDataCreateNestedManyWithoutImport_batchInput
    returns_and_cancellations?: ReturnsAndCancellationsCreateNestedManyWithoutImport_batchInput
    marketplace_reimbursements?: MarketplaceReimbursementCreateNestedManyWithoutImport_batchInput
    commission_adjustments?: CommissionAdjustmentsCreateNestedManyWithoutImport_batchInput
    affiliate_samples?: AffiliateSamplesCreateNestedManyWithoutImport_batchInput
  }

  export type ImportBatchUncheckedCreateWithoutAdvertising_settlementInput = {
    id?: string
    batch_name: string
    import_type: $Enums.ImportType
    file_name: string
    file_type: string
    total_records: number
    valid_records: number
    invalid_records: number
    imported_records: number
    status: $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    sales_data?: SalesDataUncheckedCreateNestedManyWithoutImport_batchInput
    product_data?: ProductDataUncheckedCreateNestedManyWithoutImport_batchInput
    stock_data?: StockDataUncheckedCreateNestedManyWithoutImport_batchInput
    advertising_data?: AdvertisingDataUncheckedCreateNestedManyWithoutImport_batchInput
    returns_and_cancellations?: ReturnsAndCancellationsUncheckedCreateNestedManyWithoutImport_batchInput
    marketplace_reimbursements?: MarketplaceReimbursementUncheckedCreateNestedManyWithoutImport_batchInput
    commission_adjustments?: CommissionAdjustmentsUncheckedCreateNestedManyWithoutImport_batchInput
    affiliate_samples?: AffiliateSamplesUncheckedCreateNestedManyWithoutImport_batchInput
  }

  export type ImportBatchCreateOrConnectWithoutAdvertising_settlementInput = {
    where: ImportBatchWhereUniqueInput
    create: XOR<ImportBatchCreateWithoutAdvertising_settlementInput, ImportBatchUncheckedCreateWithoutAdvertising_settlementInput>
  }

  export type ImportBatchUpsertWithoutAdvertising_settlementInput = {
    update: XOR<ImportBatchUpdateWithoutAdvertising_settlementInput, ImportBatchUncheckedUpdateWithoutAdvertising_settlementInput>
    create: XOR<ImportBatchCreateWithoutAdvertising_settlementInput, ImportBatchUncheckedCreateWithoutAdvertising_settlementInput>
    where?: ImportBatchWhereInput
  }

  export type ImportBatchUpdateToOneWithWhereWithoutAdvertising_settlementInput = {
    where?: ImportBatchWhereInput
    data: XOR<ImportBatchUpdateWithoutAdvertising_settlementInput, ImportBatchUncheckedUpdateWithoutAdvertising_settlementInput>
  }

  export type ImportBatchUpdateWithoutAdvertising_settlementInput = {
    id?: StringFieldUpdateOperationsInput | string
    batch_name?: StringFieldUpdateOperationsInput | string
    import_type?: EnumImportTypeFieldUpdateOperationsInput | $Enums.ImportType
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    total_records?: IntFieldUpdateOperationsInput | number
    valid_records?: IntFieldUpdateOperationsInput | number
    invalid_records?: IntFieldUpdateOperationsInput | number
    imported_records?: IntFieldUpdateOperationsInput | number
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_data?: SalesDataUpdateManyWithoutImport_batchNestedInput
    product_data?: ProductDataUpdateManyWithoutImport_batchNestedInput
    stock_data?: StockDataUpdateManyWithoutImport_batchNestedInput
    advertising_data?: AdvertisingDataUpdateManyWithoutImport_batchNestedInput
    returns_and_cancellations?: ReturnsAndCancellationsUpdateManyWithoutImport_batchNestedInput
    marketplace_reimbursements?: MarketplaceReimbursementUpdateManyWithoutImport_batchNestedInput
    commission_adjustments?: CommissionAdjustmentsUpdateManyWithoutImport_batchNestedInput
    affiliate_samples?: AffiliateSamplesUpdateManyWithoutImport_batchNestedInput
  }

  export type ImportBatchUncheckedUpdateWithoutAdvertising_settlementInput = {
    id?: StringFieldUpdateOperationsInput | string
    batch_name?: StringFieldUpdateOperationsInput | string
    import_type?: EnumImportTypeFieldUpdateOperationsInput | $Enums.ImportType
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    total_records?: IntFieldUpdateOperationsInput | number
    valid_records?: IntFieldUpdateOperationsInput | number
    invalid_records?: IntFieldUpdateOperationsInput | number
    imported_records?: IntFieldUpdateOperationsInput | number
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_data?: SalesDataUncheckedUpdateManyWithoutImport_batchNestedInput
    product_data?: ProductDataUncheckedUpdateManyWithoutImport_batchNestedInput
    stock_data?: StockDataUncheckedUpdateManyWithoutImport_batchNestedInput
    advertising_data?: AdvertisingDataUncheckedUpdateManyWithoutImport_batchNestedInput
    returns_and_cancellations?: ReturnsAndCancellationsUncheckedUpdateManyWithoutImport_batchNestedInput
    marketplace_reimbursements?: MarketplaceReimbursementUncheckedUpdateManyWithoutImport_batchNestedInput
    commission_adjustments?: CommissionAdjustmentsUncheckedUpdateManyWithoutImport_batchNestedInput
    affiliate_samples?: AffiliateSamplesUncheckedUpdateManyWithoutImport_batchNestedInput
  }

  export type ImportBatchCreateWithoutReturns_and_cancellationsInput = {
    id?: string
    batch_name: string
    import_type: $Enums.ImportType
    file_name: string
    file_type: string
    total_records: number
    valid_records: number
    invalid_records: number
    imported_records: number
    status: $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    sales_data?: SalesDataCreateNestedManyWithoutImport_batchInput
    product_data?: ProductDataCreateNestedManyWithoutImport_batchInput
    stock_data?: StockDataCreateNestedManyWithoutImport_batchInput
    advertising_data?: AdvertisingDataCreateNestedManyWithoutImport_batchInput
    advertising_settlement?: AdvertisingSettlementCreateNestedManyWithoutImport_batchInput
    marketplace_reimbursements?: MarketplaceReimbursementCreateNestedManyWithoutImport_batchInput
    commission_adjustments?: CommissionAdjustmentsCreateNestedManyWithoutImport_batchInput
    affiliate_samples?: AffiliateSamplesCreateNestedManyWithoutImport_batchInput
  }

  export type ImportBatchUncheckedCreateWithoutReturns_and_cancellationsInput = {
    id?: string
    batch_name: string
    import_type: $Enums.ImportType
    file_name: string
    file_type: string
    total_records: number
    valid_records: number
    invalid_records: number
    imported_records: number
    status: $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    sales_data?: SalesDataUncheckedCreateNestedManyWithoutImport_batchInput
    product_data?: ProductDataUncheckedCreateNestedManyWithoutImport_batchInput
    stock_data?: StockDataUncheckedCreateNestedManyWithoutImport_batchInput
    advertising_data?: AdvertisingDataUncheckedCreateNestedManyWithoutImport_batchInput
    advertising_settlement?: AdvertisingSettlementUncheckedCreateNestedManyWithoutImport_batchInput
    marketplace_reimbursements?: MarketplaceReimbursementUncheckedCreateNestedManyWithoutImport_batchInput
    commission_adjustments?: CommissionAdjustmentsUncheckedCreateNestedManyWithoutImport_batchInput
    affiliate_samples?: AffiliateSamplesUncheckedCreateNestedManyWithoutImport_batchInput
  }

  export type ImportBatchCreateOrConnectWithoutReturns_and_cancellationsInput = {
    where: ImportBatchWhereUniqueInput
    create: XOR<ImportBatchCreateWithoutReturns_and_cancellationsInput, ImportBatchUncheckedCreateWithoutReturns_and_cancellationsInput>
  }

  export type ImportBatchUpsertWithoutReturns_and_cancellationsInput = {
    update: XOR<ImportBatchUpdateWithoutReturns_and_cancellationsInput, ImportBatchUncheckedUpdateWithoutReturns_and_cancellationsInput>
    create: XOR<ImportBatchCreateWithoutReturns_and_cancellationsInput, ImportBatchUncheckedCreateWithoutReturns_and_cancellationsInput>
    where?: ImportBatchWhereInput
  }

  export type ImportBatchUpdateToOneWithWhereWithoutReturns_and_cancellationsInput = {
    where?: ImportBatchWhereInput
    data: XOR<ImportBatchUpdateWithoutReturns_and_cancellationsInput, ImportBatchUncheckedUpdateWithoutReturns_and_cancellationsInput>
  }

  export type ImportBatchUpdateWithoutReturns_and_cancellationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    batch_name?: StringFieldUpdateOperationsInput | string
    import_type?: EnumImportTypeFieldUpdateOperationsInput | $Enums.ImportType
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    total_records?: IntFieldUpdateOperationsInput | number
    valid_records?: IntFieldUpdateOperationsInput | number
    invalid_records?: IntFieldUpdateOperationsInput | number
    imported_records?: IntFieldUpdateOperationsInput | number
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_data?: SalesDataUpdateManyWithoutImport_batchNestedInput
    product_data?: ProductDataUpdateManyWithoutImport_batchNestedInput
    stock_data?: StockDataUpdateManyWithoutImport_batchNestedInput
    advertising_data?: AdvertisingDataUpdateManyWithoutImport_batchNestedInput
    advertising_settlement?: AdvertisingSettlementUpdateManyWithoutImport_batchNestedInput
    marketplace_reimbursements?: MarketplaceReimbursementUpdateManyWithoutImport_batchNestedInput
    commission_adjustments?: CommissionAdjustmentsUpdateManyWithoutImport_batchNestedInput
    affiliate_samples?: AffiliateSamplesUpdateManyWithoutImport_batchNestedInput
  }

  export type ImportBatchUncheckedUpdateWithoutReturns_and_cancellationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    batch_name?: StringFieldUpdateOperationsInput | string
    import_type?: EnumImportTypeFieldUpdateOperationsInput | $Enums.ImportType
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    total_records?: IntFieldUpdateOperationsInput | number
    valid_records?: IntFieldUpdateOperationsInput | number
    invalid_records?: IntFieldUpdateOperationsInput | number
    imported_records?: IntFieldUpdateOperationsInput | number
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_data?: SalesDataUncheckedUpdateManyWithoutImport_batchNestedInput
    product_data?: ProductDataUncheckedUpdateManyWithoutImport_batchNestedInput
    stock_data?: StockDataUncheckedUpdateManyWithoutImport_batchNestedInput
    advertising_data?: AdvertisingDataUncheckedUpdateManyWithoutImport_batchNestedInput
    advertising_settlement?: AdvertisingSettlementUncheckedUpdateManyWithoutImport_batchNestedInput
    marketplace_reimbursements?: MarketplaceReimbursementUncheckedUpdateManyWithoutImport_batchNestedInput
    commission_adjustments?: CommissionAdjustmentsUncheckedUpdateManyWithoutImport_batchNestedInput
    affiliate_samples?: AffiliateSamplesUncheckedUpdateManyWithoutImport_batchNestedInput
  }

  export type ImportBatchCreateWithoutMarketplace_reimbursementsInput = {
    id?: string
    batch_name: string
    import_type: $Enums.ImportType
    file_name: string
    file_type: string
    total_records: number
    valid_records: number
    invalid_records: number
    imported_records: number
    status: $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    sales_data?: SalesDataCreateNestedManyWithoutImport_batchInput
    product_data?: ProductDataCreateNestedManyWithoutImport_batchInput
    stock_data?: StockDataCreateNestedManyWithoutImport_batchInput
    advertising_data?: AdvertisingDataCreateNestedManyWithoutImport_batchInput
    advertising_settlement?: AdvertisingSettlementCreateNestedManyWithoutImport_batchInput
    returns_and_cancellations?: ReturnsAndCancellationsCreateNestedManyWithoutImport_batchInput
    commission_adjustments?: CommissionAdjustmentsCreateNestedManyWithoutImport_batchInput
    affiliate_samples?: AffiliateSamplesCreateNestedManyWithoutImport_batchInput
  }

  export type ImportBatchUncheckedCreateWithoutMarketplace_reimbursementsInput = {
    id?: string
    batch_name: string
    import_type: $Enums.ImportType
    file_name: string
    file_type: string
    total_records: number
    valid_records: number
    invalid_records: number
    imported_records: number
    status: $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    sales_data?: SalesDataUncheckedCreateNestedManyWithoutImport_batchInput
    product_data?: ProductDataUncheckedCreateNestedManyWithoutImport_batchInput
    stock_data?: StockDataUncheckedCreateNestedManyWithoutImport_batchInput
    advertising_data?: AdvertisingDataUncheckedCreateNestedManyWithoutImport_batchInput
    advertising_settlement?: AdvertisingSettlementUncheckedCreateNestedManyWithoutImport_batchInput
    returns_and_cancellations?: ReturnsAndCancellationsUncheckedCreateNestedManyWithoutImport_batchInput
    commission_adjustments?: CommissionAdjustmentsUncheckedCreateNestedManyWithoutImport_batchInput
    affiliate_samples?: AffiliateSamplesUncheckedCreateNestedManyWithoutImport_batchInput
  }

  export type ImportBatchCreateOrConnectWithoutMarketplace_reimbursementsInput = {
    where: ImportBatchWhereUniqueInput
    create: XOR<ImportBatchCreateWithoutMarketplace_reimbursementsInput, ImportBatchUncheckedCreateWithoutMarketplace_reimbursementsInput>
  }

  export type ImportBatchUpsertWithoutMarketplace_reimbursementsInput = {
    update: XOR<ImportBatchUpdateWithoutMarketplace_reimbursementsInput, ImportBatchUncheckedUpdateWithoutMarketplace_reimbursementsInput>
    create: XOR<ImportBatchCreateWithoutMarketplace_reimbursementsInput, ImportBatchUncheckedCreateWithoutMarketplace_reimbursementsInput>
    where?: ImportBatchWhereInput
  }

  export type ImportBatchUpdateToOneWithWhereWithoutMarketplace_reimbursementsInput = {
    where?: ImportBatchWhereInput
    data: XOR<ImportBatchUpdateWithoutMarketplace_reimbursementsInput, ImportBatchUncheckedUpdateWithoutMarketplace_reimbursementsInput>
  }

  export type ImportBatchUpdateWithoutMarketplace_reimbursementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    batch_name?: StringFieldUpdateOperationsInput | string
    import_type?: EnumImportTypeFieldUpdateOperationsInput | $Enums.ImportType
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    total_records?: IntFieldUpdateOperationsInput | number
    valid_records?: IntFieldUpdateOperationsInput | number
    invalid_records?: IntFieldUpdateOperationsInput | number
    imported_records?: IntFieldUpdateOperationsInput | number
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_data?: SalesDataUpdateManyWithoutImport_batchNestedInput
    product_data?: ProductDataUpdateManyWithoutImport_batchNestedInput
    stock_data?: StockDataUpdateManyWithoutImport_batchNestedInput
    advertising_data?: AdvertisingDataUpdateManyWithoutImport_batchNestedInput
    advertising_settlement?: AdvertisingSettlementUpdateManyWithoutImport_batchNestedInput
    returns_and_cancellations?: ReturnsAndCancellationsUpdateManyWithoutImport_batchNestedInput
    commission_adjustments?: CommissionAdjustmentsUpdateManyWithoutImport_batchNestedInput
    affiliate_samples?: AffiliateSamplesUpdateManyWithoutImport_batchNestedInput
  }

  export type ImportBatchUncheckedUpdateWithoutMarketplace_reimbursementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    batch_name?: StringFieldUpdateOperationsInput | string
    import_type?: EnumImportTypeFieldUpdateOperationsInput | $Enums.ImportType
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    total_records?: IntFieldUpdateOperationsInput | number
    valid_records?: IntFieldUpdateOperationsInput | number
    invalid_records?: IntFieldUpdateOperationsInput | number
    imported_records?: IntFieldUpdateOperationsInput | number
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_data?: SalesDataUncheckedUpdateManyWithoutImport_batchNestedInput
    product_data?: ProductDataUncheckedUpdateManyWithoutImport_batchNestedInput
    stock_data?: StockDataUncheckedUpdateManyWithoutImport_batchNestedInput
    advertising_data?: AdvertisingDataUncheckedUpdateManyWithoutImport_batchNestedInput
    advertising_settlement?: AdvertisingSettlementUncheckedUpdateManyWithoutImport_batchNestedInput
    returns_and_cancellations?: ReturnsAndCancellationsUncheckedUpdateManyWithoutImport_batchNestedInput
    commission_adjustments?: CommissionAdjustmentsUncheckedUpdateManyWithoutImport_batchNestedInput
    affiliate_samples?: AffiliateSamplesUncheckedUpdateManyWithoutImport_batchNestedInput
  }

  export type ImportBatchCreateWithoutCommission_adjustmentsInput = {
    id?: string
    batch_name: string
    import_type: $Enums.ImportType
    file_name: string
    file_type: string
    total_records: number
    valid_records: number
    invalid_records: number
    imported_records: number
    status: $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    sales_data?: SalesDataCreateNestedManyWithoutImport_batchInput
    product_data?: ProductDataCreateNestedManyWithoutImport_batchInput
    stock_data?: StockDataCreateNestedManyWithoutImport_batchInput
    advertising_data?: AdvertisingDataCreateNestedManyWithoutImport_batchInput
    advertising_settlement?: AdvertisingSettlementCreateNestedManyWithoutImport_batchInput
    returns_and_cancellations?: ReturnsAndCancellationsCreateNestedManyWithoutImport_batchInput
    marketplace_reimbursements?: MarketplaceReimbursementCreateNestedManyWithoutImport_batchInput
    affiliate_samples?: AffiliateSamplesCreateNestedManyWithoutImport_batchInput
  }

  export type ImportBatchUncheckedCreateWithoutCommission_adjustmentsInput = {
    id?: string
    batch_name: string
    import_type: $Enums.ImportType
    file_name: string
    file_type: string
    total_records: number
    valid_records: number
    invalid_records: number
    imported_records: number
    status: $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    sales_data?: SalesDataUncheckedCreateNestedManyWithoutImport_batchInput
    product_data?: ProductDataUncheckedCreateNestedManyWithoutImport_batchInput
    stock_data?: StockDataUncheckedCreateNestedManyWithoutImport_batchInput
    advertising_data?: AdvertisingDataUncheckedCreateNestedManyWithoutImport_batchInput
    advertising_settlement?: AdvertisingSettlementUncheckedCreateNestedManyWithoutImport_batchInput
    returns_and_cancellations?: ReturnsAndCancellationsUncheckedCreateNestedManyWithoutImport_batchInput
    marketplace_reimbursements?: MarketplaceReimbursementUncheckedCreateNestedManyWithoutImport_batchInput
    affiliate_samples?: AffiliateSamplesUncheckedCreateNestedManyWithoutImport_batchInput
  }

  export type ImportBatchCreateOrConnectWithoutCommission_adjustmentsInput = {
    where: ImportBatchWhereUniqueInput
    create: XOR<ImportBatchCreateWithoutCommission_adjustmentsInput, ImportBatchUncheckedCreateWithoutCommission_adjustmentsInput>
  }

  export type ImportBatchUpsertWithoutCommission_adjustmentsInput = {
    update: XOR<ImportBatchUpdateWithoutCommission_adjustmentsInput, ImportBatchUncheckedUpdateWithoutCommission_adjustmentsInput>
    create: XOR<ImportBatchCreateWithoutCommission_adjustmentsInput, ImportBatchUncheckedCreateWithoutCommission_adjustmentsInput>
    where?: ImportBatchWhereInput
  }

  export type ImportBatchUpdateToOneWithWhereWithoutCommission_adjustmentsInput = {
    where?: ImportBatchWhereInput
    data: XOR<ImportBatchUpdateWithoutCommission_adjustmentsInput, ImportBatchUncheckedUpdateWithoutCommission_adjustmentsInput>
  }

  export type ImportBatchUpdateWithoutCommission_adjustmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    batch_name?: StringFieldUpdateOperationsInput | string
    import_type?: EnumImportTypeFieldUpdateOperationsInput | $Enums.ImportType
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    total_records?: IntFieldUpdateOperationsInput | number
    valid_records?: IntFieldUpdateOperationsInput | number
    invalid_records?: IntFieldUpdateOperationsInput | number
    imported_records?: IntFieldUpdateOperationsInput | number
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_data?: SalesDataUpdateManyWithoutImport_batchNestedInput
    product_data?: ProductDataUpdateManyWithoutImport_batchNestedInput
    stock_data?: StockDataUpdateManyWithoutImport_batchNestedInput
    advertising_data?: AdvertisingDataUpdateManyWithoutImport_batchNestedInput
    advertising_settlement?: AdvertisingSettlementUpdateManyWithoutImport_batchNestedInput
    returns_and_cancellations?: ReturnsAndCancellationsUpdateManyWithoutImport_batchNestedInput
    marketplace_reimbursements?: MarketplaceReimbursementUpdateManyWithoutImport_batchNestedInput
    affiliate_samples?: AffiliateSamplesUpdateManyWithoutImport_batchNestedInput
  }

  export type ImportBatchUncheckedUpdateWithoutCommission_adjustmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    batch_name?: StringFieldUpdateOperationsInput | string
    import_type?: EnumImportTypeFieldUpdateOperationsInput | $Enums.ImportType
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    total_records?: IntFieldUpdateOperationsInput | number
    valid_records?: IntFieldUpdateOperationsInput | number
    invalid_records?: IntFieldUpdateOperationsInput | number
    imported_records?: IntFieldUpdateOperationsInput | number
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_data?: SalesDataUncheckedUpdateManyWithoutImport_batchNestedInput
    product_data?: ProductDataUncheckedUpdateManyWithoutImport_batchNestedInput
    stock_data?: StockDataUncheckedUpdateManyWithoutImport_batchNestedInput
    advertising_data?: AdvertisingDataUncheckedUpdateManyWithoutImport_batchNestedInput
    advertising_settlement?: AdvertisingSettlementUncheckedUpdateManyWithoutImport_batchNestedInput
    returns_and_cancellations?: ReturnsAndCancellationsUncheckedUpdateManyWithoutImport_batchNestedInput
    marketplace_reimbursements?: MarketplaceReimbursementUncheckedUpdateManyWithoutImport_batchNestedInput
    affiliate_samples?: AffiliateSamplesUncheckedUpdateManyWithoutImport_batchNestedInput
  }

  export type ImportBatchCreateWithoutAffiliate_samplesInput = {
    id?: string
    batch_name: string
    import_type: $Enums.ImportType
    file_name: string
    file_type: string
    total_records: number
    valid_records: number
    invalid_records: number
    imported_records: number
    status: $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    sales_data?: SalesDataCreateNestedManyWithoutImport_batchInput
    product_data?: ProductDataCreateNestedManyWithoutImport_batchInput
    stock_data?: StockDataCreateNestedManyWithoutImport_batchInput
    advertising_data?: AdvertisingDataCreateNestedManyWithoutImport_batchInput
    advertising_settlement?: AdvertisingSettlementCreateNestedManyWithoutImport_batchInput
    returns_and_cancellations?: ReturnsAndCancellationsCreateNestedManyWithoutImport_batchInput
    marketplace_reimbursements?: MarketplaceReimbursementCreateNestedManyWithoutImport_batchInput
    commission_adjustments?: CommissionAdjustmentsCreateNestedManyWithoutImport_batchInput
  }

  export type ImportBatchUncheckedCreateWithoutAffiliate_samplesInput = {
    id?: string
    batch_name: string
    import_type: $Enums.ImportType
    file_name: string
    file_type: string
    total_records: number
    valid_records: number
    invalid_records: number
    imported_records: number
    status: $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string
    updated_at?: Date | string
    sales_data?: SalesDataUncheckedCreateNestedManyWithoutImport_batchInput
    product_data?: ProductDataUncheckedCreateNestedManyWithoutImport_batchInput
    stock_data?: StockDataUncheckedCreateNestedManyWithoutImport_batchInput
    advertising_data?: AdvertisingDataUncheckedCreateNestedManyWithoutImport_batchInput
    advertising_settlement?: AdvertisingSettlementUncheckedCreateNestedManyWithoutImport_batchInput
    returns_and_cancellations?: ReturnsAndCancellationsUncheckedCreateNestedManyWithoutImport_batchInput
    marketplace_reimbursements?: MarketplaceReimbursementUncheckedCreateNestedManyWithoutImport_batchInput
    commission_adjustments?: CommissionAdjustmentsUncheckedCreateNestedManyWithoutImport_batchInput
  }

  export type ImportBatchCreateOrConnectWithoutAffiliate_samplesInput = {
    where: ImportBatchWhereUniqueInput
    create: XOR<ImportBatchCreateWithoutAffiliate_samplesInput, ImportBatchUncheckedCreateWithoutAffiliate_samplesInput>
  }

  export type ImportBatchUpsertWithoutAffiliate_samplesInput = {
    update: XOR<ImportBatchUpdateWithoutAffiliate_samplesInput, ImportBatchUncheckedUpdateWithoutAffiliate_samplesInput>
    create: XOR<ImportBatchCreateWithoutAffiliate_samplesInput, ImportBatchUncheckedCreateWithoutAffiliate_samplesInput>
    where?: ImportBatchWhereInput
  }

  export type ImportBatchUpdateToOneWithWhereWithoutAffiliate_samplesInput = {
    where?: ImportBatchWhereInput
    data: XOR<ImportBatchUpdateWithoutAffiliate_samplesInput, ImportBatchUncheckedUpdateWithoutAffiliate_samplesInput>
  }

  export type ImportBatchUpdateWithoutAffiliate_samplesInput = {
    id?: StringFieldUpdateOperationsInput | string
    batch_name?: StringFieldUpdateOperationsInput | string
    import_type?: EnumImportTypeFieldUpdateOperationsInput | $Enums.ImportType
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    total_records?: IntFieldUpdateOperationsInput | number
    valid_records?: IntFieldUpdateOperationsInput | number
    invalid_records?: IntFieldUpdateOperationsInput | number
    imported_records?: IntFieldUpdateOperationsInput | number
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_data?: SalesDataUpdateManyWithoutImport_batchNestedInput
    product_data?: ProductDataUpdateManyWithoutImport_batchNestedInput
    stock_data?: StockDataUpdateManyWithoutImport_batchNestedInput
    advertising_data?: AdvertisingDataUpdateManyWithoutImport_batchNestedInput
    advertising_settlement?: AdvertisingSettlementUpdateManyWithoutImport_batchNestedInput
    returns_and_cancellations?: ReturnsAndCancellationsUpdateManyWithoutImport_batchNestedInput
    marketplace_reimbursements?: MarketplaceReimbursementUpdateManyWithoutImport_batchNestedInput
    commission_adjustments?: CommissionAdjustmentsUpdateManyWithoutImport_batchNestedInput
  }

  export type ImportBatchUncheckedUpdateWithoutAffiliate_samplesInput = {
    id?: StringFieldUpdateOperationsInput | string
    batch_name?: StringFieldUpdateOperationsInput | string
    import_type?: EnumImportTypeFieldUpdateOperationsInput | $Enums.ImportType
    file_name?: StringFieldUpdateOperationsInput | string
    file_type?: StringFieldUpdateOperationsInput | string
    total_records?: IntFieldUpdateOperationsInput | number
    valid_records?: IntFieldUpdateOperationsInput | number
    invalid_records?: IntFieldUpdateOperationsInput | number
    imported_records?: IntFieldUpdateOperationsInput | number
    status?: EnumImportStatusFieldUpdateOperationsInput | $Enums.ImportStatus
    error_details?: NullableJsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sales_data?: SalesDataUncheckedUpdateManyWithoutImport_batchNestedInput
    product_data?: ProductDataUncheckedUpdateManyWithoutImport_batchNestedInput
    stock_data?: StockDataUncheckedUpdateManyWithoutImport_batchNestedInput
    advertising_data?: AdvertisingDataUncheckedUpdateManyWithoutImport_batchNestedInput
    advertising_settlement?: AdvertisingSettlementUncheckedUpdateManyWithoutImport_batchNestedInput
    returns_and_cancellations?: ReturnsAndCancellationsUncheckedUpdateManyWithoutImport_batchNestedInput
    marketplace_reimbursements?: MarketplaceReimbursementUncheckedUpdateManyWithoutImport_batchNestedInput
    commission_adjustments?: CommissionAdjustmentsUncheckedUpdateManyWithoutImport_batchNestedInput
  }

  export type PurchaseOrderCreateWithoutSupplierInput = {
    id?: string
    po_number: string
    po_date: Date | string
    expected_date: Date | string
    delivery_date?: Date | string | null
    status?: $Enums.POStatus
    total_amount?: number
    items_count?: number
    notes?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    items?: PurchaseOrderItemCreateNestedManyWithoutPurchase_orderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutSupplierInput = {
    id?: string
    po_number: string
    po_date: Date | string
    expected_date: Date | string
    delivery_date?: Date | string | null
    status?: $Enums.POStatus
    total_amount?: number
    items_count?: number
    notes?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    items?: PurchaseOrderItemUncheckedCreateNestedManyWithoutPurchase_orderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutSupplierInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseOrderCreateManySupplierInputEnvelope = {
    data: PurchaseOrderCreateManySupplierInput | PurchaseOrderCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutSupplierInput, PurchaseOrderUncheckedUpdateWithoutSupplierInput>
    create: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutSupplierInput, PurchaseOrderUncheckedUpdateWithoutSupplierInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutSupplierInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutSupplierInput>
  }

  export type PurchaseOrderScalarWhereInput = {
    AND?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    OR?: PurchaseOrderScalarWhereInput[]
    NOT?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    id?: StringFilter<"PurchaseOrder"> | string
    po_number?: StringFilter<"PurchaseOrder"> | string
    supplier_id?: StringFilter<"PurchaseOrder"> | string
    po_date?: DateTimeFilter<"PurchaseOrder"> | Date | string
    expected_date?: DateTimeFilter<"PurchaseOrder"> | Date | string
    delivery_date?: DateTimeNullableFilter<"PurchaseOrder"> | Date | string | null
    status?: EnumPOStatusFilter<"PurchaseOrder"> | $Enums.POStatus
    total_amount?: FloatFilter<"PurchaseOrder"> | number
    items_count?: IntFilter<"PurchaseOrder"> | number
    notes?: StringNullableFilter<"PurchaseOrder"> | string | null
    created_by?: StringNullableFilter<"PurchaseOrder"> | string | null
    created_at?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updated_at?: DateTimeFilter<"PurchaseOrder"> | Date | string
  }

  export type SupplierCreateWithoutPurchase_ordersInput = {
    id?: string
    code: string
    name: string
    contact_person: string
    phone: string
    email: string
    address: string
    category: string
    rating?: number
    status?: $Enums.SupplierStatus
    payment_terms: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SupplierUncheckedCreateWithoutPurchase_ordersInput = {
    id?: string
    code: string
    name: string
    contact_person: string
    phone: string
    email: string
    address: string
    category: string
    rating?: number
    status?: $Enums.SupplierStatus
    payment_terms: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SupplierCreateOrConnectWithoutPurchase_ordersInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutPurchase_ordersInput, SupplierUncheckedCreateWithoutPurchase_ordersInput>
  }

  export type PurchaseOrderItemCreateWithoutPurchase_orderInput = {
    id?: string
    material_id: string
    material_name?: string | null
    material_description?: string | null
    quantity: number
    unit_price: number
    total_price: number
    received_quantity?: number | null
    unit: string
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PurchaseOrderItemUncheckedCreateWithoutPurchase_orderInput = {
    id?: string
    material_id: string
    material_name?: string | null
    material_description?: string | null
    quantity: number
    unit_price: number
    total_price: number
    received_quantity?: number | null
    unit: string
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PurchaseOrderItemCreateOrConnectWithoutPurchase_orderInput = {
    where: PurchaseOrderItemWhereUniqueInput
    create: XOR<PurchaseOrderItemCreateWithoutPurchase_orderInput, PurchaseOrderItemUncheckedCreateWithoutPurchase_orderInput>
  }

  export type PurchaseOrderItemCreateManyPurchase_orderInputEnvelope = {
    data: PurchaseOrderItemCreateManyPurchase_orderInput | PurchaseOrderItemCreateManyPurchase_orderInput[]
    skipDuplicates?: boolean
  }

  export type SupplierUpsertWithoutPurchase_ordersInput = {
    update: XOR<SupplierUpdateWithoutPurchase_ordersInput, SupplierUncheckedUpdateWithoutPurchase_ordersInput>
    create: XOR<SupplierCreateWithoutPurchase_ordersInput, SupplierUncheckedCreateWithoutPurchase_ordersInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutPurchase_ordersInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutPurchase_ordersInput, SupplierUncheckedUpdateWithoutPurchase_ordersInput>
  }

  export type SupplierUpdateWithoutPurchase_ordersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    status?: EnumSupplierStatusFieldUpdateOperationsInput | $Enums.SupplierStatus
    payment_terms?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUncheckedUpdateWithoutPurchase_ordersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    status?: EnumSupplierStatusFieldUpdateOperationsInput | $Enums.SupplierStatus
    payment_terms?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemUpsertWithWhereUniqueWithoutPurchase_orderInput = {
    where: PurchaseOrderItemWhereUniqueInput
    update: XOR<PurchaseOrderItemUpdateWithoutPurchase_orderInput, PurchaseOrderItemUncheckedUpdateWithoutPurchase_orderInput>
    create: XOR<PurchaseOrderItemCreateWithoutPurchase_orderInput, PurchaseOrderItemUncheckedCreateWithoutPurchase_orderInput>
  }

  export type PurchaseOrderItemUpdateWithWhereUniqueWithoutPurchase_orderInput = {
    where: PurchaseOrderItemWhereUniqueInput
    data: XOR<PurchaseOrderItemUpdateWithoutPurchase_orderInput, PurchaseOrderItemUncheckedUpdateWithoutPurchase_orderInput>
  }

  export type PurchaseOrderItemUpdateManyWithWhereWithoutPurchase_orderInput = {
    where: PurchaseOrderItemScalarWhereInput
    data: XOR<PurchaseOrderItemUpdateManyMutationInput, PurchaseOrderItemUncheckedUpdateManyWithoutPurchase_orderInput>
  }

  export type PurchaseOrderItemScalarWhereInput = {
    AND?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
    OR?: PurchaseOrderItemScalarWhereInput[]
    NOT?: PurchaseOrderItemScalarWhereInput | PurchaseOrderItemScalarWhereInput[]
    id?: StringFilter<"PurchaseOrderItem"> | string
    purchase_order_id?: StringFilter<"PurchaseOrderItem"> | string
    material_id?: StringFilter<"PurchaseOrderItem"> | string
    material_name?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    material_description?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    quantity?: FloatFilter<"PurchaseOrderItem"> | number
    unit_price?: FloatFilter<"PurchaseOrderItem"> | number
    total_price?: FloatFilter<"PurchaseOrderItem"> | number
    received_quantity?: FloatNullableFilter<"PurchaseOrderItem"> | number | null
    unit?: StringFilter<"PurchaseOrderItem"> | string
    notes?: StringNullableFilter<"PurchaseOrderItem"> | string | null
    created_at?: DateTimeFilter<"PurchaseOrderItem"> | Date | string
    updated_at?: DateTimeFilter<"PurchaseOrderItem"> | Date | string
  }

  export type PurchaseOrderCreateWithoutItemsInput = {
    id?: string
    po_number: string
    po_date: Date | string
    expected_date: Date | string
    delivery_date?: Date | string | null
    status?: $Enums.POStatus
    total_amount?: number
    items_count?: number
    notes?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    supplier: SupplierCreateNestedOneWithoutPurchase_ordersInput
  }

  export type PurchaseOrderUncheckedCreateWithoutItemsInput = {
    id?: string
    po_number: string
    supplier_id: string
    po_date: Date | string
    expected_date: Date | string
    delivery_date?: Date | string | null
    status?: $Enums.POStatus
    total_amount?: number
    items_count?: number
    notes?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PurchaseOrderCreateOrConnectWithoutItemsInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
  }

  export type PurchaseOrderUpsertWithoutItemsInput = {
    update: XOR<PurchaseOrderUpdateWithoutItemsInput, PurchaseOrderUncheckedUpdateWithoutItemsInput>
    create: XOR<PurchaseOrderCreateWithoutItemsInput, PurchaseOrderUncheckedCreateWithoutItemsInput>
    where?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: PurchaseOrderWhereInput
    data: XOR<PurchaseOrderUpdateWithoutItemsInput, PurchaseOrderUncheckedUpdateWithoutItemsInput>
  }

  export type PurchaseOrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    po_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expected_date?: DateTimeFieldUpdateOperationsInput | Date | string
    delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPOStatusFieldUpdateOperationsInput | $Enums.POStatus
    total_amount?: FloatFieldUpdateOperationsInput | number
    items_count?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutPurchase_ordersNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    supplier_id?: StringFieldUpdateOperationsInput | string
    po_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expected_date?: DateTimeFieldUpdateOperationsInput | Date | string
    delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPOStatusFieldUpdateOperationsInput | $Enums.POStatus
    total_amount?: FloatFieldUpdateOperationsInput | number
    items_count?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportMetadataCreateWithoutImport_historyInput = {
    id?: string
    metadata_type: string
    metadata: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type ImportMetadataUncheckedCreateWithoutImport_historyInput = {
    id?: string
    metadata_type: string
    metadata: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type ImportMetadataCreateOrConnectWithoutImport_historyInput = {
    where: ImportMetadataWhereUniqueInput
    create: XOR<ImportMetadataCreateWithoutImport_historyInput, ImportMetadataUncheckedCreateWithoutImport_historyInput>
  }

  export type ImportMetadataCreateManyImport_historyInputEnvelope = {
    data: ImportMetadataCreateManyImport_historyInput | ImportMetadataCreateManyImport_historyInput[]
    skipDuplicates?: boolean
  }

  export type ImportMetadataUpsertWithWhereUniqueWithoutImport_historyInput = {
    where: ImportMetadataWhereUniqueInput
    update: XOR<ImportMetadataUpdateWithoutImport_historyInput, ImportMetadataUncheckedUpdateWithoutImport_historyInput>
    create: XOR<ImportMetadataCreateWithoutImport_historyInput, ImportMetadataUncheckedCreateWithoutImport_historyInput>
  }

  export type ImportMetadataUpdateWithWhereUniqueWithoutImport_historyInput = {
    where: ImportMetadataWhereUniqueInput
    data: XOR<ImportMetadataUpdateWithoutImport_historyInput, ImportMetadataUncheckedUpdateWithoutImport_historyInput>
  }

  export type ImportMetadataUpdateManyWithWhereWithoutImport_historyInput = {
    where: ImportMetadataScalarWhereInput
    data: XOR<ImportMetadataUpdateManyMutationInput, ImportMetadataUncheckedUpdateManyWithoutImport_historyInput>
  }

  export type ImportMetadataScalarWhereInput = {
    AND?: ImportMetadataScalarWhereInput | ImportMetadataScalarWhereInput[]
    OR?: ImportMetadataScalarWhereInput[]
    NOT?: ImportMetadataScalarWhereInput | ImportMetadataScalarWhereInput[]
    id?: StringFilter<"ImportMetadata"> | string
    import_history_id?: StringFilter<"ImportMetadata"> | string
    metadata_type?: StringFilter<"ImportMetadata"> | string
    metadata?: JsonFilter<"ImportMetadata">
    created_at?: DateTimeFilter<"ImportMetadata"> | Date | string
  }

  export type InvoiceItemCreateWithoutInvoiceInput = {
    id?: string
    product_name: string
    quantity: number
    unit_price: number
    total: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InvoiceItemUncheckedCreateWithoutInvoiceInput = {
    id?: string
    product_name: string
    quantity: number
    unit_price: number
    total: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InvoiceItemCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemCreateManyInvoiceInputEnvelope = {
    data: InvoiceItemCreateManyInvoiceInput | InvoiceItemCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceItemScalarWhereInput = {
    AND?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    OR?: InvoiceItemScalarWhereInput[]
    NOT?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    id?: StringFilter<"InvoiceItem"> | string
    invoice_id?: StringFilter<"InvoiceItem"> | string
    product_name?: StringFilter<"InvoiceItem"> | string
    quantity?: IntFilter<"InvoiceItem"> | number
    unit_price?: FloatFilter<"InvoiceItem"> | number
    total?: FloatFilter<"InvoiceItem"> | number
    created_at?: DateTimeFilter<"InvoiceItem"> | Date | string
    updated_at?: DateTimeFilter<"InvoiceItem"> | Date | string
  }

  export type InvoiceCreateWithoutItemsInput = {
    id?: string
    invoice_number: string
    customer_name: string
    customer_email: string
    customer_phone?: string | null
    issue_date?: Date | string
    due_date: Date | string
    status?: $Enums.InvoiceStatus
    type?: $Enums.InvoiceType
    subtotal: number
    tax?: number
    discount?: number
    total: number
    notes?: string | null
    payment_method?: string | null
    payment_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
  }

  export type InvoiceUncheckedCreateWithoutItemsInput = {
    id?: string
    invoice_number: string
    customer_name: string
    customer_email: string
    customer_phone?: string | null
    issue_date?: Date | string
    due_date: Date | string
    status?: $Enums.InvoiceStatus
    type?: $Enums.InvoiceType
    subtotal: number
    tax?: number
    discount?: number
    total: number
    notes?: string | null
    payment_method?: string | null
    payment_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    created_by?: string | null
  }

  export type InvoiceCreateOrConnectWithoutItemsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
  }

  export type InvoiceUpsertWithoutItemsInput = {
    update: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type InvoiceUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    customer_name?: StringFieldUpdateOperationsInput | string
    customer_email?: StringFieldUpdateOperationsInput | string
    customer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    customer_name?: StringFieldUpdateOperationsInput | string
    customer_email?: StringFieldUpdateOperationsInput | string
    customer_phone?: NullableStringFieldUpdateOperationsInput | string | null
    issue_date?: DateTimeFieldUpdateOperationsInput | Date | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    type?: EnumInvoiceTypeFieldUpdateOperationsInput | $Enums.InvoiceType
    subtotal?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AffiliateProductSaleCreateWithoutEndorsementInput = {
    id?: string
    product_name: string
    quantity?: number
    unit_price?: number
    total_sales?: number
    commission?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AffiliateProductSaleUncheckedCreateWithoutEndorsementInput = {
    id?: string
    product_name: string
    quantity?: number
    unit_price?: number
    total_sales?: number
    commission?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AffiliateProductSaleCreateOrConnectWithoutEndorsementInput = {
    where: AffiliateProductSaleWhereUniqueInput
    create: XOR<AffiliateProductSaleCreateWithoutEndorsementInput, AffiliateProductSaleUncheckedCreateWithoutEndorsementInput>
  }

  export type AffiliateProductSaleCreateManyEndorsementInputEnvelope = {
    data: AffiliateProductSaleCreateManyEndorsementInput | AffiliateProductSaleCreateManyEndorsementInput[]
    skipDuplicates?: boolean
  }

  export type AffiliateProductSaleUpsertWithWhereUniqueWithoutEndorsementInput = {
    where: AffiliateProductSaleWhereUniqueInput
    update: XOR<AffiliateProductSaleUpdateWithoutEndorsementInput, AffiliateProductSaleUncheckedUpdateWithoutEndorsementInput>
    create: XOR<AffiliateProductSaleCreateWithoutEndorsementInput, AffiliateProductSaleUncheckedCreateWithoutEndorsementInput>
  }

  export type AffiliateProductSaleUpdateWithWhereUniqueWithoutEndorsementInput = {
    where: AffiliateProductSaleWhereUniqueInput
    data: XOR<AffiliateProductSaleUpdateWithoutEndorsementInput, AffiliateProductSaleUncheckedUpdateWithoutEndorsementInput>
  }

  export type AffiliateProductSaleUpdateManyWithWhereWithoutEndorsementInput = {
    where: AffiliateProductSaleScalarWhereInput
    data: XOR<AffiliateProductSaleUpdateManyMutationInput, AffiliateProductSaleUncheckedUpdateManyWithoutEndorsementInput>
  }

  export type AffiliateProductSaleScalarWhereInput = {
    AND?: AffiliateProductSaleScalarWhereInput | AffiliateProductSaleScalarWhereInput[]
    OR?: AffiliateProductSaleScalarWhereInput[]
    NOT?: AffiliateProductSaleScalarWhereInput | AffiliateProductSaleScalarWhereInput[]
    id?: StringFilter<"AffiliateProductSale"> | string
    endorsement_id?: StringFilter<"AffiliateProductSale"> | string
    product_name?: StringFilter<"AffiliateProductSale"> | string
    quantity?: IntFilter<"AffiliateProductSale"> | number
    unit_price?: FloatFilter<"AffiliateProductSale"> | number
    total_sales?: FloatFilter<"AffiliateProductSale"> | number
    commission?: FloatFilter<"AffiliateProductSale"> | number
    created_at?: DateTimeFilter<"AffiliateProductSale"> | Date | string
    updated_at?: DateTimeFilter<"AffiliateProductSale"> | Date | string
  }

  export type AffiliateEndorsementCreateWithoutProduct_salesInput = {
    id?: string
    campaign_name: string
    affiliate_name: string
    affiliate_type: string
    start_date: Date | string
    end_date: Date | string
    endorse_fee?: number
    target_sales?: number
    actual_sales?: number
    total_commission?: number
    payment_method?: string | null
    platform?: AffiliateEndorsementCreateplatformInput | string[]
    content_type?: string | null
    followers?: number | null
    engagement?: number | null
    reference?: string | null
    notes?: string | null
    status?: string
    roi?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AffiliateEndorsementUncheckedCreateWithoutProduct_salesInput = {
    id?: string
    campaign_name: string
    affiliate_name: string
    affiliate_type: string
    start_date: Date | string
    end_date: Date | string
    endorse_fee?: number
    target_sales?: number
    actual_sales?: number
    total_commission?: number
    payment_method?: string | null
    platform?: AffiliateEndorsementCreateplatformInput | string[]
    content_type?: string | null
    followers?: number | null
    engagement?: number | null
    reference?: string | null
    notes?: string | null
    status?: string
    roi?: number | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AffiliateEndorsementCreateOrConnectWithoutProduct_salesInput = {
    where: AffiliateEndorsementWhereUniqueInput
    create: XOR<AffiliateEndorsementCreateWithoutProduct_salesInput, AffiliateEndorsementUncheckedCreateWithoutProduct_salesInput>
  }

  export type AffiliateEndorsementUpsertWithoutProduct_salesInput = {
    update: XOR<AffiliateEndorsementUpdateWithoutProduct_salesInput, AffiliateEndorsementUncheckedUpdateWithoutProduct_salesInput>
    create: XOR<AffiliateEndorsementCreateWithoutProduct_salesInput, AffiliateEndorsementUncheckedCreateWithoutProduct_salesInput>
    where?: AffiliateEndorsementWhereInput
  }

  export type AffiliateEndorsementUpdateToOneWithWhereWithoutProduct_salesInput = {
    where?: AffiliateEndorsementWhereInput
    data: XOR<AffiliateEndorsementUpdateWithoutProduct_salesInput, AffiliateEndorsementUncheckedUpdateWithoutProduct_salesInput>
  }

  export type AffiliateEndorsementUpdateWithoutProduct_salesInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaign_name?: StringFieldUpdateOperationsInput | string
    affiliate_name?: StringFieldUpdateOperationsInput | string
    affiliate_type?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    endorse_fee?: FloatFieldUpdateOperationsInput | number
    target_sales?: FloatFieldUpdateOperationsInput | number
    actual_sales?: FloatFieldUpdateOperationsInput | number
    total_commission?: FloatFieldUpdateOperationsInput | number
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: AffiliateEndorsementUpdateplatformInput | string[]
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    engagement?: NullableFloatFieldUpdateOperationsInput | number | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    roi?: NullableFloatFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateEndorsementUncheckedUpdateWithoutProduct_salesInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaign_name?: StringFieldUpdateOperationsInput | string
    affiliate_name?: StringFieldUpdateOperationsInput | string
    affiliate_type?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    endorse_fee?: FloatFieldUpdateOperationsInput | number
    target_sales?: FloatFieldUpdateOperationsInput | number
    actual_sales?: FloatFieldUpdateOperationsInput | number
    total_commission?: FloatFieldUpdateOperationsInput | number
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: AffiliateEndorsementUpdateplatformInput | string[]
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    followers?: NullableIntFieldUpdateOperationsInput | number | null
    engagement?: NullableFloatFieldUpdateOperationsInput | number | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    roi?: NullableFloatFieldUpdateOperationsInput | number | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportHistoryCreateWithoutImportMetadataInput = {
    id?: string
    timestamp?: Date | string
    user_id?: string | null
    import_type: string
    file_name?: string | null
    file_size?: number | null
    file_hash?: string | null
    total_records: number
    imported_records: number
    failed_records?: number
    duplicate_records?: number
    success_rate?: number | null
    processing_time_ms?: number | null
    import_status?: $Enums.ImportHistoryStatus
    error_details?: string | null
    import_summary?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    source_ip?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ImportHistoryUncheckedCreateWithoutImportMetadataInput = {
    id?: string
    timestamp?: Date | string
    user_id?: string | null
    import_type: string
    file_name?: string | null
    file_size?: number | null
    file_hash?: string | null
    total_records: number
    imported_records: number
    failed_records?: number
    duplicate_records?: number
    success_rate?: number | null
    processing_time_ms?: number | null
    import_status?: $Enums.ImportHistoryStatus
    error_details?: string | null
    import_summary?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    source_ip?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ImportHistoryCreateOrConnectWithoutImportMetadataInput = {
    where: ImportHistoryWhereUniqueInput
    create: XOR<ImportHistoryCreateWithoutImportMetadataInput, ImportHistoryUncheckedCreateWithoutImportMetadataInput>
  }

  export type ImportHistoryUpsertWithoutImportMetadataInput = {
    update: XOR<ImportHistoryUpdateWithoutImportMetadataInput, ImportHistoryUncheckedUpdateWithoutImportMetadataInput>
    create: XOR<ImportHistoryCreateWithoutImportMetadataInput, ImportHistoryUncheckedCreateWithoutImportMetadataInput>
    where?: ImportHistoryWhereInput
  }

  export type ImportHistoryUpdateToOneWithWhereWithoutImportMetadataInput = {
    where?: ImportHistoryWhereInput
    data: XOR<ImportHistoryUpdateWithoutImportMetadataInput, ImportHistoryUncheckedUpdateWithoutImportMetadataInput>
  }

  export type ImportHistoryUpdateWithoutImportMetadataInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    import_type?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    file_hash?: NullableStringFieldUpdateOperationsInput | string | null
    total_records?: IntFieldUpdateOperationsInput | number
    imported_records?: IntFieldUpdateOperationsInput | number
    failed_records?: IntFieldUpdateOperationsInput | number
    duplicate_records?: IntFieldUpdateOperationsInput | number
    success_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    processing_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    import_status?: EnumImportHistoryStatusFieldUpdateOperationsInput | $Enums.ImportHistoryStatus
    error_details?: NullableStringFieldUpdateOperationsInput | string | null
    import_summary?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    source_ip?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportHistoryUncheckedUpdateWithoutImportMetadataInput = {
    id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    import_type?: StringFieldUpdateOperationsInput | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_size?: NullableIntFieldUpdateOperationsInput | number | null
    file_hash?: NullableStringFieldUpdateOperationsInput | string | null
    total_records?: IntFieldUpdateOperationsInput | number
    imported_records?: IntFieldUpdateOperationsInput | number
    failed_records?: IntFieldUpdateOperationsInput | number
    duplicate_records?: IntFieldUpdateOperationsInput | number
    success_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    processing_time_ms?: NullableIntFieldUpdateOperationsInput | number | null
    import_status?: EnumImportHistoryStatusFieldUpdateOperationsInput | $Enums.ImportHistoryStatus
    error_details?: NullableStringFieldUpdateOperationsInput | string | null
    import_summary?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    source_ip?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TailorProductionCreateWithoutTailorInput = {
    id?: string
    product_name: string
    color: string
    size: string
    finished_stock?: number
    meters_needed?: number
    cost_per_piece?: number
    defective_stock?: number | null
    additional_costs?: number | null
    additional_cost_description?: string | null
    delivery_date?: Date | string | null
    notes?: string | null
    status?: $Enums.TailorProductionStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TailorProductionUncheckedCreateWithoutTailorInput = {
    id?: string
    product_name: string
    color: string
    size: string
    finished_stock?: number
    meters_needed?: number
    cost_per_piece?: number
    defective_stock?: number | null
    additional_costs?: number | null
    additional_cost_description?: string | null
    delivery_date?: Date | string | null
    notes?: string | null
    status?: $Enums.TailorProductionStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TailorProductionCreateOrConnectWithoutTailorInput = {
    where: TailorProductionWhereUniqueInput
    create: XOR<TailorProductionCreateWithoutTailorInput, TailorProductionUncheckedCreateWithoutTailorInput>
  }

  export type TailorProductionCreateManyTailorInputEnvelope = {
    data: TailorProductionCreateManyTailorInput | TailorProductionCreateManyTailorInput[]
    skipDuplicates?: boolean
  }

  export type TailorProductionUpsertWithWhereUniqueWithoutTailorInput = {
    where: TailorProductionWhereUniqueInput
    update: XOR<TailorProductionUpdateWithoutTailorInput, TailorProductionUncheckedUpdateWithoutTailorInput>
    create: XOR<TailorProductionCreateWithoutTailorInput, TailorProductionUncheckedCreateWithoutTailorInput>
  }

  export type TailorProductionUpdateWithWhereUniqueWithoutTailorInput = {
    where: TailorProductionWhereUniqueInput
    data: XOR<TailorProductionUpdateWithoutTailorInput, TailorProductionUncheckedUpdateWithoutTailorInput>
  }

  export type TailorProductionUpdateManyWithWhereWithoutTailorInput = {
    where: TailorProductionScalarWhereInput
    data: XOR<TailorProductionUpdateManyMutationInput, TailorProductionUncheckedUpdateManyWithoutTailorInput>
  }

  export type TailorProductionScalarWhereInput = {
    AND?: TailorProductionScalarWhereInput | TailorProductionScalarWhereInput[]
    OR?: TailorProductionScalarWhereInput[]
    NOT?: TailorProductionScalarWhereInput | TailorProductionScalarWhereInput[]
    id?: StringFilter<"TailorProduction"> | string
    tailor_id?: StringFilter<"TailorProduction"> | string
    product_name?: StringFilter<"TailorProduction"> | string
    color?: StringFilter<"TailorProduction"> | string
    size?: StringFilter<"TailorProduction"> | string
    finished_stock?: IntFilter<"TailorProduction"> | number
    meters_needed?: FloatFilter<"TailorProduction"> | number
    cost_per_piece?: FloatFilter<"TailorProduction"> | number
    defective_stock?: IntNullableFilter<"TailorProduction"> | number | null
    additional_costs?: FloatNullableFilter<"TailorProduction"> | number | null
    additional_cost_description?: StringNullableFilter<"TailorProduction"> | string | null
    delivery_date?: DateTimeNullableFilter<"TailorProduction"> | Date | string | null
    notes?: StringNullableFilter<"TailorProduction"> | string | null
    status?: EnumTailorProductionStatusFilter<"TailorProduction"> | $Enums.TailorProductionStatus
    created_at?: DateTimeFilter<"TailorProduction"> | Date | string
    updated_at?: DateTimeFilter<"TailorProduction"> | Date | string
  }

  export type TailorCreateWithoutProductionsInput = {
    id?: string
    code: string
    name: string
    contact_person: string
    phone: string
    email: string
    address: string
    specialization: string
    rating?: number
    status?: $Enums.TailorStatus
    payment_terms?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TailorUncheckedCreateWithoutProductionsInput = {
    id?: string
    code: string
    name: string
    contact_person: string
    phone: string
    email: string
    address: string
    specialization: string
    rating?: number
    status?: $Enums.TailorStatus
    payment_terms?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TailorCreateOrConnectWithoutProductionsInput = {
    where: TailorWhereUniqueInput
    create: XOR<TailorCreateWithoutProductionsInput, TailorUncheckedCreateWithoutProductionsInput>
  }

  export type TailorUpsertWithoutProductionsInput = {
    update: XOR<TailorUpdateWithoutProductionsInput, TailorUncheckedUpdateWithoutProductionsInput>
    create: XOR<TailorCreateWithoutProductionsInput, TailorUncheckedCreateWithoutProductionsInput>
    where?: TailorWhereInput
  }

  export type TailorUpdateToOneWithWhereWithoutProductionsInput = {
    where?: TailorWhereInput
    data: XOR<TailorUpdateWithoutProductionsInput, TailorUncheckedUpdateWithoutProductionsInput>
  }

  export type TailorUpdateWithoutProductionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    specialization?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    status?: EnumTailorStatusFieldUpdateOperationsInput | $Enums.TailorStatus
    payment_terms?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TailorUncheckedUpdateWithoutProductionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_person?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    specialization?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    status?: EnumTailorStatusFieldUpdateOperationsInput | $Enums.TailorStatus
    payment_terms?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockDataCreateManyProductInput = {
    id?: string
    movement_type: $Enums.StockMovementType
    quantity: number
    reference_number?: string | null
    notes?: string | null
    movement_date: Date | string
    import_batch_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StockDataUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    movement_type?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movement_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    import_batch?: ImportBatchUpdateOneWithoutStock_dataNestedInput
  }

  export type StockDataUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    movement_type?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movement_date?: DateTimeFieldUpdateOperationsInput | Date | string
    import_batch_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockDataUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    movement_type?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movement_date?: DateTimeFieldUpdateOperationsInput | Date | string
    import_batch_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesDataCreateManyImport_batchInput = {
    id?: string
    order_id: string
    seller_sku: string
    product_name: string
    color: string
    size: string
    quantity: number
    order_amount: number
    created_time: Date | string
    delivered_time?: Date | string | null
    settlement_amount?: number | null
    total_revenue?: number | null
    hpp?: number | null
    total?: number | null
    marketplace?: string | null
    customer?: string | null
    province?: string | null
    regency_city?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProductDataCreateManyImport_batchInput = {
    id?: string
    product_code: string
    product_name: string
    category: string
    brand: string
    size: string
    color: string
    price: number
    cost: number
    stock_quantity: number
    min_stock: number
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StockDataCreateManyImport_batchInput = {
    id?: string
    product_code: string
    movement_type: $Enums.StockMovementType
    quantity: number
    reference_number?: string | null
    notes?: string | null
    movement_date: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AdvertisingDataCreateManyImport_batchInput = {
    id?: string
    campaign_name: string
    ad_creative_type?: string | null
    ad_creative?: string | null
    account_name?: string | null
    cost?: number
    conversions?: number
    cpa?: number | null
    revenue?: number
    roi?: number | null
    impressions?: number
    clicks?: number
    ctr?: number | null
    conversion_rate?: number | null
    date_start: Date | string
    date_end: Date | string
    marketplace?: string | null
    nama_produk?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AdvertisingSettlementCreateManyImport_batchInput = {
    order_id: string
    type?: string | null
    order_created_time: Date | string
    order_settled_time: Date | string
    settlement_amount?: number
    settlement_period?: string | null
    account_name?: string | null
    marketplace?: string | null
    currency?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ReturnsAndCancellationsCreateManyImport_batchInput = {
    id?: string
    original_order_id?: string | null
    original_sales_id?: string | null
    type: string
    reason?: string | null
    return_date: Date | string
    returned_amount?: number
    refund_amount?: number
    restocking_fee?: number
    shipping_cost_loss?: number
    product_name: string
    quantity_returned?: number
    original_price?: number
    marketplace?: string | null
    product_condition?: string | null
    resellable?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MarketplaceReimbursementCreateManyImport_batchInput = {
    id?: string
    claim_id?: string | null
    reimbursement_type: string
    claim_amount?: number
    approved_amount?: number
    received_amount?: number
    processing_fee?: number
    incident_date: Date | string
    claim_date: Date | string
    approval_date?: Date | string | null
    received_date?: Date | string | null
    affected_order_id?: string | null
    product_name?: string | null
    marketplace: string
    status?: string
    notes?: string | null
    evidence_provided?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type CommissionAdjustmentsCreateManyImport_batchInput = {
    id?: string
    original_order_id?: string | null
    original_sales_id?: string | null
    adjustment_type: string
    reason?: string | null
    original_commission?: number
    adjustment_amount?: number
    final_commission?: number
    marketplace: string
    commission_rate?: number | null
    dynamic_rate_applied?: boolean
    transaction_date: Date | string
    adjustment_date: Date | string
    product_name?: string | null
    quantity?: number
    product_price?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AffiliateSamplesCreateManyImport_batchInput = {
    id?: string
    affiliate_name: string
    affiliate_platform?: string | null
    affiliate_contact?: string | null
    product_name: string
    product_sku?: string | null
    quantity_given?: number
    product_cost?: number
    total_cost?: number
    shipping_cost?: number
    packaging_cost?: number
    campaign_name?: string | null
    expected_reach?: number | null
    content_type?: string | null
    given_date: Date | string
    expected_content_date?: Date | string | null
    actual_content_date?: Date | string | null
    content_delivered?: boolean
    performance_notes?: string | null
    roi_estimate?: number | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SalesDataUpdateWithoutImport_batchInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    seller_sku?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    order_amount?: FloatFieldUpdateOperationsInput | number
    created_time?: DateTimeFieldUpdateOperationsInput | Date | string
    delivered_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settlement_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    total_revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    hpp?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    regency_city?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesDataUncheckedUpdateWithoutImport_batchInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    seller_sku?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    order_amount?: FloatFieldUpdateOperationsInput | number
    created_time?: DateTimeFieldUpdateOperationsInput | Date | string
    delivered_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settlement_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    total_revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    hpp?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    regency_city?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesDataUncheckedUpdateManyWithoutImport_batchInput = {
    id?: StringFieldUpdateOperationsInput | string
    order_id?: StringFieldUpdateOperationsInput | string
    seller_sku?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    order_amount?: FloatFieldUpdateOperationsInput | number
    created_time?: DateTimeFieldUpdateOperationsInput | Date | string
    delivered_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    settlement_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    total_revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    hpp?: NullableFloatFieldUpdateOperationsInput | number | null
    total?: NullableFloatFieldUpdateOperationsInput | number | null
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: NullableStringFieldUpdateOperationsInput | string | null
    province?: NullableStringFieldUpdateOperationsInput | string | null
    regency_city?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductDataUpdateWithoutImport_batchInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_code?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    stock_quantity?: IntFieldUpdateOperationsInput | number
    min_stock?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stock_movements?: StockDataUpdateManyWithoutProductNestedInput
  }

  export type ProductDataUncheckedUpdateWithoutImport_batchInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_code?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    stock_quantity?: IntFieldUpdateOperationsInput | number
    min_stock?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stock_movements?: StockDataUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductDataUncheckedUpdateManyWithoutImport_batchInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_code?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    cost?: FloatFieldUpdateOperationsInput | number
    stock_quantity?: IntFieldUpdateOperationsInput | number
    min_stock?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockDataUpdateWithoutImport_batchInput = {
    id?: StringFieldUpdateOperationsInput | string
    movement_type?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movement_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductDataUpdateOneWithoutStock_movementsNestedInput
  }

  export type StockDataUncheckedUpdateWithoutImport_batchInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_code?: StringFieldUpdateOperationsInput | string
    movement_type?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movement_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockDataUncheckedUpdateManyWithoutImport_batchInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_code?: StringFieldUpdateOperationsInput | string
    movement_type?: EnumStockMovementTypeFieldUpdateOperationsInput | $Enums.StockMovementType
    quantity?: IntFieldUpdateOperationsInput | number
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    movement_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvertisingDataUpdateWithoutImport_batchInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaign_name?: StringFieldUpdateOperationsInput | string
    ad_creative_type?: NullableStringFieldUpdateOperationsInput | string | null
    ad_creative?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    cpa?: NullableFloatFieldUpdateOperationsInput | number | null
    revenue?: FloatFieldUpdateOperationsInput | number
    roi?: NullableFloatFieldUpdateOperationsInput | number | null
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    conversion_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    date_start?: DateTimeFieldUpdateOperationsInput | Date | string
    date_end?: DateTimeFieldUpdateOperationsInput | Date | string
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    nama_produk?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvertisingDataUncheckedUpdateWithoutImport_batchInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaign_name?: StringFieldUpdateOperationsInput | string
    ad_creative_type?: NullableStringFieldUpdateOperationsInput | string | null
    ad_creative?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    cpa?: NullableFloatFieldUpdateOperationsInput | number | null
    revenue?: FloatFieldUpdateOperationsInput | number
    roi?: NullableFloatFieldUpdateOperationsInput | number | null
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    conversion_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    date_start?: DateTimeFieldUpdateOperationsInput | Date | string
    date_end?: DateTimeFieldUpdateOperationsInput | Date | string
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    nama_produk?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvertisingDataUncheckedUpdateManyWithoutImport_batchInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaign_name?: StringFieldUpdateOperationsInput | string
    ad_creative_type?: NullableStringFieldUpdateOperationsInput | string | null
    ad_creative?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    cpa?: NullableFloatFieldUpdateOperationsInput | number | null
    revenue?: FloatFieldUpdateOperationsInput | number
    roi?: NullableFloatFieldUpdateOperationsInput | number | null
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    conversion_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    date_start?: DateTimeFieldUpdateOperationsInput | Date | string
    date_end?: DateTimeFieldUpdateOperationsInput | Date | string
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    nama_produk?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvertisingSettlementUpdateWithoutImport_batchInput = {
    order_id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    order_created_time?: DateTimeFieldUpdateOperationsInput | Date | string
    order_settled_time?: DateTimeFieldUpdateOperationsInput | Date | string
    settlement_amount?: FloatFieldUpdateOperationsInput | number
    settlement_period?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvertisingSettlementUncheckedUpdateWithoutImport_batchInput = {
    order_id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    order_created_time?: DateTimeFieldUpdateOperationsInput | Date | string
    order_settled_time?: DateTimeFieldUpdateOperationsInput | Date | string
    settlement_amount?: FloatFieldUpdateOperationsInput | number
    settlement_period?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvertisingSettlementUncheckedUpdateManyWithoutImport_batchInput = {
    order_id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    order_created_time?: DateTimeFieldUpdateOperationsInput | Date | string
    order_settled_time?: DateTimeFieldUpdateOperationsInput | Date | string
    settlement_amount?: FloatFieldUpdateOperationsInput | number
    settlement_period?: NullableStringFieldUpdateOperationsInput | string | null
    account_name?: NullableStringFieldUpdateOperationsInput | string | null
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnsAndCancellationsUpdateWithoutImport_batchInput = {
    id?: StringFieldUpdateOperationsInput | string
    original_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    original_sales_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    returned_amount?: FloatFieldUpdateOperationsInput | number
    refund_amount?: FloatFieldUpdateOperationsInput | number
    restocking_fee?: FloatFieldUpdateOperationsInput | number
    shipping_cost_loss?: FloatFieldUpdateOperationsInput | number
    product_name?: StringFieldUpdateOperationsInput | string
    quantity_returned?: IntFieldUpdateOperationsInput | number
    original_price?: FloatFieldUpdateOperationsInput | number
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    product_condition?: NullableStringFieldUpdateOperationsInput | string | null
    resellable?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnsAndCancellationsUncheckedUpdateWithoutImport_batchInput = {
    id?: StringFieldUpdateOperationsInput | string
    original_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    original_sales_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    returned_amount?: FloatFieldUpdateOperationsInput | number
    refund_amount?: FloatFieldUpdateOperationsInput | number
    restocking_fee?: FloatFieldUpdateOperationsInput | number
    shipping_cost_loss?: FloatFieldUpdateOperationsInput | number
    product_name?: StringFieldUpdateOperationsInput | string
    quantity_returned?: IntFieldUpdateOperationsInput | number
    original_price?: FloatFieldUpdateOperationsInput | number
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    product_condition?: NullableStringFieldUpdateOperationsInput | string | null
    resellable?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnsAndCancellationsUncheckedUpdateManyWithoutImport_batchInput = {
    id?: StringFieldUpdateOperationsInput | string
    original_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    original_sales_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    returned_amount?: FloatFieldUpdateOperationsInput | number
    refund_amount?: FloatFieldUpdateOperationsInput | number
    restocking_fee?: FloatFieldUpdateOperationsInput | number
    shipping_cost_loss?: FloatFieldUpdateOperationsInput | number
    product_name?: StringFieldUpdateOperationsInput | string
    quantity_returned?: IntFieldUpdateOperationsInput | number
    original_price?: FloatFieldUpdateOperationsInput | number
    marketplace?: NullableStringFieldUpdateOperationsInput | string | null
    product_condition?: NullableStringFieldUpdateOperationsInput | string | null
    resellable?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceReimbursementUpdateWithoutImport_batchInput = {
    id?: StringFieldUpdateOperationsInput | string
    claim_id?: NullableStringFieldUpdateOperationsInput | string | null
    reimbursement_type?: StringFieldUpdateOperationsInput | string
    claim_amount?: FloatFieldUpdateOperationsInput | number
    approved_amount?: FloatFieldUpdateOperationsInput | number
    received_amount?: FloatFieldUpdateOperationsInput | number
    processing_fee?: FloatFieldUpdateOperationsInput | number
    incident_date?: DateTimeFieldUpdateOperationsInput | Date | string
    claim_date?: DateTimeFieldUpdateOperationsInput | Date | string
    approval_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    received_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affected_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    marketplace?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    evidence_provided?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceReimbursementUncheckedUpdateWithoutImport_batchInput = {
    id?: StringFieldUpdateOperationsInput | string
    claim_id?: NullableStringFieldUpdateOperationsInput | string | null
    reimbursement_type?: StringFieldUpdateOperationsInput | string
    claim_amount?: FloatFieldUpdateOperationsInput | number
    approved_amount?: FloatFieldUpdateOperationsInput | number
    received_amount?: FloatFieldUpdateOperationsInput | number
    processing_fee?: FloatFieldUpdateOperationsInput | number
    incident_date?: DateTimeFieldUpdateOperationsInput | Date | string
    claim_date?: DateTimeFieldUpdateOperationsInput | Date | string
    approval_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    received_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affected_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    marketplace?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    evidence_provided?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketplaceReimbursementUncheckedUpdateManyWithoutImport_batchInput = {
    id?: StringFieldUpdateOperationsInput | string
    claim_id?: NullableStringFieldUpdateOperationsInput | string | null
    reimbursement_type?: StringFieldUpdateOperationsInput | string
    claim_amount?: FloatFieldUpdateOperationsInput | number
    approved_amount?: FloatFieldUpdateOperationsInput | number
    received_amount?: FloatFieldUpdateOperationsInput | number
    processing_fee?: FloatFieldUpdateOperationsInput | number
    incident_date?: DateTimeFieldUpdateOperationsInput | Date | string
    claim_date?: DateTimeFieldUpdateOperationsInput | Date | string
    approval_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    received_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    affected_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    marketplace?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    evidence_provided?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionAdjustmentsUpdateWithoutImport_batchInput = {
    id?: StringFieldUpdateOperationsInput | string
    original_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    original_sales_id?: NullableStringFieldUpdateOperationsInput | string | null
    adjustment_type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    original_commission?: FloatFieldUpdateOperationsInput | number
    adjustment_amount?: FloatFieldUpdateOperationsInput | number
    final_commission?: FloatFieldUpdateOperationsInput | number
    marketplace?: StringFieldUpdateOperationsInput | string
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    dynamic_rate_applied?: BoolFieldUpdateOperationsInput | boolean
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    adjustment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    product_price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionAdjustmentsUncheckedUpdateWithoutImport_batchInput = {
    id?: StringFieldUpdateOperationsInput | string
    original_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    original_sales_id?: NullableStringFieldUpdateOperationsInput | string | null
    adjustment_type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    original_commission?: FloatFieldUpdateOperationsInput | number
    adjustment_amount?: FloatFieldUpdateOperationsInput | number
    final_commission?: FloatFieldUpdateOperationsInput | number
    marketplace?: StringFieldUpdateOperationsInput | string
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    dynamic_rate_applied?: BoolFieldUpdateOperationsInput | boolean
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    adjustment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    product_price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommissionAdjustmentsUncheckedUpdateManyWithoutImport_batchInput = {
    id?: StringFieldUpdateOperationsInput | string
    original_order_id?: NullableStringFieldUpdateOperationsInput | string | null
    original_sales_id?: NullableStringFieldUpdateOperationsInput | string | null
    adjustment_type?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    original_commission?: FloatFieldUpdateOperationsInput | number
    adjustment_amount?: FloatFieldUpdateOperationsInput | number
    final_commission?: FloatFieldUpdateOperationsInput | number
    marketplace?: StringFieldUpdateOperationsInput | string
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    dynamic_rate_applied?: BoolFieldUpdateOperationsInput | boolean
    transaction_date?: DateTimeFieldUpdateOperationsInput | Date | string
    adjustment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    product_price?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateSamplesUpdateWithoutImport_batchInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliate_name?: StringFieldUpdateOperationsInput | string
    affiliate_platform?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_contact?: NullableStringFieldUpdateOperationsInput | string | null
    product_name?: StringFieldUpdateOperationsInput | string
    product_sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity_given?: IntFieldUpdateOperationsInput | number
    product_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    shipping_cost?: FloatFieldUpdateOperationsInput | number
    packaging_cost?: FloatFieldUpdateOperationsInput | number
    campaign_name?: NullableStringFieldUpdateOperationsInput | string | null
    expected_reach?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    given_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expected_content_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_content_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content_delivered?: BoolFieldUpdateOperationsInput | boolean
    performance_notes?: NullableStringFieldUpdateOperationsInput | string | null
    roi_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateSamplesUncheckedUpdateWithoutImport_batchInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliate_name?: StringFieldUpdateOperationsInput | string
    affiliate_platform?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_contact?: NullableStringFieldUpdateOperationsInput | string | null
    product_name?: StringFieldUpdateOperationsInput | string
    product_sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity_given?: IntFieldUpdateOperationsInput | number
    product_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    shipping_cost?: FloatFieldUpdateOperationsInput | number
    packaging_cost?: FloatFieldUpdateOperationsInput | number
    campaign_name?: NullableStringFieldUpdateOperationsInput | string | null
    expected_reach?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    given_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expected_content_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_content_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content_delivered?: BoolFieldUpdateOperationsInput | boolean
    performance_notes?: NullableStringFieldUpdateOperationsInput | string | null
    roi_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateSamplesUncheckedUpdateManyWithoutImport_batchInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliate_name?: StringFieldUpdateOperationsInput | string
    affiliate_platform?: NullableStringFieldUpdateOperationsInput | string | null
    affiliate_contact?: NullableStringFieldUpdateOperationsInput | string | null
    product_name?: StringFieldUpdateOperationsInput | string
    product_sku?: NullableStringFieldUpdateOperationsInput | string | null
    quantity_given?: IntFieldUpdateOperationsInput | number
    product_cost?: FloatFieldUpdateOperationsInput | number
    total_cost?: FloatFieldUpdateOperationsInput | number
    shipping_cost?: FloatFieldUpdateOperationsInput | number
    packaging_cost?: FloatFieldUpdateOperationsInput | number
    campaign_name?: NullableStringFieldUpdateOperationsInput | string | null
    expected_reach?: NullableIntFieldUpdateOperationsInput | number | null
    content_type?: NullableStringFieldUpdateOperationsInput | string | null
    given_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expected_content_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actual_content_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content_delivered?: BoolFieldUpdateOperationsInput | boolean
    performance_notes?: NullableStringFieldUpdateOperationsInput | string | null
    roi_estimate?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderCreateManySupplierInput = {
    id?: string
    po_number: string
    po_date: Date | string
    expected_date: Date | string
    delivery_date?: Date | string | null
    status?: $Enums.POStatus
    total_amount?: number
    items_count?: number
    notes?: string | null
    created_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PurchaseOrderUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    po_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expected_date?: DateTimeFieldUpdateOperationsInput | Date | string
    delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPOStatusFieldUpdateOperationsInput | $Enums.POStatus
    total_amount?: FloatFieldUpdateOperationsInput | number
    items_count?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUpdateManyWithoutPurchase_orderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    po_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expected_date?: DateTimeFieldUpdateOperationsInput | Date | string
    delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPOStatusFieldUpdateOperationsInput | $Enums.POStatus
    total_amount?: FloatFieldUpdateOperationsInput | number
    items_count?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PurchaseOrderItemUncheckedUpdateManyWithoutPurchase_orderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    po_date?: DateTimeFieldUpdateOperationsInput | Date | string
    expected_date?: DateTimeFieldUpdateOperationsInput | Date | string
    delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPOStatusFieldUpdateOperationsInput | $Enums.POStatus
    total_amount?: FloatFieldUpdateOperationsInput | number
    items_count?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemCreateManyPurchase_orderInput = {
    id?: string
    material_id: string
    material_name?: string | null
    material_description?: string | null
    quantity: number
    unit_price: number
    total_price: number
    received_quantity?: number | null
    unit: string
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PurchaseOrderItemUpdateWithoutPurchase_orderInput = {
    id?: StringFieldUpdateOperationsInput | string
    material_id?: StringFieldUpdateOperationsInput | string
    material_name?: NullableStringFieldUpdateOperationsInput | string | null
    material_description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    received_quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemUncheckedUpdateWithoutPurchase_orderInput = {
    id?: StringFieldUpdateOperationsInput | string
    material_id?: StringFieldUpdateOperationsInput | string
    material_name?: NullableStringFieldUpdateOperationsInput | string | null
    material_description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    received_quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderItemUncheckedUpdateManyWithoutPurchase_orderInput = {
    id?: StringFieldUpdateOperationsInput | string
    material_id?: StringFieldUpdateOperationsInput | string
    material_name?: NullableStringFieldUpdateOperationsInput | string | null
    material_description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: FloatFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    received_quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    unit?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportMetadataCreateManyImport_historyInput = {
    id?: string
    metadata_type: string
    metadata: JsonNullValueInput | InputJsonValue
    created_at?: Date | string
  }

  export type ImportMetadataUpdateWithoutImport_historyInput = {
    id?: StringFieldUpdateOperationsInput | string
    metadata_type?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportMetadataUncheckedUpdateWithoutImport_historyInput = {
    id?: StringFieldUpdateOperationsInput | string
    metadata_type?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportMetadataUncheckedUpdateManyWithoutImport_historyInput = {
    id?: StringFieldUpdateOperationsInput | string
    metadata_type?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemCreateManyInvoiceInput = {
    id?: string
    product_name: string
    quantity: number
    unit_price: number
    total: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InvoiceItemUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateProductSaleCreateManyEndorsementInput = {
    id?: string
    product_name: string
    quantity?: number
    unit_price?: number
    total_sales?: number
    commission?: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AffiliateProductSaleUpdateWithoutEndorsementInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    total_sales?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateProductSaleUncheckedUpdateWithoutEndorsementInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    total_sales?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AffiliateProductSaleUncheckedUpdateManyWithoutEndorsementInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit_price?: FloatFieldUpdateOperationsInput | number
    total_sales?: FloatFieldUpdateOperationsInput | number
    commission?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TailorProductionCreateManyTailorInput = {
    id?: string
    product_name: string
    color: string
    size: string
    finished_stock?: number
    meters_needed?: number
    cost_per_piece?: number
    defective_stock?: number | null
    additional_costs?: number | null
    additional_cost_description?: string | null
    delivery_date?: Date | string | null
    notes?: string | null
    status?: $Enums.TailorProductionStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TailorProductionUpdateWithoutTailorInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    finished_stock?: IntFieldUpdateOperationsInput | number
    meters_needed?: FloatFieldUpdateOperationsInput | number
    cost_per_piece?: FloatFieldUpdateOperationsInput | number
    defective_stock?: NullableIntFieldUpdateOperationsInput | number | null
    additional_costs?: NullableFloatFieldUpdateOperationsInput | number | null
    additional_cost_description?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTailorProductionStatusFieldUpdateOperationsInput | $Enums.TailorProductionStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TailorProductionUncheckedUpdateWithoutTailorInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    finished_stock?: IntFieldUpdateOperationsInput | number
    meters_needed?: FloatFieldUpdateOperationsInput | number
    cost_per_piece?: FloatFieldUpdateOperationsInput | number
    defective_stock?: NullableIntFieldUpdateOperationsInput | number | null
    additional_costs?: NullableFloatFieldUpdateOperationsInput | number | null
    additional_cost_description?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTailorProductionStatusFieldUpdateOperationsInput | $Enums.TailorProductionStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TailorProductionUncheckedUpdateManyWithoutTailorInput = {
    id?: StringFieldUpdateOperationsInput | string
    product_name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    size?: StringFieldUpdateOperationsInput | string
    finished_stock?: IntFieldUpdateOperationsInput | number
    meters_needed?: FloatFieldUpdateOperationsInput | number
    cost_per_piece?: FloatFieldUpdateOperationsInput | number
    defective_stock?: NullableIntFieldUpdateOperationsInput | number | null
    additional_costs?: NullableFloatFieldUpdateOperationsInput | number | null
    additional_cost_description?: NullableStringFieldUpdateOperationsInput | string | null
    delivery_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTailorProductionStatusFieldUpdateOperationsInput | $Enums.TailorProductionStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use ProductDataCountOutputTypeDefaultArgs instead
     */
    export type ProductDataCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDataCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ImportBatchCountOutputTypeDefaultArgs instead
     */
    export type ImportBatchCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ImportBatchCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierCountOutputTypeDefaultArgs instead
     */
    export type SupplierCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PurchaseOrderCountOutputTypeDefaultArgs instead
     */
    export type PurchaseOrderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ImportHistoryCountOutputTypeDefaultArgs instead
     */
    export type ImportHistoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ImportHistoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceCountOutputTypeDefaultArgs instead
     */
    export type InvoiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AffiliateEndorsementCountOutputTypeDefaultArgs instead
     */
    export type AffiliateEndorsementCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AffiliateEndorsementCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TailorCountOutputTypeDefaultArgs instead
     */
    export type TailorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TailorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SalesDataDefaultArgs instead
     */
    export type SalesDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SalesDataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDataDefaultArgs instead
     */
    export type ProductDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StockDataDefaultArgs instead
     */
    export type StockDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StockDataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ImportBatchDefaultArgs instead
     */
    export type ImportBatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ImportBatchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdvertisingDataDefaultArgs instead
     */
    export type AdvertisingDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdvertisingDataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdvertisingSettlementDefaultArgs instead
     */
    export type AdvertisingSettlementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdvertisingSettlementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReturnsAndCancellationsDefaultArgs instead
     */
    export type ReturnsAndCancellationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReturnsAndCancellationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MarketplaceReimbursementDefaultArgs instead
     */
    export type MarketplaceReimbursementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MarketplaceReimbursementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommissionAdjustmentsDefaultArgs instead
     */
    export type CommissionAdjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommissionAdjustmentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AffiliateSamplesDefaultArgs instead
     */
    export type AffiliateSamplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AffiliateSamplesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryDefaultArgs instead
     */
    export type CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BrandDefaultArgs instead
     */
    export type BrandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BrandDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierDefaultArgs instead
     */
    export type SupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PurchaseOrderDefaultArgs instead
     */
    export type PurchaseOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PurchaseOrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PurchaseOrderItemDefaultArgs instead
     */
    export type PurchaseOrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PurchaseOrderItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CashFlowEntryDefaultArgs instead
     */
    export type CashFlowEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CashFlowEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DashboardMetricsDefaultArgs instead
     */
    export type DashboardMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DashboardMetricsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ImportHistoryDefaultArgs instead
     */
    export type ImportHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ImportHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceDefaultArgs instead
     */
    export type InvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceItemDefaultArgs instead
     */
    export type InvoiceItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AffiliateEndorsementDefaultArgs instead
     */
    export type AffiliateEndorsementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AffiliateEndorsementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AffiliateProductSaleDefaultArgs instead
     */
    export type AffiliateProductSaleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AffiliateProductSaleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActivityLogsDefaultArgs instead
     */
    export type ActivityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActivityLogsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DuplicateCheckLogsDefaultArgs instead
     */
    export type DuplicateCheckLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DuplicateCheckLogsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ImportMetadataDefaultArgs instead
     */
    export type ImportMetadataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ImportMetadataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TailorDefaultArgs instead
     */
    export type TailorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TailorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TailorProductionDefaultArgs instead
     */
    export type TailorProductionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TailorProductionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductHPPDefaultArgs instead
     */
    export type ProductHPPArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductHPPDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}